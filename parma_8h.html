<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SCOREC core: parma.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="scorec.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SCOREC core
   </div>
   <div id="projectbrief">Parallel unstructured mesh tools</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_eb87070704e93fbde16ef0e38c81af05.html">parma</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">parma.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The ParMA tools interface.  
<a href="#details">More...</a></p>

<p><a href="parma_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParma__GroupCode.html">Parma_GroupCode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-defined code to run on process sub-groups.  <a href="structParma__GroupCode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6831e5a44e875fd72aa0e9c7444b1807"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parma_8h.html#a6831e5a44e875fd72aa0e9c7444b1807">Parma_GetEntImbalance</a> (<a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *mesh, double(*entImb)[4])</td></tr>
<tr class="memdesc:a6831e5a44e875fd72aa0e9c7444b1807"><td class="mdescLeft">&#160;</td><td class="mdescRight">get entity imbalance  <a href="parma_8h.html#a6831e5a44e875fd72aa0e9c7444b1807">More...</a><br /></td></tr>
<tr class="separator:a6831e5a44e875fd72aa0e9c7444b1807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17555a158156593af33dba93376d70db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parma_8h.html#a17555a158156593af33dba93376d70db">Parma_GetWeightedEntImbalance</a> (<a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *mesh, apf::MeshTag *weight, double(*entImb)[4])</td></tr>
<tr class="memdesc:a17555a158156593af33dba93376d70db"><td class="mdescLeft">&#160;</td><td class="mdescRight">see Parma_GetEntImbalance(...)  <a href="parma_8h.html#a17555a158156593af33dba93376d70db">More...</a><br /></td></tr>
<tr class="separator:a17555a158156593af33dba93376d70db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a279e8950f2683d3983e8521049e1709c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parma_8h.html#a279e8950f2683d3983e8521049e1709c">Parma_GetWeightedEntImbalance</a> (<a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *mesh, apf::MeshTag *weight, int dim)</td></tr>
<tr class="memdesc:a279e8950f2683d3983e8521049e1709c"><td class="mdescLeft">&#160;</td><td class="mdescRight">see Parma_GetEntImbalance(...)  <a href="parma_8h.html#a279e8950f2683d3983e8521049e1709c">More...</a><br /></td></tr>
<tr class="separator:a279e8950f2683d3983e8521049e1709c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852241521a6e33599ed2c4eecbcc54a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parma_8h.html#a852241521a6e33599ed2c4eecbcc54a9">Parma_GetNeighborStats</a> (<a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *m, int &amp;max, int &amp;maxNumParts, double &amp;avg, int &amp;loc)</td></tr>
<tr class="memdesc:a852241521a6e33599ed2c4eecbcc54a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the maximum and average number of vtx-connected neighboring parts  <a href="parma_8h.html#a852241521a6e33599ed2c4eecbcc54a9">More...</a><br /></td></tr>
<tr class="separator:a852241521a6e33599ed2c4eecbcc54a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b7a2deb5c768ec66f02a88be664f14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parma_8h.html#a85b7a2deb5c768ec66f02a88be664f14">Parma_WriteSmallNeighbors</a> (<a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *m, int small, const char *prefix)</td></tr>
<tr class="memdesc:a85b7a2deb5c768ec66f02a88be664f14"><td class="mdescLeft">&#160;</td><td class="mdescRight">write the number of parts with neighbors formed by a small number of shared vtx  <a href="parma_8h.html#a85b7a2deb5c768ec66f02a88be664f14">More...</a><br /></td></tr>
<tr class="separator:a85b7a2deb5c768ec66f02a88be664f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada5226f432581c80c83eb7f69de68759"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parma_8h.html#ada5226f432581c80c83eb7f69de68759">Parma_GetSmallestSideMaxNeighborParts</a> (<a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *m)</td></tr>
<tr class="memdesc:ada5226f432581c80c83eb7f69de68759"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the smallest number of shared vertices forming a neighbor ,a 'side', in a part with the maximum number of neigbhors  <a href="parma_8h.html#ada5226f432581c80c83eb7f69de68759">More...</a><br /></td></tr>
<tr class="separator:ada5226f432581c80c83eb7f69de68759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add329450935ff50336e6473a0d8486fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parma_8h.html#add329450935ff50336e6473a0d8486fd">Parma_GetOwnedBdryVtxStats</a> (<a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *m, int &amp;loc, long &amp;tot, int &amp;min, int &amp;max, double &amp;avg)</td></tr>
<tr class="memdesc:add329450935ff50336e6473a0d8486fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the number of owned vertices on inter-part boundaries  <a href="parma_8h.html#add329450935ff50336e6473a0d8486fd">More...</a><br /></td></tr>
<tr class="separator:add329450935ff50336e6473a0d8486fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d7b41224e992e887589aeec49eae93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parma_8h.html#af7d7b41224e992e887589aeec49eae93">Parma_GetSharedBdryVtxStats</a> (<a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *m, int &amp;loc, long &amp;tot, int &amp;min, int &amp;max, double &amp;avg)</td></tr>
<tr class="memdesc:af7d7b41224e992e887589aeec49eae93"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the number of shared vertices on inter-part boundaries  <a href="parma_8h.html#af7d7b41224e992e887589aeec49eae93">More...</a><br /></td></tr>
<tr class="separator:af7d7b41224e992e887589aeec49eae93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a1a6585a95a33fb6aa397dc940cfc6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parma_8h.html#a86a1a6585a95a33fb6aa397dc940cfc6">Parma_GetMdlBdryVtxStats</a> (<a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *m, int &amp;loc, long &amp;tot, int &amp;min, int &amp;max, double &amp;avg)</td></tr>
<tr class="memdesc:a86a1a6585a95a33fb6aa397dc940cfc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the number of vertices classified on the model boundary  <a href="parma_8h.html#a86a1a6585a95a33fb6aa397dc940cfc6">More...</a><br /></td></tr>
<tr class="separator:a86a1a6585a95a33fb6aa397dc940cfc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56bd3fab8e7291fe79e1ffa07bb79184"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parma_8h.html#a56bd3fab8e7291fe79e1ffa07bb79184">Parma_GetDisconnectedStats</a> (<a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *m, int &amp;max, double &amp;avg, int &amp;loc)</td></tr>
<tr class="memdesc:a56bd3fab8e7291fe79e1ffa07bb79184"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the maximum, average and local number of face-disconnected components  <a href="parma_8h.html#a56bd3fab8e7291fe79e1ffa07bb79184">More...</a><br /></td></tr>
<tr class="separator:a56bd3fab8e7291fe79e1ffa07bb79184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5314791419cae8865b12d567f271efb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parma_8h.html#a5314791419cae8865b12d567f271efb1">Parma_PrintPtnStats</a> (<a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *m, std::string key, bool fine=false)</td></tr>
<tr class="memdesc:a5314791419cae8865b12d567f271efb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">prints partition stats  <a href="parma_8h.html#a5314791419cae8865b12d567f271efb1">More...</a><br /></td></tr>
<tr class="separator:a5314791419cae8865b12d567f271efb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb10fd3b4e7e6d5a539d149c3e6c68ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parma_8h.html#afb10fd3b4e7e6d5a539d149c3e6c68ae">Parma_PrintWeightedPtnStats</a> (<a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *m, apf::MeshTag *w, std::string key, bool fine=false)</td></tr>
<tr class="memdesc:afb10fd3b4e7e6d5a539d149c3e6c68ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">prints partition stats using entity weights  <a href="parma_8h.html#afb10fd3b4e7e6d5a539d149c3e6c68ae">More...</a><br /></td></tr>
<tr class="separator:afb10fd3b4e7e6d5a539d149c3e6c68ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab95ff164bc36386a7ca30f56b6184795"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parma_8h.html#ab95ff164bc36386a7ca30f56b6184795">Parma_ProcessDisconnectedParts</a> (<a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *m)</td></tr>
<tr class="memdesc:ab95ff164bc36386a7ca30f56b6184795"><td class="mdescLeft">&#160;</td><td class="mdescRight">re-connect disconnected parts  <a href="parma_8h.html#ab95ff164bc36386a7ca30f56b6184795">More...</a><br /></td></tr>
<tr class="separator:ab95ff164bc36386a7ca30f56b6184795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa0f97d8e3d38ae55f2ef26c8d46485"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapf_1_1Balancer.html">apf::Balancer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parma_8h.html#a7aa0f97d8e3d38ae55f2ef26c8d46485">Parma_MakeCentroidDiffuser</a> (<a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *m, double stepFactor=0.1, int verbose=0)</td></tr>
<tr class="memdesc:a7aa0f97d8e3d38ae55f2ef26c8d46485"><td class="mdescLeft">&#160;</td><td class="mdescRight">create an APF Balancer using centroid diffusion  <a href="parma_8h.html#a7aa0f97d8e3d38ae55f2ef26c8d46485">More...</a><br /></td></tr>
<tr class="separator:a7aa0f97d8e3d38ae55f2ef26c8d46485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1851398f1bf415045b33429aff7a391"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapf_1_1Balancer.html">apf::Balancer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parma_8h.html#ac1851398f1bf415045b33429aff7a391">Parma_MakeShapeOptimizer</a> (<a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *m, double stepFactor=0.1, int verbose=0)</td></tr>
<tr class="memdesc:ac1851398f1bf415045b33429aff7a391"><td class="mdescLeft">&#160;</td><td class="mdescRight">create an APF Balancer to optimize part shape  <a href="parma_8h.html#ac1851398f1bf415045b33429aff7a391">More...</a><br /></td></tr>
<tr class="separator:ac1851398f1bf415045b33429aff7a391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a374c49f44a8ea12a6b90e70b9159709a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapf_1_1Balancer.html">apf::Balancer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parma_8h.html#a374c49f44a8ea12a6b90e70b9159709a">Parma_MakeMPASDiffuser</a> (<a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *m, int layers, int bridge, double stepFactor=0.1, int verbosity=0)</td></tr>
<tr class="memdesc:a374c49f44a8ea12a6b90e70b9159709a"><td class="mdescLeft">&#160;</td><td class="mdescRight">create an APF Balancer for MPAS  <a href="parma_8h.html#a374c49f44a8ea12a6b90e70b9159709a">More...</a><br /></td></tr>
<tr class="separator:a374c49f44a8ea12a6b90e70b9159709a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b685150b36af706bd20ccd6187f0bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapf_1_1Balancer.html">apf::Balancer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parma_8h.html#af7b685150b36af706bd20ccd6187f0bf">Parma_MakeGhostEdgeDiffuser</a> (<a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *m, double stepFactor=0.1, int verbosity=0)</td></tr>
<tr class="memdesc:af7b685150b36af706bd20ccd6187f0bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">create an edge balancer that is ghost aware  <a href="parma_8h.html#af7b685150b36af706bd20ccd6187f0bf">More...</a><br /></td></tr>
<tr class="separator:af7b685150b36af706bd20ccd6187f0bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d16aa1fa2cf5012b37cbdd6a11de8fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapf_1_1Balancer.html">apf::Balancer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parma_8h.html#a5d16aa1fa2cf5012b37cbdd6a11de8fe">Parma_MakeGhostDiffuser</a> (<a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *m, int layers, double stepFactor=0.1, int verbosity=0)</td></tr>
<tr class="memdesc:a5d16aa1fa2cf5012b37cbdd6a11de8fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">create an APF Balancer using ghost element aware diffusion for a vertex-based partition  <a href="parma_8h.html#a5d16aa1fa2cf5012b37cbdd6a11de8fe">More...</a><br /></td></tr>
<tr class="separator:a5d16aa1fa2cf5012b37cbdd6a11de8fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ebbc0e5ed46bfdbc74885cc12000b9"><td class="memItemLeft" align="right" valign="top"><a id="a63ebbc0e5ed46bfdbc74885cc12000b9"></a>
<a class="el" href="classapf_1_1Balancer.html">apf::Balancer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parma_8h.html#a63ebbc0e5ed46bfdbc74885cc12000b9">Parma_MakeGhostDiffuser</a> (<a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *m, int layers, int bridge, double stepFactor=0.1, int verbosity=0)</td></tr>
<tr class="memdesc:a63ebbc0e5ed46bfdbc74885cc12000b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">backward compatability <br /></td></tr>
<tr class="separator:a63ebbc0e5ed46bfdbc74885cc12000b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3196d47d453f83f9a02a5fb5ff30eba8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parma_8h.html#a3196d47d453f83f9a02a5fb5ff30eba8">Parma_WriteVtxPtn</a> (<a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *m, const char *prefix)</td></tr>
<tr class="memdesc:a3196d47d453f83f9a02a5fb5ff30eba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">write the vertex based partition to file  <a href="parma_8h.html#a3196d47d453f83f9a02a5fb5ff30eba8">More...</a><br /></td></tr>
<tr class="separator:a3196d47d453f83f9a02a5fb5ff30eba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e4ce7d2ef314aa046d0eede6900e4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapf_1_1Balancer.html">apf::Balancer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parma_8h.html#af5e4ce7d2ef314aa046d0eede6900e4f">Parma_MakeVtxBalancer</a> (<a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *m, double stepFactor=0.1, int verbosity=0)</td></tr>
<tr class="memdesc:af5e4ce7d2ef314aa046d0eede6900e4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">create an APF Balancer targeting vertex imbalance  <a href="parma_8h.html#af5e4ce7d2ef314aa046d0eede6900e4f">More...</a><br /></td></tr>
<tr class="separator:af5e4ce7d2ef314aa046d0eede6900e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c94adbc5c9bffabc86aac8aeb8d3012"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapf_1_1Balancer.html">apf::Balancer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parma_8h.html#a3c94adbc5c9bffabc86aac8aeb8d3012">Parma_MakeElmBalancer</a> (<a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *m, double stepFactor=0.1, int verbosity=0)</td></tr>
<tr class="memdesc:a3c94adbc5c9bffabc86aac8aeb8d3012"><td class="mdescLeft">&#160;</td><td class="mdescRight">create an APF Balancer targeting element imbalance  <a href="parma_8h.html#a3c94adbc5c9bffabc86aac8aeb8d3012">More...</a><br /></td></tr>
<tr class="separator:a3c94adbc5c9bffabc86aac8aeb8d3012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ffa86145e6dd7d6d39eb5a2f89d3c0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapf_1_1Balancer.html">apf::Balancer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parma_8h.html#a6ffa86145e6dd7d6d39eb5a2f89d3c0e">Parma_MakeVtxEdgeElmBalancer</a> (<a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *m, double stepFactor=0.1, int verbosity=0)</td></tr>
<tr class="memdesc:a6ffa86145e6dd7d6d39eb5a2f89d3c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">create an APF Balancer targeting vertex, edge, and elm imbalance  <a href="parma_8h.html#a6ffa86145e6dd7d6d39eb5a2f89d3c0e">More...</a><br /></td></tr>
<tr class="separator:a6ffa86145e6dd7d6d39eb5a2f89d3c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557a44a1560a37e4dd807be391444083"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapf_1_1Balancer.html">apf::Balancer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parma_8h.html#a557a44a1560a37e4dd807be391444083">Parma_MakeVtxElmBalancer</a> (<a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *m, double stepFactor=0.1, int verbosity=0)</td></tr>
<tr class="memdesc:a557a44a1560a37e4dd807be391444083"><td class="mdescLeft">&#160;</td><td class="mdescRight">create an APF Balancer targeting vertex, and elm imbalance  <a href="parma_8h.html#a557a44a1560a37e4dd807be391444083">More...</a><br /></td></tr>
<tr class="separator:a557a44a1560a37e4dd807be391444083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6102852a190a0521f53263c4e060926"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapf_1_1Splitter.html">apf::Splitter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parma_8h.html#aa6102852a190a0521f53263c4e060926">Parma_MakeRibSplitter</a> (<a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *m, bool sync=true)</td></tr>
<tr class="memdesc:aa6102852a190a0521f53263c4e060926"><td class="mdescLeft">&#160;</td><td class="mdescRight">create an APF Splitter using recursive inertial bisection  <a href="parma_8h.html#aa6102852a190a0521f53263c4e060926">More...</a><br /></td></tr>
<tr class="separator:aa6102852a190a0521f53263c4e060926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e1feb3987dc1bcc6c7734fb83b87be"><td class="memItemLeft" align="right" valign="top">apf::MeshTag *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parma_8h.html#ad4e1feb3987dc1bcc6c7734fb83b87be">Parma_WeighByMemory</a> (<a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *m)</td></tr>
<tr class="memdesc:ad4e1feb3987dc1bcc6c7734fb83b87be"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a mesh tag that weighs elements by their memory consumption  <a href="parma_8h.html#ad4e1feb3987dc1bcc6c7734fb83b87be">More...</a><br /></td></tr>
<tr class="separator:ad4e1feb3987dc1bcc6c7734fb83b87be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae837ec8b02087c670747359c8abc184c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parma_8h.html#ae837ec8b02087c670747359c8abc184c">Parma_ShrinkPartition</a> (<a class="el" href="classapf_1_1Mesh2.html">apf::Mesh2</a> *m, int factor, <a class="el" href="structParma__GroupCode.html">Parma_GroupCode</a> &amp;toRun, pcu::PCU *PCUObj=nullptr)</td></tr>
<tr class="memdesc:ae837ec8b02087c670747359c8abc184c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shrink the mesh into N/factor processes.  <a href="parma_8h.html#ae837ec8b02087c670747359c8abc184c">More...</a><br /></td></tr>
<tr class="separator:ae837ec8b02087c670747359c8abc184c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c37407682562f2220cc4a5d68ccf37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parma_8h.html#ab4c37407682562f2220cc4a5d68ccf37">Parma_SplitPartition</a> (<a class="el" href="classapf_1_1Mesh2.html">apf::Mesh2</a> *m, int factor, <a class="el" href="structParma__GroupCode.html">Parma_GroupCode</a> &amp;toRun, pcu::PCU *PCUObj=nullptr)</td></tr>
<tr class="memdesc:ab4c37407682562f2220cc4a5d68ccf37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the processes into groups of (factor).  <a href="parma_8h.html#ab4c37407682562f2220cc4a5d68ccf37">More...</a><br /></td></tr>
<tr class="separator:ab4c37407682562f2220cc4a5d68ccf37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a634cd71c4e7c825f2ad6a0c63ede7784"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parma_8h.html#a634cd71c4e7c825f2ad6a0c63ede7784">Parma_MisNumbering</a> (<a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *m, int d)</td></tr>
<tr class="memdesc:a634cd71c4e7c825f2ad6a0c63ede7784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute maximal independent set numbering.  <a href="parma_8h.html#a634cd71c4e7c825f2ad6a0c63ede7784">More...</a><br /></td></tr>
<tr class="separator:a634cd71c4e7c825f2ad6a0c63ede7784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4604ca782d4af2bee81071ad9f55d7de"><td class="memItemLeft" align="right" valign="top">apf::MeshTag *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parma_8h.html#a4604ca782d4af2bee81071ad9f55d7de">Parma_BfsReorder</a> (<a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *m, int verbosity=0)</td></tr>
<tr class="memdesc:a4604ca782d4af2bee81071ad9f55d7de"><td class="mdescLeft">&#160;</td><td class="mdescRight">reorder the mesh via a breadth first search  <a href="parma_8h.html#a4604ca782d4af2bee81071ad9f55d7de">More...</a><br /></td></tr>
<tr class="separator:a4604ca782d4af2bee81071ad9f55d7de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The ParMA tools interface. </p>

<p class="definition">Definition in file <a class="el" href="parma_8h_source.html">parma.h</a>.</p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a4604ca782d4af2bee81071ad9f55d7de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4604ca782d4af2bee81071ad9f55d7de">&#9670;&nbsp;</a></span>Parma_BfsReorder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apf::MeshTag* Parma_BfsReorder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>verbosity</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reorder the mesh via a breadth first search </p>
<dl class="section remark"><dt>Remarks</dt><dd>the returned tag has the reordered vertex order </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>(In) partitioned mesh </td></tr>
    <tr><td class="paramname">verbosity</td><td>(In) output control, higher values output more </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>apf mesh tag </dd></dl>

</div>
</div>
<a id="a56bd3fab8e7291fe79e1ffa07bb79184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56bd3fab8e7291fe79e1ffa07bb79184">&#9670;&nbsp;</a></span>Parma_GetDisconnectedStats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_GetDisconnectedStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>avg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the maximum, average and local number of face-disconnected components </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>(In) partitioned mesh </td></tr>
    <tr><td class="paramname">max</td><td>(InOut) max disconnected </td></tr>
    <tr><td class="paramname">avg</td><td>(InOut) average disconnected </td></tr>
    <tr><td class="paramname">loc</td><td>(InOut) local disconnected </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6831e5a44e875fd72aa0e9c7444b1807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6831e5a44e875fd72aa0e9c7444b1807">&#9670;&nbsp;</a></span>Parma_GetEntImbalance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_GetEntImbalance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double(*)&#160;</td>
          <td class="paramname"><em>entImb</em>[4]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get entity imbalance </p>
<dl class="section remark"><dt>Remarks</dt><dd>The imbalance of a given entity order (i.e., vtx, edge, face, rgn) is defined as the maximum count of that entity order on a part, across all parts, divided by the average entity count across all parts. For example if there are four parts and the parts have 5, 7, 12, and 8 vertices, respectively, then the vertex imbalance is 50%; 12 / ((5+7+8+12)/4) = 1.5. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>(InOut) partitioned mesh </td></tr>
    <tr><td class="paramname">entImb</td><td>(InOut) entity imbalance [vtx, edge, face, rgn] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86a1a6585a95a33fb6aa397dc940cfc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86a1a6585a95a33fb6aa397dc940cfc6">&#9670;&nbsp;</a></span>Parma_GetMdlBdryVtxStats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_GetMdlBdryVtxStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>tot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>avg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the number of vertices classified on the model boundary </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>(In) partitioned mesh </td></tr>
    <tr><td class="paramname">loc</td><td>(InOut) local number of vertices </td></tr>
    <tr><td class="paramname">tot</td><td>(InOut) total number of vertices </td></tr>
    <tr><td class="paramname">min</td><td>(InOut) min number of vertices on a single part </td></tr>
    <tr><td class="paramname">max</td><td>(InOut) max number of vertices on a single part </td></tr>
    <tr><td class="paramname">avg</td><td>(InOut) average number of vertices per part </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a852241521a6e33599ed2c4eecbcc54a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a852241521a6e33599ed2c4eecbcc54a9">&#9670;&nbsp;</a></span>Parma_GetNeighborStats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_GetNeighborStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>maxNumParts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>avg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the maximum and average number of vtx-connected neighboring parts </p>
<dl class="section remark"><dt>Remarks</dt><dd>for each part count the number of parts it shares mesh vertices with </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>(In) partitioned mesh </td></tr>
    <tr><td class="paramname">max</td><td>(InOut) max neighbors </td></tr>
    <tr><td class="paramname">maxNumParts</td><td>(InOut) number of parts with max neighbors </td></tr>
    <tr><td class="paramname">avg</td><td>(InOut) average neighbors </td></tr>
    <tr><td class="paramname">loc</td><td>(InOut) local neighbors </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add329450935ff50336e6473a0d8486fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add329450935ff50336e6473a0d8486fd">&#9670;&nbsp;</a></span>Parma_GetOwnedBdryVtxStats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_GetOwnedBdryVtxStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>tot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>avg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the number of owned vertices on inter-part boundaries </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>(In) partitioned mesh </td></tr>
    <tr><td class="paramname">loc</td><td>(InOut) local number of vertices </td></tr>
    <tr><td class="paramname">tot</td><td>(InOut) total number of vertices </td></tr>
    <tr><td class="paramname">min</td><td>(InOut) min number of vertices on a single part </td></tr>
    <tr><td class="paramname">max</td><td>(InOut) max number of vertices on a single part </td></tr>
    <tr><td class="paramname">avg</td><td>(InOut) average number of vertices per part </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7d7b41224e992e887589aeec49eae93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7d7b41224e992e887589aeec49eae93">&#9670;&nbsp;</a></span>Parma_GetSharedBdryVtxStats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_GetSharedBdryVtxStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>tot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>avg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the number of shared vertices on inter-part boundaries </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>(In) partitioned mesh </td></tr>
    <tr><td class="paramname">loc</td><td>(InOut) local number of vertices </td></tr>
    <tr><td class="paramname">tot</td><td>(InOut) total number of vertices </td></tr>
    <tr><td class="paramname">min</td><td>(InOut) min number of vertices on a single part </td></tr>
    <tr><td class="paramname">max</td><td>(InOut) max number of vertices on a single part </td></tr>
    <tr><td class="paramname">avg</td><td>(InOut) average number of vertices per part </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada5226f432581c80c83eb7f69de68759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada5226f432581c80c83eb7f69de68759">&#9670;&nbsp;</a></span>Parma_GetSmallestSideMaxNeighborParts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Parma_GetSmallestSideMaxNeighborParts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the smallest number of shared vertices forming a neighbor ,a 'side', in a part with the maximum number of neigbhors </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>(In) partitioned mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>smallest number of shared vertices </dd></dl>

</div>
</div>
<a id="a17555a158156593af33dba93376d70db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17555a158156593af33dba93376d70db">&#9670;&nbsp;</a></span>Parma_GetWeightedEntImbalance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_GetWeightedEntImbalance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apf::MeshTag *&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double(*)&#160;</td>
          <td class="paramname"><em>entImb</em>[4]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>see Parma_GetEntImbalance(...) </p>
<dl class="section remark"><dt>Remarks</dt><dd>The weighted imbalance definition replaces the entity count with the sum of entity weights. If the weight for all the entities of a given order is one, then the two definitions are equivalent. On a part, if an entity order (vtx, edge, face, rgn) does not have weights set on all its entities then a weight of one will be assigned to each of the entities (of the given order). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>(InOut) partitioned mesh </td></tr>
    <tr><td class="paramname">weight</td><td>(In) entity weights used for computing imbalance </td></tr>
    <tr><td class="paramname">entImb</td><td>(InOut) entity imbalance [vtx, edge, face, rgn] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a279e8950f2683d3983e8521049e1709c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a279e8950f2683d3983e8521049e1709c">&#9670;&nbsp;</a></span>Parma_GetWeightedEntImbalance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Parma_GetWeightedEntImbalance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apf::MeshTag *&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>see Parma_GetEntImbalance(...) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>(InOut) partitioned mesh </td></tr>
    <tr><td class="paramname">weight</td><td>(In) element weight used for computing imbalance </td></tr>
    <tr><td class="paramname">dim</td><td>(In) entity dimension [vtx|edge|face|rgn] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>entity imbalance </dd></dl>

</div>
</div>
<a id="a7aa0f97d8e3d38ae55f2ef26c8d46485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aa0f97d8e3d38ae55f2ef26c8d46485">&#9670;&nbsp;</a></span>Parma_MakeCentroidDiffuser()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapf_1_1Balancer.html">apf::Balancer</a>* Parma_MakeCentroidDiffuser </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>stepFactor</em> = <code>0.1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create an APF Balancer using centroid diffusion </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>(In) partitioned mesh </td></tr>
    <tr><td class="paramname">stepFactor</td><td>(In) amount of weight to migrate between parts during diffusion, lower values migrate fewer elements per iteration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>apf balancer instance </dd></dl>

</div>
</div>
<a id="a3c94adbc5c9bffabc86aac8aeb8d3012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c94adbc5c9bffabc86aac8aeb8d3012">&#9670;&nbsp;</a></span>Parma_MakeElmBalancer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapf_1_1Balancer.html">apf::Balancer</a>* Parma_MakeElmBalancer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>stepFactor</em> = <code>0.1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>verbosity</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create an APF Balancer targeting element imbalance </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>(In) partitioned mesh </td></tr>
    <tr><td class="paramname">verbosity</td><td>(In) output control, higher values output more </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>apf balancer instance </dd></dl>

</div>
</div>
<a id="a5d16aa1fa2cf5012b37cbdd6a11de8fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d16aa1fa2cf5012b37cbdd6a11de8fe">&#9670;&nbsp;</a></span>Parma_MakeGhostDiffuser()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapf_1_1Balancer.html">apf::Balancer</a>* Parma_MakeGhostDiffuser </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>layers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>stepFactor</em> = <code>0.1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>verbosity</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create an APF Balancer using ghost element aware diffusion for a vertex-based partition </p>
<dl class="section remark"><dt>Remarks</dt><dd>Ghosting for a vertex-based partition is asymetric; ghosts are only needed for vertices on the boundary that are owned. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>(In) partitioned mesh </td></tr>
    <tr><td class="paramname">layers</td><td>(In) depth of ghosting </td></tr>
    <tr><td class="paramname">stepFactor</td><td>(In) amount of weight to migrate between parts during diffusion, lower values migrate fewer elements per iteration </td></tr>
    <tr><td class="paramname">verbosity</td><td>(In) output control, higher values output more </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>apf balancer instance </dd></dl>

</div>
</div>
<a id="af7b685150b36af706bd20ccd6187f0bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7b685150b36af706bd20ccd6187f0bf">&#9670;&nbsp;</a></span>Parma_MakeGhostEdgeDiffuser()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapf_1_1Balancer.html">apf::Balancer</a>* Parma_MakeGhostEdgeDiffuser </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>stepFactor</em> = <code>0.1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>verbosity</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create an edge balancer that is ghost aware </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>(In) partitioned mesh </td></tr>
    <tr><td class="paramname">stepFactor</td><td>(In) amount of weight to migrate between parts during diffusion, lower values migrate fewer elements per iteration </td></tr>
    <tr><td class="paramname">verbosity</td><td>(In) output control, higher values output more </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>apf balancer instance </dd></dl>

</div>
</div>
<a id="a374c49f44a8ea12a6b90e70b9159709a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a374c49f44a8ea12a6b90e70b9159709a">&#9670;&nbsp;</a></span>Parma_MakeMPASDiffuser()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapf_1_1Balancer.html">apf::Balancer</a>* Parma_MakeMPASDiffuser </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>layers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bridge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>stepFactor</em> = <code>0.1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>verbosity</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create an APF Balancer for MPAS </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>(In) partitioned mesh </td></tr>
    <tr><td class="paramname">layers</td><td>(In) depth of ghosting </td></tr>
    <tr><td class="paramname">bridge</td><td>(In) dimension of entity ghosting depth is based on, typically meshDim-1 </td></tr>
    <tr><td class="paramname">stepFactor</td><td>(In) amount of weight to migrate between parts during diffusion, lower values migrate fewer elements per iteration </td></tr>
    <tr><td class="paramname">verbosity</td><td>(In) output control, higher values output more </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>apf balancer instance </dd></dl>

</div>
</div>
<a id="aa6102852a190a0521f53263c4e060926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6102852a190a0521f53263c4e060926">&#9670;&nbsp;</a></span>Parma_MakeRibSplitter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapf_1_1Splitter.html">apf::Splitter</a>* Parma_MakeRibSplitter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create an APF Splitter using recursive inertial bisection </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>(In) partitioned mesh </td></tr>
    <tr><td class="paramname">sync</td><td>(In) true if all parts will be split, false o.w. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>apf splitter instance </dd></dl>

</div>
</div>
<a id="ac1851398f1bf415045b33429aff7a391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1851398f1bf415045b33429aff7a391">&#9670;&nbsp;</a></span>Parma_MakeShapeOptimizer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapf_1_1Balancer.html">apf::Balancer</a>* Parma_MakeShapeOptimizer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>stepFactor</em> = <code>0.1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create an APF Balancer to optimize part shape </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>(In) partitioned mesh </td></tr>
    <tr><td class="paramname">stepFactor</td><td>(In) amount of weight to migrate between parts during diffusion, lower values migrate fewer elements per iteration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>apf balancer instance </dd></dl>

</div>
</div>
<a id="af5e4ce7d2ef314aa046d0eede6900e4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5e4ce7d2ef314aa046d0eede6900e4f">&#9670;&nbsp;</a></span>Parma_MakeVtxBalancer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapf_1_1Balancer.html">apf::Balancer</a>* Parma_MakeVtxBalancer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>stepFactor</em> = <code>0.1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>verbosity</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create an APF Balancer targeting vertex imbalance </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>(In) partitioned mesh </td></tr>
    <tr><td class="paramname">verbosity</td><td>(In) output control, higher values output more </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>apf balancer instance </dd></dl>

</div>
</div>
<a id="a6ffa86145e6dd7d6d39eb5a2f89d3c0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ffa86145e6dd7d6d39eb5a2f89d3c0e">&#9670;&nbsp;</a></span>Parma_MakeVtxEdgeElmBalancer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapf_1_1Balancer.html">apf::Balancer</a>* Parma_MakeVtxEdgeElmBalancer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>stepFactor</em> = <code>0.1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>verbosity</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create an APF Balancer targeting vertex, edge, and elm imbalance </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>(In) partitioned mesh </td></tr>
    <tr><td class="paramname">verbosity</td><td>(In) output control, higher values output more </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>apf balancer instance </dd></dl>

</div>
</div>
<a id="a557a44a1560a37e4dd807be391444083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a557a44a1560a37e4dd807be391444083">&#9670;&nbsp;</a></span>Parma_MakeVtxElmBalancer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapf_1_1Balancer.html">apf::Balancer</a>* Parma_MakeVtxElmBalancer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>stepFactor</em> = <code>0.1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>verbosity</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create an APF Balancer targeting vertex, and elm imbalance </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>(In) partitioned mesh </td></tr>
    <tr><td class="paramname">verbosity</td><td>(In) output control, higher values output more </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>apf balancer instance </dd></dl>

</div>
</div>
<a id="a634cd71c4e7c825f2ad6a0c63ede7784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a634cd71c4e7c825f2ad6a0c63ede7784">&#9670;&nbsp;</a></span>Parma_MisNumbering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Parma_MisNumbering </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute maximal independent set numbering. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This function will compute the maximal independent set numbering for the partition such that no two part neighbors that share dimension d mesh entities will be assigned the same number. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>(In) partitioned mesh </td></tr>
    <tr><td class="paramname">d</td><td>(In) adjacency dimension </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5314791419cae8865b12d567f271efb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5314791419cae8865b12d567f271efb1">&#9670;&nbsp;</a></span>Parma_PrintPtnStats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_PrintPtnStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fine</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>prints partition stats </p>
<dl class="section remark"><dt>Remarks</dt><dd>includes face-disconnected components, number of vertices on inter-part boundaries, number of vtx-connected neighboring parts, entity imbalance, and number of empty parts </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>(In) partitioned mesh </td></tr>
    <tr><td class="paramname">key</td><td>(In) identifying string to write with stat output </td></tr>
    <tr><td class="paramname">fine</td><td>(In) enable per part stat output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb10fd3b4e7e6d5a539d149c3e6c68ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb10fd3b4e7e6d5a539d149c3e6c68ae">&#9670;&nbsp;</a></span>Parma_PrintWeightedPtnStats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_PrintWeightedPtnStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apf::MeshTag *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fine</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>prints partition stats using entity weights </p>
<dl class="section remark"><dt>Remarks</dt><dd>On a part, if an entity order (vtx, edge, face, rgn) does not have weights set on all its entities then a weight of one will be assigned to each of the entities (of the given order) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>(In) partitioned mesh </td></tr>
    <tr><td class="paramname">w</td><td>(In) tag with entity weights </td></tr>
    <tr><td class="paramname">key</td><td>(In) identifying string to write with stat output </td></tr>
    <tr><td class="paramname">fine</td><td>(In) enable per part stat output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab95ff164bc36386a7ca30f56b6184795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab95ff164bc36386a7ca30f56b6184795">&#9670;&nbsp;</a></span>Parma_ProcessDisconnectedParts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_ProcessDisconnectedParts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>re-connect disconnected parts </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>(In) partitioned mesh </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae837ec8b02087c670747359c8abc184c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae837ec8b02087c670747359c8abc184c">&#9670;&nbsp;</a></span>Parma_ShrinkPartition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_ShrinkPartition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh2.html">apf::Mesh2</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structParma__GroupCode.html">Parma_GroupCode</a> &amp;&#160;</td>
          <td class="paramname"><em>toRun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcu::PCU *&#160;</td>
          <td class="paramname"><em>PCUObj</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shrink the mesh into N/factor processes. </p>
<p>This function will take N=PCU_Comm_Peers() and generate (factor) subgroups, each of (N/factor) processes. It then migrates the mesh onto group 0 and then calls the user's group code on all groups. After the user's code completes, the mesh is repartitioned to all N processes and this function returns. groups are organized such that contiguous ranges of (factor) parts are combined into one and then that one is split back out into (factor) contiguous part ids again. </p>

</div>
</div>
<a id="ab4c37407682562f2220cc4a5d68ccf37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4c37407682562f2220cc4a5d68ccf37">&#9670;&nbsp;</a></span>Parma_SplitPartition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_SplitPartition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh2.html">apf::Mesh2</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structParma__GroupCode.html">Parma_GroupCode</a> &amp;&#160;</td>
          <td class="paramname"><em>toRun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcu::PCU *&#160;</td>
          <td class="paramname"><em>PCUObj</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the processes into groups of (factor). </p>
<p>This function groups contiguous ranges of (factor) processes into (PCU_Comm_Peers()/factor) total groups, then calls the user's group code. After the user's code completes, execution returns to the global communicator. If a non-zero mesh pointer is given, then <a class="el" href="namespaceapf.html#a69273da0fbc721b7fcd7b07fe426869b" title="remap all part ids in the mesh structure">apf::remapPartition</a> is used to maintain the mesh structure during these transitions. </p>

</div>
</div>
<a id="ad4e1feb3987dc1bcc6c7734fb83b87be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4e1feb3987dc1bcc6c7734fb83b87be">&#9670;&nbsp;</a></span>Parma_WeighByMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apf::MeshTag* Parma_WeighByMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a mesh tag that weighs elements by their memory consumption </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>(In) partitioned mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>mesh tag </dd></dl>

</div>
</div>
<a id="a85b7a2deb5c768ec66f02a88be664f14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b7a2deb5c768ec66f02a88be664f14">&#9670;&nbsp;</a></span>Parma_WriteSmallNeighbors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_WriteSmallNeighbors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>small</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>write the number of parts with neighbors formed by a small number of shared vtx </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>(In) partitioned mesh </td></tr>
    <tr><td class="paramname">small</td><td>(In) report part counts with [1:small] number of shared vertices </td></tr>
    <tr><td class="paramname">prefix</td><td>(In) string to prepend to output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3196d47d453f83f9a02a5fb5ff30eba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3196d47d453f83f9a02a5fb5ff30eba8">&#9670;&nbsp;</a></span>Parma_WriteVtxPtn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parma_WriteVtxPtn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>write the vertex based partition to file </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>(In) partitioned mesh </td></tr>
    <tr><td class="paramname">prefix</td><td>(In) prefix for file names </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<hr class="footer"/><address class="footer"><small>
Generated for SCOREC core by&nbsp;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.1</small></address>
</body>
</html>
