<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SCOREC core: crv Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="scorec.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SCOREC core
   </div>
   <div id="projectbrief">Parallel unstructured mesh tools</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">crv Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>the curving functions are contained in this namespace  
<a href="namespacecrv.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrv_1_1MeshCurver.html">MeshCurver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base Mesh curving object.  <a href="classcrv_1_1MeshCurver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrv_1_1InterpolatingCurver.html">InterpolatingCurver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">curves an already changed mesh  <a href="classcrv_1_1InterpolatingCurver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrv_1_1BezierCurver.html">BezierCurver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">this curves a mesh with Bezier shapes  <a href="classcrv_1_1BezierCurver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrv_1_1GregoryCurver.html">GregoryCurver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">this curves a mesh with 4th order G1 Patches  <a href="classcrv_1_1GregoryCurver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrv_1_1Quality.html">Quality</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class to store matrices used in quality assessment and validity checking  <a href="classcrv_1_1Quality.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcrv_1_1Adapt.html">Adapt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base <a class="el" href="classcrv_1_1Adapt.html" title="base crv::Adapt class, looks the same as ma::Adapt, but carries tag identifying validity (see crvShap...">crv::Adapt</a> class, looks the same as ma::Adapt, but carries tag identifying validity (see <a class="el" href="crvShape_8h.html" title="main file for shape fixing operations, largely based off of ma functions">crvShape.h</a>)  <a href="classcrv_1_1Adapt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a3bc760a6279cdc9b15779144e36fd70c"><td class="memItemLeft" align="right" valign="top"><a id="a3bc760a6279cdc9b15779144e36fd70c"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#a3bc760a6279cdc9b15779144e36fd70c">bezierShape</a>) (int P, <a class="el" href="classapf_1_1Vector3.html">apf::Vector3</a> const &amp;xi, apf::NewArray&lt; double &gt; &amp;values)</td></tr>
<tr class="memdesc:a3bc760a6279cdc9b15779144e36fd70c"><td class="mdescLeft">&#160;</td><td class="mdescRight">typedef for table of shape functions <br /></td></tr>
<tr class="separator:a3bc760a6279cdc9b15779144e36fd70c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4899e132dc03c39444daccd1123a80f9"><td class="memItemLeft" align="right" valign="top"><a id="a4899e132dc03c39444daccd1123a80f9"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#a4899e132dc03c39444daccd1123a80f9">bezierShapeGrads</a>) (int P, <a class="el" href="classapf_1_1Vector3.html">apf::Vector3</a> const &amp;xi, apf::NewArray&lt; <a class="el" href="classapf_1_1Vector3.html">apf::Vector3</a> &gt; &amp;grads)</td></tr>
<tr class="memdesc:a4899e132dc03c39444daccd1123a80f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">typedef for table of shape function gradients <br /></td></tr>
<tr class="separator:a4899e132dc03c39444daccd1123a80f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7b809013b39130610e178592e589a7"><td class="memItemLeft" align="right" valign="top"><a id="a2c7b809013b39130610e178592e589a7"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#a2c7b809013b39130610e178592e589a7">SubdivisionFunction</a>) (int P, apf::NewArray&lt; double &gt; &amp;nodes, apf::NewArray&lt; double &gt; *subNodes)</td></tr>
<tr class="memdesc:a2c7b809013b39130610e178592e589a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">typedef for table of jacobian det subdivision functions <br /></td></tr>
<tr class="separator:a2c7b809013b39130610e178592e589a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0d0c5cf8fc898fd73634619eeb1423eb"><td class="memItemLeft" align="right" valign="top"><a id="a0d0c5cf8fc898fd73634619eeb1423eb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#a0d0c5cf8fc898fd73634619eeb1423eb">setOrder</a> (const int order)</td></tr>
<tr class="memdesc:a0d0c5cf8fc898fd73634619eeb1423eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets order used in bezier shape functions <br /></td></tr>
<tr class="separator:a0d0c5cf8fc898fd73634619eeb1423eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98bcd8852e511e4233ca5e8f39f8b0e3"><td class="memItemLeft" align="right" valign="top"><a id="a98bcd8852e511e4233ca5e8f39f8b0e3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#a98bcd8852e511e4233ca5e8f39f8b0e3">getOrder</a> ()</td></tr>
<tr class="memdesc:a98bcd8852e511e4233ca5e8f39f8b0e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets order used in bezier shape functions <br /></td></tr>
<tr class="separator:a98bcd8852e511e4233ca5e8f39f8b0e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc7909de596641e99cc74acc359e83a"><td class="memItemLeft" align="right" valign="top"><a id="a6fc7909de596641e99cc74acc359e83a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#a6fc7909de596641e99cc74acc359e83a">setBlendingOrder</a> (const int type, const int b)</td></tr>
<tr class="memdesc:a6fc7909de596641e99cc74acc359e83a"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the blending order, if shape blending is used <br /></td></tr>
<tr class="separator:a6fc7909de596641e99cc74acc359e83a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9e6162f14d966706a26ad77f4294b8"><td class="memItemLeft" align="right" valign="top"><a id="aea9e6162f14d966706a26ad77f4294b8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#aea9e6162f14d966706a26ad77f4294b8">getBlendingOrder</a> (const int type)</td></tr>
<tr class="memdesc:aea9e6162f14d966706a26ad77f4294b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the blending order <br /></td></tr>
<tr class="separator:aea9e6162f14d966706a26ad77f4294b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6f5a82552be7243fe3109ad32c1d68"><td class="memItemLeft" align="right" valign="top"><a id="a3d6f5a82552be7243fe3109ad32c1d68"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#a3d6f5a82552be7243fe3109ad32c1d68">countNumberInvalidElements</a> (<a class="el" href="classapf_1_1Mesh2.html">apf::Mesh2</a> *m)</td></tr>
<tr class="memdesc:a3d6f5a82552be7243fe3109ad32c1d68"><td class="mdescLeft">&#160;</td><td class="mdescRight">count invalid elements of the mesh <br /></td></tr>
<tr class="separator:a3d6f5a82552be7243fe3109ad32c1d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf7317c6902acf424470d3957adaf5bd"><td class="memItemLeft" align="right" valign="top"><a id="abf7317c6902acf424470d3957adaf5bd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#abf7317c6902acf424470d3957adaf5bd">interpolatingToBezier</a> (<a class="el" href="classapf_1_1Mesh2.html">apf::Mesh2</a> *m)</td></tr>
<tr class="memdesc:abf7317c6902acf424470d3957adaf5bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts Interpolating nodes to Control points for a Bezier mesh <br /></td></tr>
<tr class="separator:abf7317c6902acf424470d3957adaf5bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d26e2f65c6ffa7964206cd5c20f0f1"><td class="memItemLeft" align="right" valign="top"><a id="ae5d26e2f65c6ffa7964206cd5c20f0f1"></a>
<a class="el" href="classma_1_1Input.html">ma::Input</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#ae5d26e2f65c6ffa7964206cd5c20f0f1">configureShapeCorrection</a> (<a class="el" href="namespacema.html#a3341de79ff346e22c3e00e3eddddd030">ma::Mesh</a> *m, ma::SizeField *f=0, <a class="el" href="classma_1_1SolutionTransfer.html">ma::SolutionTransfer</a> *s=0)</td></tr>
<tr class="memdesc:ae5d26e2f65c6ffa7964206cd5c20f0f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">configure for fixing invalid elements <br /></td></tr>
<tr class="separator:ae5d26e2f65c6ffa7964206cd5c20f0f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f1c5610252c55108cd0f72b02c1b44a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#a8f1c5610252c55108cd0f72b02c1b44a">adapt</a> (<a class="el" href="classma_1_1Input.html">ma::Input</a> *in)</td></tr>
<tr class="memdesc:a8f1c5610252c55108cd0f72b02c1b44a"><td class="mdescLeft">&#160;</td><td class="mdescRight">crv adapt with custom configuration  <a href="namespacecrv.html#a8f1c5610252c55108cd0f72b02c1b44a">More...</a><br /></td></tr>
<tr class="separator:a8f1c5610252c55108cd0f72b02c1b44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cba0b823284e0dd7809a1442e50233f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#a4cba0b823284e0dd7809a1442e50233f">adapt</a> (const <a class="el" href="classma_1_1Input.html">ma::Input</a> *in)</td></tr>
<tr class="memdesc:a4cba0b823284e0dd7809a1442e50233f"><td class="mdescLeft">&#160;</td><td class="mdescRight">crv adapt with custom configuration  <a href="namespacecrv.html#a4cba0b823284e0dd7809a1442e50233f">More...</a><br /></td></tr>
<tr class="separator:a4cba0b823284e0dd7809a1442e50233f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075f366285a160b1e0dfd2f806726d03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#a075f366285a160b1e0dfd2f806726d03">stats</a> (<a class="el" href="classma_1_1Input.html">ma::Input</a> *in, std::vector&lt; double &gt; &amp;edgeLengths, std::vector&lt; double &gt; &amp;linearQualities, std::vector&lt; double &gt; &amp;curvedQualities, bool inMetric=true)</td></tr>
<tr class="memdesc:a075f366285a160b1e0dfd2f806726d03"><td class="mdescLeft">&#160;</td><td class="mdescRight">crv stats to get statistic information about the mesh  <a href="namespacecrv.html#a075f366285a160b1e0dfd2f806726d03">More...</a><br /></td></tr>
<tr class="separator:a075f366285a160b1e0dfd2f806726d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa516f28b3126777d0ea13c385660da6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapf_1_1FieldShape.html">apf::FieldShape</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#aaa516f28b3126777d0ea13c385660da6">getBezier</a> (int order)</td></tr>
<tr class="memdesc:aaa516f28b3126777d0ea13c385660da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Bezier Curve or Shape of some order.  <a href="namespacecrv.html#aaa516f28b3126777d0ea13c385660da6">More...</a><br /></td></tr>
<tr class="separator:aaa516f28b3126777d0ea13c385660da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3930c36c697409ce8906f2b98c71c298"><td class="memItemLeft" align="right" valign="top"><a id="a3930c36c697409ce8906f2b98c71c298"></a>
<a class="el" href="classapf_1_1FieldShape.html">apf::FieldShape</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#a3930c36c697409ce8906f2b98c71c298">getGregory</a> ()</td></tr>
<tr class="memdesc:a3930c36c697409ce8906f2b98c71c298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the 4th order Gregory Surface. <br /></td></tr>
<tr class="separator:a3930c36c697409ce8906f2b98c71c298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72103a99e9f246f03aadc42f967d0d5a"><td class="memItemLeft" align="right" valign="top"><a id="a72103a99e9f246f03aadc42f967d0d5a"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#a72103a99e9f246f03aadc42f967d0d5a">getQuality</a> (<a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *m, apf::MeshEntity *e)</td></tr>
<tr class="memdesc:a72103a99e9f246f03aadc42f967d0d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes min det Jacobian / max det Jacobian. <a class="el" href="classcrv_1_1Quality.html#abf576548f3798e9b7aa0ecd13aaba7e8" title="get scaled jacobian, a quality measure">Quality::getQuality</a> should be used if multiple elements checked in a row <br /></td></tr>
<tr class="separator:a72103a99e9f246f03aadc42f967d0d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf1723bc6e0d97cde68768e94caaf1b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#abcf1723bc6e0d97cde68768e94caaf1b">checkValidity</a> (<a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *m, apf::MeshEntity *e, int algorithm=2)</td></tr>
<tr class="memdesc:abcf1723bc6e0d97cde68768e94caaf1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks validity of it and returns integer corresponding to invalid entity. <a class="el" href="classcrv_1_1Quality.html#ad8ff90e26b89c1e3c794c1287e6c231f" title="check the validity (det(Jacobian) &gt; eps) of an element">Quality::checkValidity</a> should be used if multiple elements checked in a row  <a href="namespacecrv.html#abcf1723bc6e0d97cde68768e94caaf1b">More...</a><br /></td></tr>
<tr class="separator:abcf1723bc6e0d97cde68768e94caaf1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2f47b0c9c9516b17ad700706f0aaf0"><td class="memItemLeft" align="right" valign="top"><a id="aab2f47b0c9c9516b17ad700706f0aaf0"></a>
<a class="el" href="classcrv_1_1Quality.html">Quality</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#aab2f47b0c9c9516b17ad700706f0aaf0">makeQuality</a> (<a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *m, int algorithm=2)</td></tr>
<tr class="memdesc:aab2f47b0c9c9516b17ad700706f0aaf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">use this to make a quality object with the correct dimension <br /></td></tr>
<tr class="separator:aab2f47b0c9c9516b17ad700706f0aaf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a026928e19c6d08f134f8c74f4e50fffa"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#a026928e19c6d08f134f8c74f4e50fffa">interpolationError</a> (<a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *m, apf::MeshEntity *e, int n)</td></tr>
<tr class="memdesc:a026928e19c6d08f134f8c74f4e50fffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes interpolation error of a curved entity on a mesh  <a href="namespacecrv.html#a026928e19c6d08f134f8c74f4e50fffa">More...</a><br /></td></tr>
<tr class="separator:a026928e19c6d08f134f8c74f4e50fffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af72d134610f2e2d46c34af096684eaa5"><td class="memItemLeft" align="right" valign="top"><a id="af72d134610f2e2d46c34af096684eaa5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#af72d134610f2e2d46c34af096684eaa5">writeCurvedVtuFiles</a> (<a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *m, int type, int n, const char *prefix)</td></tr>
<tr class="memdesc:af72d134610f2e2d46c34af096684eaa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visualization, writes file for specified type, n is number of subdivisions, higher number -&gt; better resolution, but bigger file. <br /></td></tr>
<tr class="separator:af72d134610f2e2d46c34af096684eaa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae197b0b54cf1870fdf1fb88377494866"><td class="memItemLeft" align="right" valign="top"><a id="ae197b0b54cf1870fdf1fb88377494866"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#ae197b0b54cf1870fdf1fb88377494866">writeCurvedWireFrame</a> (<a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *m, int n, const char *prefix)</td></tr>
<tr class="memdesc:ae197b0b54cf1870fdf1fb88377494866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visualization, writes wireframe of the curved mesh, n is number of subdivisions, higher number -&gt; better resolution, but bigger file. <br /></td></tr>
<tr class="separator:ae197b0b54cf1870fdf1fb88377494866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc2c19f4c88204bfab34c05c66f42f1"><td class="memItemLeft" align="right" valign="top"><a id="aedc2c19f4c88204bfab34c05c66f42f1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#aedc2c19f4c88204bfab34c05c66f42f1">writeControlPointVtuFiles</a> (<a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *m, const char *prefix)</td></tr>
<tr class="memdesc:aedc2c19f4c88204bfab34c05c66f42f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visualization, writes file of control nodes for each entity. <br /></td></tr>
<tr class="separator:aedc2c19f4c88204bfab34c05c66f42f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b71535871ef8ab006272e262c0756b"><td class="memItemLeft" align="right" valign="top"><a id="aa1b71535871ef8ab006272e262c0756b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#aa1b71535871ef8ab006272e262c0756b">writeInterpolationPointVtuFiles</a> (<a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *m, const char *prefix)</td></tr>
<tr class="memdesc:aa1b71535871ef8ab006272e262c0756b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visualization, writes file of shapes evaluated at node xi for each entity. <br /></td></tr>
<tr class="separator:aa1b71535871ef8ab006272e262c0756b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f76521b14cd0b0c5b09f8a3035407f"><td class="memItemLeft" align="right" valign="top"><a id="a96f76521b14cd0b0c5b09f8a3035407f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#a96f76521b14cd0b0c5b09f8a3035407f">getTriNodeIndex</a> (int P, int i, int j)</td></tr>
<tr class="memdesc:a96f76521b14cd0b0c5b09f8a3035407f"><td class="mdescLeft">&#160;</td><td class="mdescRight">publically accessible functions <br /></td></tr>
<tr class="separator:a96f76521b14cd0b0c5b09f8a3035407f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a876905196b00356d51d6f9881d7c62c1"><td class="memItemLeft" align="right" valign="top"><a id="a876905196b00356d51d6f9881d7c62c1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#a876905196b00356d51d6f9881d7c62c1">fail</a> (const char *why) __attribute__((noreturn))</td></tr>
<tr class="memdesc:a876905196b00356d51d6f9881d7c62c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">crv fail function <br /></td></tr>
<tr class="separator:a876905196b00356d51d6f9881d7c62c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa60c255137d475ca0d095e77d4fd75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#a9fa60c255137d475ca0d095e77d4fd75">changeMeshOrder</a> (<a class="el" href="classapf_1_1Mesh2.html">apf::Mesh2</a> *m, int newOrder)</td></tr>
<tr class="memdesc:a9fa60c255137d475ca0d095e77d4fd75"><td class="mdescLeft">&#160;</td><td class="mdescRight">change the order of a Bezier Mesh  <a href="namespacecrv.html#a9fa60c255137d475ca0d095e77d4fd75">More...</a><br /></td></tr>
<tr class="separator:a9fa60c255137d475ca0d095e77d4fd75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32484fd7346c843e8450ab36d2bbae6f"><td class="memItemLeft" align="right" valign="top"><a id="a32484fd7346c843e8450ab36d2bbae6f"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#a32484fd7346c843e8450ab36d2bbae6f">Bij</a> (const int i, const int j, const double u, const double v)</td></tr>
<tr class="memdesc:a32484fd7346c843e8450ab36d2bbae6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">polynomial part of bernstein polynomial, Bij, Bijk, Bijkl <br /></td></tr>
<tr class="separator:a32484fd7346c843e8450ab36d2bbae6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5654ebdb0b57114e12344ad1d1b6e249"><td class="memItemLeft" align="right" valign="top"><a id="a5654ebdb0b57114e12344ad1d1b6e249"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#a5654ebdb0b57114e12344ad1d1b6e249">Bij</a> (const int ij[], const double xi[])</td></tr>
<tr class="memdesc:a5654ebdb0b57114e12344ad1d1b6e249"><td class="mdescLeft">&#160;</td><td class="mdescRight">a different form of Bij, Bijk, Bijkl <br /></td></tr>
<tr class="separator:a5654ebdb0b57114e12344ad1d1b6e249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a013463c99e442e169dad65bc0c85957a"><td class="memItemLeft" align="right" valign="top"><a id="a013463c99e442e169dad65bc0c85957a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#a013463c99e442e169dad65bc0c85957a">computeTriNodeIndex</a> (int P, int i, int j)</td></tr>
<tr class="memdesc:a013463c99e442e169dad65bc0c85957a"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes node index, use getTriNodeIndex to leverage tables <br /></td></tr>
<tr class="separator:a013463c99e442e169dad65bc0c85957a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d8bb5a7b71062abc8fd8f568bd45fc"><td class="memItemLeft" align="right" valign="top"><a id="a69d8bb5a7b71062abc8fd8f568bd45fc"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#a69d8bb5a7b71062abc8fd8f568bd45fc">computeTetNodeIndex</a> (int P, int i, int j, int k)</td></tr>
<tr class="memdesc:a69d8bb5a7b71062abc8fd8f568bd45fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes node index, use getTetNodeIndex to leverage tables <br /></td></tr>
<tr class="separator:a69d8bb5a7b71062abc8fd8f568bd45fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90dea84d1f143cb9895e39968de0d2e7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#a90dea84d1f143cb9895e39968de0d2e7">getNumControlPoints</a> (int type, int order)</td></tr>
<tr class="memdesc:a90dea84d1f143cb9895e39968de0d2e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates total number of control points, use tables for smaller numbers, this is for quality  <a href="namespacecrv.html#a90dea84d1f143cb9895e39968de0d2e7">More...</a><br /></td></tr>
<tr class="separator:a90dea84d1f143cb9895e39968de0d2e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d23a62a0c74f78ef02a638100f2447"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#ac2d23a62a0c74f78ef02a638100f2447">getNumInternalControlPoints</a> (int type, int order)</td></tr>
<tr class="memdesc:ac2d23a62a0c74f78ef02a638100f2447"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates number of internal control points, use tables for smaller numbers, this is for quality  <a href="namespacecrv.html#ac2d23a62a0c74f78ef02a638100f2447">More...</a><br /></td></tr>
<tr class="separator:ac2d23a62a0c74f78ef02a638100f2447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad66cfeec4b19939c711710188155cd30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#ad66cfeec4b19939c711710188155cd30">getTriNodesFromTetNodes</a> (int f, int P, apf::NewArray&lt; <a class="el" href="classapf_1_1Vector3.html">apf::Vector3</a> &gt; &amp;tetNodes, apf::NewArray&lt; <a class="el" href="classapf_1_1Vector3.html">apf::Vector3</a> &gt; &amp;triNodes)</td></tr>
<tr class="memdesc:ad66cfeec4b19939c711710188155cd30"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes nodes of face f from tet  <a href="namespacecrv.html#ad66cfeec4b19939c711710188155cd30">More...</a><br /></td></tr>
<tr class="separator:ad66cfeec4b19939c711710188155cd30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2628f0f312a7aa4f5e68ba073ad6629c"><td class="memItemLeft" align="right" valign="top"><a id="a2628f0f312a7aa4f5e68ba073ad6629c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#a2628f0f312a7aa4f5e68ba073ad6629c">getTriDetJacNodesFromTetDetJacNodes</a> (int f, int P, apf::NewArray&lt; double &gt; &amp;tetNodes, apf::NewArray&lt; double &gt; &amp;triNodes)</td></tr>
<tr class="memdesc:a2628f0f312a7aa4f5e68ba073ad6629c"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes det(Jacobian) nodes of face f from tet <br /></td></tr>
<tr class="separator:a2628f0f312a7aa4f5e68ba073ad6629c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac330d0e1a5161ce9a90ec06874d3f99c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#ac330d0e1a5161ce9a90ec06874d3f99c">getFullRepFromBlended</a> (int type, apf::NewArray&lt; double &gt; &amp;transformCoefficients, apf::NewArray&lt; <a class="el" href="classapf_1_1Vector3.html">apf::Vector3</a> &gt; &amp;elemNodes)</td></tr>
<tr class="memdesc:ac330d0e1a5161ce9a90ec06874d3f99c"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets full set of bezier control points given blended points  <a href="namespacecrv.html#ac330d0e1a5161ce9a90ec06874d3f99c">More...</a><br /></td></tr>
<tr class="separator:ac330d0e1a5161ce9a90ec06874d3f99c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7eeb92a68be94996a1dba17aced18e0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#aa7eeb92a68be94996a1dba17aced18e0">computeTriJacobianDetFromBezierFormulation</a> (<a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *m, apf::MeshEntity *e, <a class="el" href="classapf_1_1Vector3.html">apf::Vector3</a> &amp;xi)</td></tr>
<tr class="memdesc:aa7eeb92a68be94996a1dba17aced18e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes det(Jacobian) for tri from the Bezier conversion  <a href="namespacecrv.html#aa7eeb92a68be94996a1dba17aced18e0">More...</a><br /></td></tr>
<tr class="separator:aa7eeb92a68be94996a1dba17aced18e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f11352db1cb9de9cbfe1e166c358305"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#a7f11352db1cb9de9cbfe1e166c358305">computeTetJacobianDetFromBezierFormulation</a> (<a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *m, apf::MeshEntity *e, <a class="el" href="classapf_1_1Vector3.html">apf::Vector3</a> &amp;xi)</td></tr>
<tr class="memdesc:a7f11352db1cb9de9cbfe1e166c358305"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes det(Jacobian) for tri from the Bezier conversion  <a href="namespacecrv.html#a7f11352db1cb9de9cbfe1e166c358305">More...</a><br /></td></tr>
<tr class="separator:a7f11352db1cb9de9cbfe1e166c358305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f8e246fa503b6e40981ce0e29b15dad"><td class="memItemLeft" align="right" valign="top"><a id="a6f8e246fa503b6e40981ce0e29b15dad"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#a6f8e246fa503b6e40981ce0e29b15dad">getBezierNodeXi</a> (int type, int P, int node, <a class="el" href="classapf_1_1Vector3.html">apf::Vector3</a> &amp;xi)</td></tr>
<tr class="memdesc:a6f8e246fa503b6e40981ce0e29b15dad"><td class="mdescLeft">&#160;</td><td class="mdescRight">get one bezier node location in parameter space <br /></td></tr>
<tr class="separator:a6f8e246fa503b6e40981ce0e29b15dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0493ca5060847ef61500fb6495d72e6"><td class="memItemLeft" align="right" valign="top"><a id="ac0493ca5060847ef61500fb6495d72e6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#ac0493ca5060847ef61500fb6495d72e6">collectNodeXi</a> (int parentType, int childType, int P, const <a class="el" href="classapf_1_1Vector3.html">apf::Vector3</a> *range, apf::NewArray&lt; <a class="el" href="classapf_1_1Vector3.html">apf::Vector3</a> &gt; &amp;xi)</td></tr>
<tr class="memdesc:ac0493ca5060847ef61500fb6495d72e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">get all bezier node locations in parameter space <br /></td></tr>
<tr class="separator:ac0493ca5060847ef61500fb6495d72e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcce46ef47e529e36782746d5b5f32da"><td class="memItemLeft" align="right" valign="top"><a id="adcce46ef47e529e36782746d5b5f32da"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#adcce46ef47e529e36782746d5b5f32da">elevateBezierEdge</a> (int P, int r, apf::NewArray&lt; <a class="el" href="classapf_1_1Vector3.html">apf::Vector3</a> &gt; &amp;nodes, apf::NewArray&lt; <a class="el" href="classapf_1_1Vector3.html">apf::Vector3</a> &gt; &amp;elevatedNodes)</td></tr>
<tr class="memdesc:adcce46ef47e529e36782746d5b5f32da"><td class="mdescLeft">&#160;</td><td class="mdescRight">elevation functions for beziers <br /></td></tr>
<tr class="separator:adcce46ef47e529e36782746d5b5f32da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f4a80959908851f2e6adab30c48975"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#a83f4a80959908851f2e6adab30c48975">elevateBezierCurve</a> (<a class="el" href="classapf_1_1Mesh2.html">apf::Mesh2</a> *m, apf::MeshEntity *edge, int n, int r)</td></tr>
<tr class="memdesc:a83f4a80959908851f2e6adab30c48975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elevate a bezier curve to a higher order.  <a href="namespacecrv.html#a83f4a80959908851f2e6adab30c48975">More...</a><br /></td></tr>
<tr class="separator:a83f4a80959908851f2e6adab30c48975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25bc216a3ed8f3e30c4d9069a06fb03e"><td class="memItemLeft" align="right" valign="top"><a id="a25bc216a3ed8f3e30c4d9069a06fb03e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#a25bc216a3ed8f3e30c4d9069a06fb03e">subdivideBezierEdge</a> (int P, double t, apf::NewArray&lt; <a class="el" href="classapf_1_1Vector3.html">apf::Vector3</a> &gt; &amp;nodes, apf::NewArray&lt; <a class="el" href="classapf_1_1Vector3.html">apf::Vector3</a> &gt;(&amp;subNodes)[2])</td></tr>
<tr class="memdesc:a25bc216a3ed8f3e30c4d9069a06fb03e"><td class="mdescLeft">&#160;</td><td class="mdescRight">subdivision functions for beziers <br /></td></tr>
<tr class="separator:a25bc216a3ed8f3e30c4d9069a06fb03e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a54273541c455109da23fda2e6984bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#a8a54273541c455109da23fda2e6984bf">convertInterpolationPoints</a> (int n, int ne, apf::NewArray&lt; <a class="el" href="classapf_1_1Vector3.html">apf::Vector3</a> &gt; &amp;nodes, apf::NewArray&lt; double &gt; &amp;c, apf::NewArray&lt; <a class="el" href="classapf_1_1Vector3.html">apf::Vector3</a> &gt; &amp;newNodes)</td></tr>
<tr class="memdesc:a8a54273541c455109da23fda2e6984bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts interpolating points to control points  <a href="namespacecrv.html#a8a54273541c455109da23fda2e6984bf">More...</a><br /></td></tr>
<tr class="separator:a8a54273541c455109da23fda2e6984bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a019632d7ffd1478bd36c38691ce4e9ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#a019632d7ffd1478bd36c38691ce4e9ef">getBezierTransformationCoefficients</a> (int P, int type, apf::NewArray&lt; double &gt; &amp;c)</td></tr>
<tr class="memdesc:a019632d7ffd1478bd36c38691ce4e9ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">get coefficients for interpolating points to control points  <a href="namespacecrv.html#a019632d7ffd1478bd36c38691ce4e9ef">More...</a><br /></td></tr>
<tr class="separator:a019632d7ffd1478bd36c38691ce4e9ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae534914faf992900b69d4a1079aa5b"><td class="memItemLeft" align="right" valign="top"><a id="a8ae534914faf992900b69d4a1079aa5b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#a8ae534914faf992900b69d4a1079aa5b">snapToInterpolate</a> (<a class="el" href="classapf_1_1Mesh2.html">apf::Mesh2</a> *m, apf::MeshEntity *e, bool isNew=false)</td></tr>
<tr class="memdesc:a8ae534914faf992900b69d4a1079aa5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">a per entity version of above <br /></td></tr>
<tr class="separator:a8ae534914faf992900b69d4a1079aa5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ad4750e7167441650633b591488142"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#a85ad4750e7167441650633b591488142">getTransformationMatrix</a> (<a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *m, apf::MeshEntity *e, <a class="el" href="classmth_1_1Matrix.html">mth::Matrix</a>&lt; double &gt; &amp;A, const <a class="el" href="classapf_1_1Vector3.html">apf::Vector3</a> *range)</td></tr>
<tr class="memdesc:a85ad4750e7167441650633b591488142"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the matrix to transform between Bezier and Lagrange Points  <a href="namespacecrv.html#a85ad4750e7167441650633b591488142">More...</a><br /></td></tr>
<tr class="separator:a85ad4750e7167441650633b591488142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881f14e4ac5dfcf39f96338a9b122eea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#a881f14e4ac5dfcf39f96338a9b122eea">BlendedTriangleGetValues</a> (<a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *m, apf::MeshEntity *e, <a class="el" href="classapf_1_1Vector3.html">apf::Vector3</a> const &amp;xi, apf::NewArray&lt; double &gt; &amp;values)</td></tr>
<tr class="memdesc:a881f14e4ac5dfcf39f96338a9b122eea"><td class="mdescLeft">&#160;</td><td class="mdescRight">shape blending functions  <a href="namespacecrv.html#a881f14e4ac5dfcf39f96338a9b122eea">More...</a><br /></td></tr>
<tr class="separator:a881f14e4ac5dfcf39f96338a9b122eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab16dcd83df73253fc3ef9cef10af9b24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#ab16dcd83df73253fc3ef9cef10af9b24">getBezierTransformationMatrix</a> (int type, int P, <a class="el" href="classmth_1_1Matrix.html">mth::Matrix</a>&lt; double &gt; &amp;A, const <a class="el" href="classapf_1_1Vector3.html">apf::Vector3</a> *range)</td></tr>
<tr class="memdesc:ab16dcd83df73253fc3ef9cef10af9b24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get transformation matrix corresponding to a parametric range.  <a href="namespacecrv.html#ab16dcd83df73253fc3ef9cef10af9b24">More...</a><br /></td></tr>
<tr class="separator:ab16dcd83df73253fc3ef9cef10af9b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d4e8ef183a9a5aba2b685375112af4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#ad8d4e8ef183a9a5aba2b685375112af4">getBezierTransformationMatrix</a> (int parentType, int childType, int P, <a class="el" href="classmth_1_1Matrix.html">mth::Matrix</a>&lt; double &gt; &amp;A, const <a class="el" href="classapf_1_1Vector3.html">apf::Vector3</a> *childRange)</td></tr>
<tr class="memdesc:ad8d4e8ef183a9a5aba2b685375112af4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get transformation matrix of a lower entity in a higher entity over a parametric range.  <a href="namespacecrv.html#ad8d4e8ef183a9a5aba2b685375112af4">More...</a><br /></td></tr>
<tr class="separator:ad8d4e8ef183a9a5aba2b685375112af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad30dd0c236e74a47f6a4e2d73ca885f7"><td class="memItemLeft" align="right" valign="top"><a id="ad30dd0c236e74a47f6a4e2d73ca885f7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#ad30dd0c236e74a47f6a4e2d73ca885f7">binomial</a> (int n, int i)</td></tr>
<tr class="memdesc:ad30dd0c236e74a47f6a4e2d73ca885f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">binomial function n!/(i!(n-i)!) <br /></td></tr>
<tr class="separator:ad30dd0c236e74a47f6a4e2d73ca885f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadabb766857993fc4003b14717e3ee22"><td class="memItemLeft" align="right" valign="top"><a id="aadabb766857993fc4003b14717e3ee22"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#aadabb766857993fc4003b14717e3ee22">trinomial</a> (int n, int i, int j)</td></tr>
<tr class="memdesc:aadabb766857993fc4003b14717e3ee22"><td class="mdescLeft">&#160;</td><td class="mdescRight">trinomial function n!/(i!j!(n-i-j)!) <br /></td></tr>
<tr class="separator:aadabb766857993fc4003b14717e3ee22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d3eccfad641d573ac7045d6caee6001"><td class="memItemLeft" align="right" valign="top"><a id="a4d3eccfad641d573ac7045d6caee6001"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#a4d3eccfad641d573ac7045d6caee6001">quadnomial</a> (int n, int i, int j, int k)</td></tr>
<tr class="memdesc:a4d3eccfad641d573ac7045d6caee6001"><td class="mdescLeft">&#160;</td><td class="mdescRight">"quadnomial" function n!/(i!j!k!(n-i-j-k)!) <br /></td></tr>
<tr class="separator:a4d3eccfad641d573ac7045d6caee6001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47eeb732345b3439d9d4a08ee270868b"><td class="memItemLeft" align="right" valign="top"><a id="a47eeb732345b3439d9d4a08ee270868b"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#a47eeb732345b3439d9d4a08ee270868b">intpow</a> (const double b, const int e)</td></tr>
<tr class="memdesc:a47eeb732345b3439d9d4a08ee270868b"><td class="mdescLeft">&#160;</td><td class="mdescRight">faster power for integers <br /></td></tr>
<tr class="separator:a47eeb732345b3439d9d4a08ee270868b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c97813c328c5be5466f4fcb50a50ea"><td class="memItemLeft" align="right" valign="top"><a id="ae2c97813c328c5be5466f4fcb50a50ea"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#ae2c97813c328c5be5466f4fcb50a50ea">invertMatrixWithQR</a> (int n, <a class="el" href="classmth_1_1Matrix.html">mth::Matrix</a>&lt; double &gt; &amp;A, <a class="el" href="classmth_1_1Matrix.html">mth::Matrix</a>&lt; double &gt; &amp;Ai)</td></tr>
<tr class="memdesc:ae2c97813c328c5be5466f4fcb50a50ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">invert a matrix using QR factorization <br /></td></tr>
<tr class="separator:ae2c97813c328c5be5466f4fcb50a50ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade7f6639c3974dee40384b03c1118a53"><td class="memItemLeft" align="right" valign="top"><a id="ade7f6639c3974dee40384b03c1118a53"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#ade7f6639c3974dee40384b03c1118a53">invertMatrixWithPLU</a> (int n, <a class="el" href="classmth_1_1Matrix.html">mth::Matrix</a>&lt; double &gt; &amp;A, <a class="el" href="classmth_1_1Matrix.html">mth::Matrix</a>&lt; double &gt; &amp;Ai)</td></tr>
<tr class="memdesc:ade7f6639c3974dee40384b03c1118a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">invert a matrix using Pivoting and LU decomposition <br /></td></tr>
<tr class="separator:ade7f6639c3974dee40384b03c1118a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2c0cc6203a20061d68e4d323353add2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#ab2c0cc6203a20061d68e4d323353add2">subdivideBezierEntityJacobianDet</a> (int P, int type, apf::NewArray&lt; double &gt; &amp;c, apf::NewArray&lt; double &gt; &amp;nodes, apf::NewArray&lt; double &gt; *subNodes)</td></tr>
<tr class="memdesc:ab2c0cc6203a20061d68e4d323353add2"><td class="mdescLeft">&#160;</td><td class="mdescRight">subdivide jacobian det using subdivision matrices  <a href="namespacecrv.html#ab2c0cc6203a20061d68e4d323353add2">More...</a><br /></td></tr>
<tr class="separator:ab2c0cc6203a20061d68e4d323353add2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44504533bd6bf3521535215b88f3dc6f"><td class="memItemLeft" align="right" valign="top"><a id="a44504533bd6bf3521535215b88f3dc6f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#a44504533bd6bf3521535215b88f3dc6f">getBezierJacobianDetSubdivisionCoefficients</a> (int P, int type, apf::NewArray&lt; double &gt; &amp;c)</td></tr>
<tr class="memdesc:a44504533bd6bf3521535215b88f3dc6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">get matrices used for uniform subdivision, 2^dim matrices, unrolled into a double <br /></td></tr>
<tr class="separator:a44504533bd6bf3521535215b88f3dc6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e52c0235274b89b5d14ec9441b7a5fe"><td class="memItemLeft" align="right" valign="top"><a id="a0e52c0235274b89b5d14ec9441b7a5fe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#a0e52c0235274b89b5d14ec9441b7a5fe">elevateBezierJacobianDet</a> (int type, int P, int r, apf::NewArray&lt; double &gt; &amp;nodes, apf::NewArray&lt; double &gt; &amp;elevatedNodes)</td></tr>
<tr class="memdesc:a0e52c0235274b89b5d14ec9441b7a5fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">elevate jacobian det to higher order, used in getQuality <br /></td></tr>
<tr class="separator:a0e52c0235274b89b5d14ec9441b7a5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d89c2d6362a46a7b56ad2dd0a1bfbc"><td class="memItemLeft" align="right" valign="top"><a id="a73d89c2d6362a46a7b56ad2dd0a1bfbc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#a73d89c2d6362a46a7b56ad2dd0a1bfbc">isBoundaryEntity</a> (<a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *m, apf::MeshEntity *e)</td></tr>
<tr class="memdesc:a73d89c2d6362a46a7b56ad2dd0a1bfbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if is a boundary entity <br /></td></tr>
<tr class="separator:a73d89c2d6362a46a7b56ad2dd0a1bfbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a0c875fdbfef67320ec303a58d80694"><td class="memItemLeft" align="right" valign="top"><a id="a7a0c875fdbfef67320ec303a58d80694"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#a7a0c875fdbfef67320ec303a58d80694">repositionInteriorWithBlended</a> (<a class="el" href="namespacema.html#a3341de79ff346e22c3e00e3eddddd030">ma::Mesh</a> *m, <a class="el" href="namespacema.html#a178f4ea80694469018f1c7ba120a9236">ma::Entity</a> *e)</td></tr>
<tr class="memdesc:a7a0c875fdbfef67320ec303a58d80694"><td class="mdescLeft">&#160;</td><td class="mdescRight">uses blending to position interior points, based on edge locations <br /></td></tr>
<tr class="separator:a7a0c875fdbfef67320ec303a58d80694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9f3e39cbe6359c9e50ebe6740eeffe"><td class="memItemLeft" align="right" valign="top"><a id="a6e9f3e39cbe6359c9e50ebe6740eeffe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#a6e9f3e39cbe6359c9e50ebe6740eeffe">splitEdges</a> (ma::Adapt *a)</td></tr>
<tr class="memdesc:a6e9f3e39cbe6359c9e50ebe6740eeffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split edges marked with ma::SPLIT and place high order nodes using subdivision, see ma::refine. <br /></td></tr>
<tr class="separator:a6e9f3e39cbe6359c9e50ebe6740eeffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f186b4ed08d08c74e6c140b42d31c6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#a18f186b4ed08d08c74e6c140b42d31c6">markInvalidEntities</a> (<a class="el" href="classcrv_1_1Adapt.html">Adapt</a> *a)</td></tr>
<tr class="memdesc:a18f186b4ed08d08c74e6c140b42d31c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">mark invalid entities with validity tag  <a href="namespacecrv.html#a18f186b4ed08d08c74e6c140b42d31c6">More...</a><br /></td></tr>
<tr class="separator:a18f186b4ed08d08c74e6c140b42d31c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f120cd29db0d65d6a0fd2d63be0e933"><td class="memItemLeft" align="right" valign="top"><a id="a7f120cd29db0d65d6a0fd2d63be0e933"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#a7f120cd29db0d65d6a0fd2d63be0e933">getTag</a> (<a class="el" href="classcrv_1_1Adapt.html">Adapt</a> *a, <a class="el" href="namespacema.html#a178f4ea80694469018f1c7ba120a9236">ma::Entity</a> *e)</td></tr>
<tr class="memdesc:a7f120cd29db0d65d6a0fd2d63be0e933"><td class="mdescLeft">&#160;</td><td class="mdescRight">get validityTag <br /></td></tr>
<tr class="separator:a7f120cd29db0d65d6a0fd2d63be0e933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf9c53e8159d01d494a2e21299c83fda"><td class="memItemLeft" align="right" valign="top"><a id="acf9c53e8159d01d494a2e21299c83fda"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#acf9c53e8159d01d494a2e21299c83fda">setTag</a> (<a class="el" href="classcrv_1_1Adapt.html">Adapt</a> *a, <a class="el" href="namespacema.html#a178f4ea80694469018f1c7ba120a9236">ma::Entity</a> *e, int tag)</td></tr>
<tr class="memdesc:acf9c53e8159d01d494a2e21299c83fda"><td class="mdescLeft">&#160;</td><td class="mdescRight">set validityTag <br /></td></tr>
<tr class="separator:acf9c53e8159d01d494a2e21299c83fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f554adf3c2ae8ee6fa972f3071d697"><td class="memItemLeft" align="right" valign="top"><a id="af3f554adf3c2ae8ee6fa972f3071d697"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#af3f554adf3c2ae8ee6fa972f3071d697">clearTag</a> (<a class="el" href="classcrv_1_1Adapt.html">Adapt</a> *a, <a class="el" href="namespacema.html#a178f4ea80694469018f1c7ba120a9236">ma::Entity</a> *e)</td></tr>
<tr class="memdesc:af3f554adf3c2ae8ee6fa972f3071d697"><td class="mdescLeft">&#160;</td><td class="mdescRight">reset validityTag <br /></td></tr>
<tr class="separator:af3f554adf3c2ae8ee6fa972f3071d697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad537d698a677e035ed6d19f4d387a6ac"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#ad537d698a677e035ed6d19f4d387a6ac">getValidityTag</a> (<a class="el" href="namespacema.html#a3341de79ff346e22c3e00e3eddddd030">ma::Mesh</a> *m, <a class="el" href="namespacema.html#a178f4ea80694469018f1c7ba120a9236">ma::Entity</a> *e, <a class="el" href="namespacema.html#a178f4ea80694469018f1c7ba120a9236">ma::Entity</a> *bdry)</td></tr>
<tr class="memdesc:ad537d698a677e035ed6d19f4d387a6ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">get validityTag  <a href="namespacecrv.html#ad537d698a677e035ed6d19f4d387a6ac">More...</a><br /></td></tr>
<tr class="separator:ad537d698a677e035ed6d19f4d387a6ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7ca30538daca8e8b464dc7679eaa61"><td class="memItemLeft" align="right" valign="top"><a id="abc7ca30538daca8e8b464dc7679eaa61"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#abc7ca30538daca8e8b464dc7679eaa61">fixLargeBoundaryAngles</a> (<a class="el" href="classcrv_1_1Adapt.html">Adapt</a> *a)</td></tr>
<tr class="memdesc:abc7ca30538daca8e8b464dc7679eaa61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take boundary triangles where two edges on the boundary form an angle of 180 (or greater) at a vertex and split the edge opposite them. <br /></td></tr>
<tr class="separator:abc7ca30538daca8e8b464dc7679eaa61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d85fb53b58821bfcc6ad0fd2291bb2"><td class="memItemLeft" align="right" valign="top"><a id="a26d85fb53b58821bfcc6ad0fd2291bb2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#a26d85fb53b58821bfcc6ad0fd2291bb2">fixInvalidEdges</a> (<a class="el" href="classcrv_1_1Adapt.html">Adapt</a> *a)</td></tr>
<tr class="memdesc:a26d85fb53b58821bfcc6ad0fd2291bb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">If an edge is flagged as invalid, try and collapse or swap it away. <br /></td></tr>
<tr class="separator:a26d85fb53b58821bfcc6ad0fd2291bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d69be16c7072d7c730439295380b97"><td class="memItemLeft" align="right" valign="top"><a id="a19d69be16c7072d7c730439295380b97"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#a19d69be16c7072d7c730439295380b97">fixCrvElementShapes</a> (<a class="el" href="classcrv_1_1Adapt.html">Adapt</a> *a)</td></tr>
<tr class="memdesc:a19d69be16c7072d7c730439295380b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">attempts to fix the shape of the elements in a same manner as ma::fixElementShape <br /></td></tr>
<tr class="separator:a19d69be16c7072d7c730439295380b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a998c1bfbe55a66eade9379cd4b0a6b0d"><td class="memItemLeft" align="right" valign="top"><a id="a998c1bfbe55a66eade9379cd4b0a6b0d"></a>
ma::ShapeHandler *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#a998c1bfbe55a66eade9379cd4b0a6b0d">getShapeHandler</a> (ma::Adapt *a)</td></tr>
<tr class="memdesc:a998c1bfbe55a66eade9379cd4b0a6b0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">get bezier shape handler <br /></td></tr>
<tr class="separator:a998c1bfbe55a66eade9379cd4b0a6b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26a93894d91157d5acfedf42f5d56a4"><td class="memItemLeft" align="right" valign="top"><a id="ab26a93894d91157d5acfedf42f5d56a4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#ab26a93894d91157d5acfedf42f5d56a4">transferParametricOnEdgeSplit</a> (<a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *m, apf::MeshEntity *e, double t, <a class="el" href="classapf_1_1Vector3.html">apf::Vector3</a> &amp;p)</td></tr>
<tr class="memdesc:ab26a93894d91157d5acfedf42f5d56a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets parametric location on geometry given t in [0,1] on edge <br /></td></tr>
<tr class="separator:ab26a93894d91157d5acfedf42f5d56a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe74383c54bd4ac3ee75f30536721683"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#abe74383c54bd4ac3ee75f30536721683">transferParametricOnTriSplit</a> (<a class="el" href="classapf_1_1Mesh2.html">apf::Mesh2</a> *m, apf::MeshEntity *e, <a class="el" href="classapf_1_1Vector3.html">apf::Vector3</a> &amp;t, <a class="el" href="classapf_1_1Vector3.html">apf::Vector3</a> &amp;p)</td></tr>
<tr class="memdesc:abe74383c54bd4ac3ee75f30536721683"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets parametric location on geometry given barycentric coordinate t on tri  <a href="namespacecrv.html#abe74383c54bd4ac3ee75f30536721683">More...</a><br /></td></tr>
<tr class="separator:abe74383c54bd4ac3ee75f30536721683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d73a515c3a75299b962d51e6628ca2f"><td class="memItemLeft" align="right" valign="top"><a id="a4d73a515c3a75299b962d51e6628ca2f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#a4d73a515c3a75299b962d51e6628ca2f">transferParametricOnGeometricEdgeSplit</a> (<a class="el" href="classapf_1_1Mesh2.html">apf::Mesh2</a> *m, apf::MeshEntity *e, double t, <a class="el" href="classapf_1_1Vector3.html">apf::Vector3</a> &amp;p)</td></tr>
<tr class="memdesc:a4d73a515c3a75299b962d51e6628ca2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets parametric location on geometry given t in [0,1] on edge, but splitting in geometric space first and then projecting <br /></td></tr>
<tr class="separator:a4d73a515c3a75299b962d51e6628ca2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967075acf1d1050ee93821f749637850"><td class="memItemLeft" align="right" valign="top"><a id="a967075acf1d1050ee93821f749637850"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#a967075acf1d1050ee93821f749637850">transferParametricOnGeometricTriSplit</a> (<a class="el" href="classapf_1_1Mesh2.html">apf::Mesh2</a> *m, apf::MeshEntity *e, <a class="el" href="classapf_1_1Vector3.html">apf::Vector3</a> &amp;t, <a class="el" href="classapf_1_1Vector3.html">apf::Vector3</a> &amp;p)</td></tr>
<tr class="memdesc:a967075acf1d1050ee93821f749637850"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets parametric location on geometry given barycentric coordinate t on tri, but splitting in geometric space first and then projecting <br /></td></tr>
<tr class="separator:a967075acf1d1050ee93821f749637850"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:abcfc2f111672bc3a3d16161b952c4a5a"><td class="memItemLeft" align="right" valign="top"><a id="abcfc2f111672bc3a3d16161b952c4a5a"></a>
const <a class="el" href="namespacecrv.html#a3bc760a6279cdc9b15779144e36fd70c">bezierShape</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#abcfc2f111672bc3a3d16161b952c4a5a">bezier</a> [<a class="el" href="classapf_1_1Mesh.html#a68729141a3c5781a24bb72ea6160b898aef6476acf6005c1f0aebb089a6ba8e85">apf::Mesh::TYPES</a>]</td></tr>
<tr class="memdesc:abcfc2f111672bc3a3d16161b952c4a5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">table of shape functions <br /></td></tr>
<tr class="separator:abcfc2f111672bc3a3d16161b952c4a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa12d94e82b35205718cd4d3f3b4d87e7"><td class="memItemLeft" align="right" valign="top"><a id="aa12d94e82b35205718cd4d3f3b4d87e7"></a>
const <a class="el" href="namespacecrv.html#a4899e132dc03c39444daccd1123a80f9">bezierShapeGrads</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#aa12d94e82b35205718cd4d3f3b4d87e7">bezierGrads</a> [<a class="el" href="classapf_1_1Mesh.html#a68729141a3c5781a24bb72ea6160b898aef6476acf6005c1f0aebb089a6ba8e85">apf::Mesh::TYPES</a>]</td></tr>
<tr class="memdesc:aa12d94e82b35205718cd4d3f3b4d87e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">table of shape function gradients <br /></td></tr>
<tr class="separator:aa12d94e82b35205718cd4d3f3b4d87e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bfa76d9707e765121daf3430639eab1"><td class="memItemLeft" align="right" valign="top"><a id="a8bfa76d9707e765121daf3430639eab1"></a>
const <a class="el" href="namespacecrv.html#a2c7b809013b39130610e178592e589a7">SubdivisionFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#a8bfa76d9707e765121daf3430639eab1">subdivideBezierJacobianDet</a> [<a class="el" href="classapf_1_1Mesh.html#a68729141a3c5781a24bb72ea6160b898aef6476acf6005c1f0aebb089a6ba8e85">apf::Mesh::TYPES</a>]</td></tr>
<tr class="memdesc:a8bfa76d9707e765121daf3430639eab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">table of jacobian det subdivision functions <br /></td></tr>
<tr class="separator:a8bfa76d9707e765121daf3430639eab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883306cb5a6bd3c14d005284bec19364"><td class="memItemLeft" align="right" valign="top"><a id="a883306cb5a6bd3c14d005284bec19364"></a>
unsigned const  *const  *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#a883306cb5a6bd3c14d005284bec19364">b2</a> [11]</td></tr>
<tr class="memdesc:a883306cb5a6bd3c14d005284bec19364"><td class="mdescLeft">&#160;</td><td class="mdescRight">table of indices for triangles, b2[order][i][j], only up to 10th order is stored, higher can be generated on the fly <br /></td></tr>
<tr class="separator:a883306cb5a6bd3c14d005284bec19364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd45cecc4219f0adee4adc2e55d0b350"><td class="memItemLeft" align="right" valign="top"><a id="abd45cecc4219f0adee4adc2e55d0b350"></a>
unsigned const  *const  *const  *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#abd45cecc4219f0adee4adc2e55d0b350">b3</a> [5]</td></tr>
<tr class="memdesc:abd45cecc4219f0adee4adc2e55d0b350"><td class="mdescLeft">&#160;</td><td class="mdescRight">table of indices for tets, b3[order][i][j][k], only up to 4th order is stored, higher can be generated on the fly <br /></td></tr>
<tr class="separator:abd45cecc4219f0adee4adc2e55d0b350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37277c138c3b387cfe4b4de618904c9c"><td class="memItemLeft" align="right" valign="top"><a id="a37277c138c3b387cfe4b4de618904c9c"></a>
unsigned const  *const  *const  *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#a37277c138c3b387cfe4b4de618904c9c">tet_tri</a> [7]</td></tr>
<tr class="memdesc:a37277c138c3b387cfe4b4de618904c9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">table of alignment used in alignSharedNodes, tet_tri[order][flip][rotate][node]; <br /></td></tr>
<tr class="separator:a37277c138c3b387cfe4b4de618904c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6888c1945e6425c1241b5d2835a0ae73"><td class="memItemLeft" align="right" valign="top"><a id="a6888c1945e6425c1241b5d2835a0ae73"></a>
<a class="el" href="classapf_1_1Vector3.html">apf::Vector3</a> const  *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#a6888c1945e6425c1241b5d2835a0ae73">elem_vert_xi</a> [<a class="el" href="classapf_1_1Mesh.html#a68729141a3c5781a24bb72ea6160b898aef6476acf6005c1f0aebb089a6ba8e85">apf::Mesh::TYPES</a>]</td></tr>
<tr class="memdesc:a6888c1945e6425c1241b5d2835a0ae73"><td class="mdescLeft">&#160;</td><td class="mdescRight">parametric locations of midpoint nodes given a vertex number, elem_vert_xi[type][vertex_index] <br /></td></tr>
<tr class="separator:a6888c1945e6425c1241b5d2835a0ae73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f11787d7c730f0b64133cd44dbf0f8"><td class="memItemLeft" align="right" valign="top"><a id="ac5f11787d7c730f0b64133cd44dbf0f8"></a>
<a class="el" href="classapf_1_1Vector3.html">apf::Vector3</a> const  *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecrv.html#ac5f11787d7c730f0b64133cd44dbf0f8">elem_edge_xi</a> [<a class="el" href="classapf_1_1Mesh.html#a68729141a3c5781a24bb72ea6160b898aef6476acf6005c1f0aebb089a6ba8e85">apf::Mesh::TYPES</a>]</td></tr>
<tr class="memdesc:ac5f11787d7c730f0b64133cd44dbf0f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">parametric locations of midpoint nodes given an edge number, elem_edge_xi[type][edge_index] <br /></td></tr>
<tr class="separator:ac5f11787d7c730f0b64133cd44dbf0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>the curving functions are contained in this namespace </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a4cba0b823284e0dd7809a1442e50233f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cba0b823284e0dd7809a1442e50233f">&#9670;&nbsp;</a></span>adapt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crv::adapt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classma_1_1Input.html">ma::Input</a> *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>crv adapt with custom configuration </p>
<p>see <a class="el" href="maInput_8h.html" title="MeshAdapt user configuration.">maInput.h</a> for details. note that this function will delete the Input object </p>

</div>
</div>
<a id="a8f1c5610252c55108cd0f72b02c1b44a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f1c5610252c55108cd0f72b02c1b44a">&#9670;&nbsp;</a></span>adapt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crv::adapt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classma_1_1Input.html">ma::Input</a> *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>crv adapt with custom configuration </p>
<p>see <a class="el" href="maInput_8h.html" title="MeshAdapt user configuration.">maInput.h</a> for details. note that this function will delete the Input object </p>

</div>
</div>
<a id="a881f14e4ac5dfcf39f96338a9b122eea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a881f14e4ac5dfcf39f96338a9b122eea">&#9670;&nbsp;</a></span>BlendedTriangleGetValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crv::BlendedTriangleGetValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apf::MeshEntity *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1Vector3.html">apf::Vector3</a> const &amp;&#160;</td>
          <td class="paramname"><em>xi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apf::NewArray&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>shape blending functions </p>
<p>see bezier.tex in SCOREC/docs repo </p>

</div>
</div>
<a id="a9fa60c255137d475ca0d095e77d4fd75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fa60c255137d475ca0d095e77d4fd75">&#9670;&nbsp;</a></span>changeMeshOrder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crv::changeMeshOrder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh2.html">apf::Mesh2</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newOrder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>change the order of a Bezier Mesh </p>
<p>going up in order is exact, except for boundary elements, where snapping changes things Going down in order is approximate everywhere </p>

</div>
</div>
<a id="abcf1723bc6e0d97cde68768e94caaf1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcf1723bc6e0d97cde68768e94caaf1b">&#9670;&nbsp;</a></span>checkValidity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crv::checkValidity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apf::MeshEntity *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>algorithm</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>checks validity of it and returns integer corresponding to invalid entity. <a class="el" href="classcrv_1_1Quality.html#ad8ff90e26b89c1e3c794c1287e6c231f" title="check the validity (det(Jacobian) &gt; eps) of an element">Quality::checkValidity</a> should be used if multiple elements checked in a row </p>
<p>Use an integer to determine the vuality tag 0 -&gt; Not checked 1 -&gt; Okay <a class="el" href="classcrv_1_1Quality.html" title="class to store matrices used in quality assessment and validity checking">Quality</a> 2-7 -&gt; Vertex of index+2 is bad 8-13 -&gt; Edge of index+6 is bad 14-17 -&gt; Face of index+12 bad 20 -&gt; Tet itself is bad, this one is the worst</p>
<p>6*dim + 2 + index </p>

</div>
</div>
<a id="a7f11352db1cb9de9cbfe1e166c358305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f11352db1cb9de9cbfe1e166c358305">&#9670;&nbsp;</a></span>computeTetJacobianDetFromBezierFormulation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double crv::computeTetJacobianDetFromBezierFormulation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apf::MeshEntity *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1Vector3.html">apf::Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>xi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes det(Jacobian) for tri from the Bezier conversion </p>
<p>this evaluates an order d(P-1) bezier to compute it and is much, much slower than the direct method, but exists for comparison </p>

</div>
</div>
<a id="aa7eeb92a68be94996a1dba17aced18e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7eeb92a68be94996a1dba17aced18e0">&#9670;&nbsp;</a></span>computeTriJacobianDetFromBezierFormulation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double crv::computeTriJacobianDetFromBezierFormulation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apf::MeshEntity *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1Vector3.html">apf::Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>xi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes det(Jacobian) for tri from the Bezier conversion </p>
<p>this evaluates an order d(P-1) bezier to compute it and is much, much slower than the direct method, but exists for comparison </p>

</div>
</div>
<a id="a8a54273541c455109da23fda2e6984bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a54273541c455109da23fda2e6984bf">&#9670;&nbsp;</a></span>convertInterpolationPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crv::convertInterpolationPoints </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ne</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apf::NewArray&lt; <a class="el" href="classapf_1_1Vector3.html">apf::Vector3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apf::NewArray&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apf::NewArray&lt; <a class="el" href="classapf_1_1Vector3.html">apf::Vector3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>newNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>converts interpolating points to control points </p>
<p>n is total number of nodes on the shape ne is nodes on the entity, that belong to it c is a coefficient matrix in vector form corresponding to the matrix </p>

</div>
</div>
<a id="a83f4a80959908851f2e6adab30c48975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83f4a80959908851f2e6adab30c48975">&#9670;&nbsp;</a></span>elevateBezierCurve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crv::elevateBezierCurve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh2.html">apf::Mesh2</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apf::MeshEntity *&#160;</td>
          <td class="paramname"><em>edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Elevate a bezier curve to a higher order. </p>
<p>This elevates from nth order to n+rth order requires the curve be order n+r in memory already, and that the first n points correspond to the lower order curve </p>

</div>
</div>
<a id="aaa516f28b3126777d0ea13c385660da6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa516f28b3126777d0ea13c385660da6">&#9670;&nbsp;</a></span>getBezier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapf_1_1FieldShape.html">apf::FieldShape</a>* crv::getBezier </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Bezier Curve or Shape of some order. </p>
<p>goes from first to sixth order </p>

</div>
</div>
<a id="a019632d7ffd1478bd36c38691ce4e9ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a019632d7ffd1478bd36c38691ce4e9ef">&#9670;&nbsp;</a></span>getBezierTransformationCoefficients()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crv::getBezierTransformationCoefficients </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apf::NewArray&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get coefficients for interpolating points to control points </p>
<p>works only for prescribed optimal point locations up to 6th order in 2D and </p>

</div>
</div>
<a id="ad8d4e8ef183a9a5aba2b685375112af4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8d4e8ef183a9a5aba2b685375112af4">&#9670;&nbsp;</a></span>getBezierTransformationMatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crv::getBezierTransformationMatrix </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>parentType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>childType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmth_1_1Matrix.html">mth::Matrix</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapf_1_1Vector3.html">apf::Vector3</a> *&#160;</td>
          <td class="paramname"><em>childRange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get transformation matrix of a lower entity in a higher entity over a parametric range. </p>
<p>Range is an array of size(num vertices), this is used for refinement, It is the lower dimensional component, as part of the higher array, see notes </p>

</div>
</div>
<a id="ab16dcd83df73253fc3ef9cef10af9b24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab16dcd83df73253fc3ef9cef10af9b24">&#9670;&nbsp;</a></span>getBezierTransformationMatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crv::getBezierTransformationMatrix </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmth_1_1Matrix.html">mth::Matrix</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapf_1_1Vector3.html">apf::Vector3</a> *&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get transformation matrix corresponding to a parametric range. </p>
<p>Range is an array of size(num vertices), this is used for subdivision, refinement. It is the element transformation matrix, see notes </p>

</div>
</div>
<a id="ac330d0e1a5161ce9a90ec06874d3f99c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac330d0e1a5161ce9a90ec06874d3f99c">&#9670;&nbsp;</a></span>getFullRepFromBlended()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crv::getFullRepFromBlended </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apf::NewArray&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>transformCoefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apf::NewArray&lt; <a class="el" href="classapf_1_1Vector3.html">apf::Vector3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>elemNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets full set of bezier control points given blended points </p>
<p>this is used for quality assessment of blended shapes, and reallocates elemNodes </p>

</div>
</div>
<a id="a90dea84d1f143cb9895e39968de0d2e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90dea84d1f143cb9895e39968de0d2e7">&#9670;&nbsp;</a></span>getNumControlPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crv::getNumControlPoints </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculates total number of control points, use tables for smaller numbers, this is for quality </p>
<p>This gives the numbers for full bezier shapes, this is not accurate for blended shapes </p>

</div>
</div>
<a id="ac2d23a62a0c74f78ef02a638100f2447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2d23a62a0c74f78ef02a638100f2447">&#9670;&nbsp;</a></span>getNumInternalControlPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crv::getNumInternalControlPoints </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculates number of internal control points, use tables for smaller numbers, this is for quality </p>
<p>This gives the numbers for full bezier shapes, this is not accurate for blended shapes </p>

</div>
</div>
<a id="a85ad4750e7167441650633b591488142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ad4750e7167441650633b591488142">&#9670;&nbsp;</a></span>getTransformationMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crv::getTransformationMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apf::MeshEntity *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmth_1_1Matrix.html">mth::Matrix</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapf_1_1Vector3.html">apf::Vector3</a> *&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the matrix to transform between Bezier and Lagrange Points </p>
<p>this is a support function, not actual ever needed. Bezier control points, C, can be written as L = A*C where A is a matrix of Bernstein polynomials and binomial coefficients. To compute the control points from Lagrange points, A^{-1} is used. crvBezierPoints.cc contains A^{-1}, precomputed, for the nodeXi locations in getBezierNodeXi. </p>

</div>
</div>
<a id="ad66cfeec4b19939c711710188155cd30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad66cfeec4b19939c711710188155cd30">&#9670;&nbsp;</a></span>getTriNodesFromTetNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crv::getTriNodesFromTetNodes </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apf::NewArray&lt; <a class="el" href="classapf_1_1Vector3.html">apf::Vector3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tetNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apf::NewArray&lt; <a class="el" href="classapf_1_1Vector3.html">apf::Vector3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>triNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes nodes of face f from tet </p>
<p>does not consider alignment, extra care needed </p>

</div>
</div>
<a id="ad537d698a677e035ed6d19f4d387a6ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad537d698a677e035ed6d19f4d387a6ac">&#9670;&nbsp;</a></span>getValidityTag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crv::getValidityTag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacema.html#a3341de79ff346e22c3e00e3eddddd030">ma::Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacema.html#a178f4ea80694469018f1c7ba120a9236">ma::Entity</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacema.html#a178f4ea80694469018f1c7ba120a9236">ma::Entity</a> *&#160;</td>
          <td class="paramname"><em>bdry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get validityTag </p>
<p>Use an integer to determine the validity tag 0 -&gt; Not checked 1 -&gt; Okay <a class="el" href="classcrv_1_1Quality.html" title="class to store matrices used in quality assessment and validity checking">Quality</a> 2-7 -&gt; Vertices are bad 8-13 -&gt; Edge is are bad 14-17 -&gt; Face is are bad 20 -&gt; Tet itself is bad, this one is the worst</p>
<p>6*dim + 2 + index </p>

</div>
</div>
<a id="a026928e19c6d08f134f8c74f4e50fffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a026928e19c6d08f134f8c74f4e50fffa">&#9670;&nbsp;</a></span>interpolationError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double crv::interpolationError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apf::MeshEntity *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes interpolation error of a curved entity on a mesh </p>
<p>this computes the Hausdorff distance by sampling n points per dimension of the entity through uniform sampling locations in parameter space </p>

</div>
</div>
<a id="a18f186b4ed08d08c74e6c140b42d31c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18f186b4ed08d08c74e6c140b42d31c6">&#9670;&nbsp;</a></span>markInvalidEntities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int crv::markInvalidEntities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcrv_1_1Adapt.html">Adapt</a> *&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>mark invalid entities with validity tag </p>
<p>since validity checking is expensive, do this as little as possible and keep information about the check </p>

</div>
</div>
<a id="a075f366285a160b1e0dfd2f806726d03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a075f366285a160b1e0dfd2f806726d03">&#9670;&nbsp;</a></span>stats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crv::stats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classma_1_1Input.html">ma::Input</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>edgeLengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>linearQualities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>curvedQualities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inMetric</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>crv stats to get statistic information about the mesh </p>
<p>statistic considered are (1)final/desired edge-lengths (2) linear quality (3) curved quality (minJ/maxJ) </p>

</div>
</div>
<a id="ab2c0cc6203a20061d68e4d323353add2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2c0cc6203a20061d68e4d323353add2">&#9670;&nbsp;</a></span>subdivideBezierEntityJacobianDet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crv::subdivideBezierEntityJacobianDet </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apf::NewArray&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apf::NewArray&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apf::NewArray&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>subNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>subdivide jacobian det using subdivision matrices </p>
<p>see getBezierJacobianDetSubdivisionCoefficients </p>

</div>
</div>
<a id="abe74383c54bd4ac3ee75f30536721683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe74383c54bd4ac3ee75f30536721683">&#9670;&nbsp;</a></span>transferParametricOnTriSplit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void crv::transferParametricOnTriSplit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh2.html">apf::Mesh2</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apf::MeshEntity *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1Vector3.html">apf::Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1Vector3.html">apf::Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets parametric location on geometry given barycentric coordinate t on tri </p>
<p>uses two linear splits to find location on a triangle, which is more stable and handles degeneracy better than using pure barycentrics </p>

</div>
</div>
</div><!-- contents -->
<hr class="footer"/><address class="footer"><small>
Generated for SCOREC core by&nbsp;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.1</small></address>
</body>
</html>
