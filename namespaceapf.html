<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SCOREC core: apf Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="scorec.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SCOREC core
   </div>
   <div id="projectbrief">Parallel unstructured mesh tools</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">apf Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>All APF symbols are contained in this namespace.  
<a href="namespaceapf.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapf_1_1Up.html">Up</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">statically sized container for upward adjacency queries.  <a href="structapf_1_1Up.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapf_1_1Copy.html">Copy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a reference to an object representing the same entity  <a href="structapf_1_1Copy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1Mesh.html">Mesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface to a mesh part.  <a href="classapf_1_1Mesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1Migration.html">Migration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classapf_1_1Migration.html" title="Migration plan object: local elements to destinations.">Migration</a> plan object: local elements to destinations.  <a href="classapf_1_1Migration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapf_1_1Sharing.html">Sharing</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">abstract description of entity copy sharing  <a href="structapf_1_1Sharing.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1Mesh2.html">Mesh2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extended mesh interface for modification.  <a href="classapf_1_1Mesh2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1BuildCallback.html">BuildCallback</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-defined entity creation callback.  <a href="classapf_1_1BuildCallback.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1ReductionOp.html">ReductionOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for applying operations to make a Field consistent in parallel.  <a href="classapf_1_1ReductionOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1Integrator.html">Integrator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A virtual base for user-defined integrators.  <a href="classapf_1_1Integrator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapf_1_1Function.html">Function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-defined Analytic <a class="el" href="structapf_1_1Function.html" title="User-defined Analytic Function.">Function</a>.  <a href="structapf_1_1Function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapf_1_1Node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structapf_1_1Node.html" title="Node identifier.">Node</a> identifier.  <a href="structapf_1_1Node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1EntityShape.html">EntityShape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shape functions over this element.  <a href="classapf_1_1EntityShape.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1FieldShape.html">FieldShape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes field distribution and shape functions.  <a href="classapf_1_1FieldShape.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1Vector.html">Vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">template-generic vector of N doubles  <a href="classapf_1_1Vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1Vector3.html">Vector3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience wrapper over apf::Vector&lt;3&gt;  <a href="classapf_1_1Vector3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1Matrix.html">Matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">template-generic matrix of M by N doubles  <a href="classapf_1_1Matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1Matrix3x3.html">Matrix3x3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience wrapper over apf::Matrix&lt;3,3&gt;  <a href="classapf_1_1Matrix3x3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1DynamicVector.html">DynamicVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A runtime-sized linear algebra vector of doubles.  <a href="classapf_1_1DynamicVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1DynamicMatrix.html">DynamicMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A runtime-sized dense matrix.  <a href="classapf_1_1DynamicMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1CavityOp.html">CavityOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">user-defined mesh cavity operator  <a href="classapf_1_1CavityOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1Splitter.html">Splitter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a mesh part into many.  <a href="classapf_1_1Splitter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classapf_1_1Balancer.html">Balancer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load balance over all mesh parts.  <a href="classapf_1_1Balancer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapf_1_1Remap.html">Remap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a map from old part ids to new part ids  <a href="structapf_1_1Remap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapf_1_1Divide.html">Divide</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">divide the part id  <a href="structapf_1_1Divide.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapf_1_1Multiply.html">Multiply</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiply the part id  <a href="structapf_1_1Multiply.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapf_1_1Modulo.html">Modulo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">return part id modulo n  <a href="structapf_1_1Modulo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapf_1_1Unmodulo.html">Unmodulo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">inverse of <a class="el" href="structapf_1_1Modulo.html" title="return part id modulo n">apf::Modulo</a>  <a href="structapf_1_1Unmodulo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapf_1_1Round.html">Round</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">map to nearest multiple of n  <a href="structapf_1_1Round.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a662a796b32a9173981bfc6e1ebe60ba1"><td class="memItemLeft" align="right" valign="top"><a id="a662a796b32a9173981bfc6e1ebe60ba1"></a>
typedef NumberingOf&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a662a796b32a9173981bfc6e1ebe60ba1">Numbering</a></td></tr>
<tr class="memdesc:a662a796b32a9173981bfc6e1ebe60ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Numbering is meant to be a 32-bit local numbering. <br /></td></tr>
<tr class="separator:a662a796b32a9173981bfc6e1ebe60ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a691865cc4ddfa6781e8aba4e338617e8"><td class="memItemLeft" align="right" valign="top"><a id="a691865cc4ddfa6781e8aba4e338617e8"></a>
typedef NumberingOf&lt; long &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a691865cc4ddfa6781e8aba4e338617e8">GlobalNumbering</a></td></tr>
<tr class="memdesc:a691865cc4ddfa6781e8aba4e338617e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global numberings use 64-bit integers. <br /></td></tr>
<tr class="separator:a691865cc4ddfa6781e8aba4e338617e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fdcb1e40963596d8345f0328e7d65b1"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; int, MeshEntity * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a4fdcb1e40963596d8345f0328e7d65b1">Copies</a></td></tr>
<tr class="memdesc:a4fdcb1e40963596d8345f0328e7d65b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remote copy container.  <a href="namespaceapf.html#a4fdcb1e40963596d8345f0328e7d65b1">More...</a><br /></td></tr>
<tr class="separator:a4fdcb1e40963596d8345f0328e7d65b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29a3b61c20263ec345eed4108116ccfb"><td class="memItemLeft" align="right" valign="top"><a id="a29a3b61c20263ec345eed4108116ccfb"></a>
typedef std::set&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a29a3b61c20263ec345eed4108116ccfb">Parts</a></td></tr>
<tr class="memdesc:a29a3b61c20263ec345eed4108116ccfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of unique part ids. <br /></td></tr>
<tr class="separator:a29a3b61c20263ec345eed4108116ccfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d882b4789bf98322cbe6f02c91b1f8"><td class="memItemLeft" align="right" valign="top">typedef DynamicArray&lt; MeshEntity * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a12d882b4789bf98322cbe6f02c91b1f8">Adjacent</a></td></tr>
<tr class="memdesc:a12d882b4789bf98322cbe6f02c91b1f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of adjacent mesh entities.  <a href="namespaceapf.html#a12d882b4789bf98322cbe6f02c91b1f8">More...</a><br /></td></tr>
<tr class="separator:a12d882b4789bf98322cbe6f02c91b1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a041eedcdfef4c64dafb2936219978328"><td class="memItemLeft" align="right" valign="top">typedef MeshEntity *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a041eedcdfef4c64dafb2936219978328">Downward</a>[12]</td></tr>
<tr class="memdesc:a041eedcdfef4c64dafb2936219978328"><td class="mdescLeft">&#160;</td><td class="mdescRight">a static array type downward adjacency queries.  <a href="namespaceapf.html#a041eedcdfef4c64dafb2936219978328">More...</a><br /></td></tr>
<tr class="separator:a041eedcdfef4c64dafb2936219978328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ead57a50aad0c68325845eb8de823e6"><td class="memItemLeft" align="right" valign="top"><a id="a6ead57a50aad0c68325845eb8de823e6"></a>
typedef <a class="el" href="structapf_1_1Copy.html">Copy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a6ead57a50aad0c68325845eb8de823e6">Match</a></td></tr>
<tr class="memdesc:a6ead57a50aad0c68325845eb8de823e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">matches are just a special case of copies <br /></td></tr>
<tr class="separator:a6ead57a50aad0c68325845eb8de823e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0144be017f4819c76225f8237a4883d7"><td class="memItemLeft" align="right" valign="top"><a id="a0144be017f4819c76225f8237a4883d7"></a>
typedef DynamicArray&lt; <a class="el" href="structapf_1_1Copy.html">Copy</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a0144be017f4819c76225f8237a4883d7">CopyArray</a></td></tr>
<tr class="memdesc:a0144be017f4819c76225f8237a4883d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">a set of copies, possibly multiple copies per part <br /></td></tr>
<tr class="separator:a0144be017f4819c76225f8237a4883d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b8b6aca1188d00aa293b974d3e66be"><td class="memItemLeft" align="right" valign="top"><a id="a84b8b6aca1188d00aa293b974d3e66be"></a>
typedef <a class="el" href="namespaceapf.html#a0144be017f4819c76225f8237a4883d7">CopyArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a84b8b6aca1188d00aa293b974d3e66be">Matches</a></td></tr>
<tr class="memdesc:a84b8b6aca1188d00aa293b974d3e66be"><td class="mdescLeft">&#160;</td><td class="mdescRight">a set of periodic copies <br /></td></tr>
<tr class="separator:a84b8b6aca1188d00aa293b974d3e66be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3971b2bbfe2c9173f54391078088ac5"><td class="memItemLeft" align="right" valign="top"><a id="ad3971b2bbfe2c9173f54391078088ac5"></a>
typedef <a class="el" href="namespaceapf.html#a0144be017f4819c76225f8237a4883d7">CopyArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#ad3971b2bbfe2c9173f54391078088ac5">DgCopies</a></td></tr>
<tr class="memdesc:ad3971b2bbfe2c9173f54391078088ac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">a set of DG copies <br /></td></tr>
<tr class="separator:ad3971b2bbfe2c9173f54391078088ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2432d4261391eda474007fb25c097a5c"><td class="memItemLeft" align="right" valign="top"><a id="a2432d4261391eda474007fb25c097a5c"></a>
typedef VectorElement&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a2432d4261391eda474007fb25c097a5c">MeshElement</a></td></tr>
<tr class="memdesc:a2432d4261391eda474007fb25c097a5c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classapf_1_1Mesh.html" title="Interface to a mesh part.">Mesh</a> Elements represent the mesh coordinate vector field. <br /></td></tr>
<tr class="separator:a2432d4261391eda474007fb25c097a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad41eed81404b62d897ea31da38a53f73"><td class="memItemLeft" align="right" valign="top"><a id="ad41eed81404b62d897ea31da38a53f73"></a>
typedef std::map&lt; Gid, MeshEntity * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#ad41eed81404b62d897ea31da38a53f73">GlobalToVert</a></td></tr>
<tr class="memdesc:ad41eed81404b62d897ea31da38a53f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">a map from global ids to vertex objects <br /></td></tr>
<tr class="separator:ad41eed81404b62d897ea31da38a53f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a496b3a52d5026c0afdb138b46ea25cca"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a496b3a52d5026c0afdb138b46ea25cca">ValueType</a> { <br />
&#160;&#160;<a class="el" href="namespaceapf.html#a496b3a52d5026c0afdb138b46ea25ccaab8dc994c7c9cd1be3a1b9b176b8ccc65">SCALAR</a>
, <a class="el" href="namespaceapf.html#a496b3a52d5026c0afdb138b46ea25ccaa963e21a78ec85257a262d62c14f93160">VECTOR</a>
, <a class="el" href="namespaceapf.html#a496b3a52d5026c0afdb138b46ea25ccaafb466e4ed43caf8134a8d67013877f3d">MATRIX</a>
, <a class="el" href="namespaceapf.html#a496b3a52d5026c0afdb138b46ea25ccaa2bedc04cff0e3de6562d2d9855658e42">PACKED</a>
, <br />
&#160;&#160;<a class="el" href="namespaceapf.html#a496b3a52d5026c0afdb138b46ea25ccaac7e6014a273fb05e198991f5a5ff8504">VALUE_TYPES</a>
<br />
 }</td></tr>
<tr class="memdesc:a496b3a52d5026c0afdb138b46ea25cca"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of value the field stores.  <a href="namespaceapf.html#a496b3a52d5026c0afdb138b46ea25cca">More...</a><br /></td></tr>
<tr class="separator:a496b3a52d5026c0afdb138b46ea25cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43962b2ec3f0b13035fcdd6b605c0542"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a43962b2ec3f0b13035fcdd6b605c0542">ZoltanMethod</a> { <br />
&#160;&#160;<a class="el" href="namespaceapf.html#a43962b2ec3f0b13035fcdd6b605c0542a4a4bf3caf26566014c77301edef9645c">RCB</a>
, <a class="el" href="namespaceapf.html#a43962b2ec3f0b13035fcdd6b605c0542a607255cecabcbb1b1ffabd23e131d83d">RIB</a>
, <a class="el" href="namespaceapf.html#a43962b2ec3f0b13035fcdd6b605c0542afd0f04e6c7f37704263c158f7cbb20e3">HYPERGRAPH</a>
, <a class="el" href="namespaceapf.html#a43962b2ec3f0b13035fcdd6b605c0542aeb776aa18738bd7e607f65389a957e22">PARMETIS</a>
, <br />
&#160;&#160;<a class="el" href="namespaceapf.html#a43962b2ec3f0b13035fcdd6b605c0542a7c9c0a487322ecba8b41d0331fbc5d1b">GRAPH</a>
<br />
 }</td></tr>
<tr class="memdesc:a43962b2ec3f0b13035fcdd6b605c0542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zoltan partitioning method.  <a href="namespaceapf.html#a43962b2ec3f0b13035fcdd6b605c0542">More...</a><br /></td></tr>
<tr class="separator:a43962b2ec3f0b13035fcdd6b605c0542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cbe5a6d7973e9a17036406a3cead028"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a4cbe5a6d7973e9a17036406a3cead028">ZoltanApproach</a> { <br />
&#160;&#160;<a class="el" href="namespaceapf.html#a4cbe5a6d7973e9a17036406a3cead028a8cb25195e6e91535fb91ec8693f3ba9f">PARTITION</a>
, <a class="el" href="namespaceapf.html#a4cbe5a6d7973e9a17036406a3cead028a61e3517c772e8d7ada0efb663e147063">REPARTITION</a>
, <a class="el" href="namespaceapf.html#a4cbe5a6d7973e9a17036406a3cead028ab295d9106368298122ff7c02701b5e45">REFINE</a>
, <a class="el" href="namespaceapf.html#a4cbe5a6d7973e9a17036406a3cead028ae6d3431a5438bf549c9ce3c7e9118eb6">PART_KWAY</a>
, <br />
&#160;&#160;<a class="el" href="namespaceapf.html#a4cbe5a6d7973e9a17036406a3cead028a26ca6977a5dfc333fd0478c4e495a304">PART_GEOM</a>
, <a class="el" href="namespaceapf.html#a4cbe5a6d7973e9a17036406a3cead028a02f85ed97912e559830f3c477facf458">PART_GEOM_KWAY</a>
, <a class="el" href="namespaceapf.html#a4cbe5a6d7973e9a17036406a3cead028ab381b0c6fa3cb9e4980ce664a7026b77">ADAPT_REPART</a>
, <a class="el" href="namespaceapf.html#a4cbe5a6d7973e9a17036406a3cead028a861462a65cf82c41d73959677370694a">REFINE_KWAY</a>
<br />
 }</td></tr>
<tr class="memdesc:a4cbe5a6d7973e9a17036406a3cead028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zoltan partitioning approach.  <a href="namespaceapf.html#a4cbe5a6d7973e9a17036406a3cead028">More...</a><br /></td></tr>
<tr class="separator:a4cbe5a6d7973e9a17036406a3cead028"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aacc951388f86b0fcce7a428905d09203"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#aacc951388f86b0fcce7a428905d09203">verify</a> (<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *m, bool abort_on_error=true)</td></tr>
<tr class="memdesc:aacc951388f86b0fcce7a428905d09203"><td class="mdescLeft">&#160;</td><td class="mdescRight">run consistency checks on an <a class="el" href="classapf_1_1Mesh.html" title="Interface to a mesh part.">apf::Mesh</a> structure  <a href="namespaceapf.html#aacc951388f86b0fcce7a428905d09203">More...</a><br /></td></tr>
<tr class="separator:aacc951388f86b0fcce7a428905d09203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e2205d0cf8588e0e673473942d8fb19"><td class="memItemLeft" align="right" valign="top"><a id="a1e2205d0cf8588e0e673473942d8fb19"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a1e2205d0cf8588e0e673473942d8fb19">getDimension</a> (<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *m, MeshEntity *e)</td></tr>
<tr class="memdesc:a1e2205d0cf8588e0e673473942d8fb19"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the dimension of a mesh entity <br /></td></tr>
<tr class="separator:a1e2205d0cf8588e0e673473942d8fb19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad72b0dfe3a9ddb52cd9b2a5fcec69591"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#ad72b0dfe3a9ddb52cd9b2a5fcec69591">unite</a> (<a class="el" href="namespaceapf.html#a29a3b61c20263ec345eed4108116ccfb">Parts</a> &amp;into, <a class="el" href="namespaceapf.html#a29a3b61c20263ec345eed4108116ccfb">Parts</a> const &amp;from)</td></tr>
<tr class="memdesc:ad72b0dfe3a9ddb52cd9b2a5fcec69591"><td class="mdescLeft">&#160;</td><td class="mdescRight">unite two sets of unique part ids  <a href="namespaceapf.html#ad72b0dfe3a9ddb52cd9b2a5fcec69591">More...</a><br /></td></tr>
<tr class="separator:ad72b0dfe3a9ddb52cd9b2a5fcec69591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d5d6ee966dca278b1a0e9da97ba542"><td class="memItemLeft" align="right" valign="top"><a id="a04d5d6ee966dca278b1a0e9da97ba542"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a04d5d6ee966dca278b1a0e9da97ba542">removeTagFromDimension</a> (<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *m, MeshTag *tag, int d)</td></tr>
<tr class="memdesc:a04d5d6ee966dca278b1a0e9da97ba542"><td class="mdescLeft">&#160;</td><td class="mdescRight">removes a tag from all entities of dimension (d) <br /></td></tr>
<tr class="separator:a04d5d6ee966dca278b1a0e9da97ba542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9247929491b6b16ca6eb2278c2829d5"><td class="memItemLeft" align="right" valign="top">MeshEntity *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#ab9247929491b6b16ca6eb2278c2829d5">findUpward</a> (<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *m, int type, MeshEntity **down)</td></tr>
<tr class="memdesc:ab9247929491b6b16ca6eb2278c2829d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">find an entity from one-level downward adjacencies  <a href="namespaceapf.html#ab9247929491b6b16ca6eb2278c2829d5">More...</a><br /></td></tr>
<tr class="separator:ab9247929491b6b16ca6eb2278c2829d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a984f9f8298f6d6d0e914ccf3e87f219b"><td class="memItemLeft" align="right" valign="top"><a id="a984f9f8298f6d6d0e914ccf3e87f219b"></a>
MeshEntity *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a984f9f8298f6d6d0e914ccf3e87f219b">findElement</a> (<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *m, int type, MeshEntity **verts)</td></tr>
<tr class="memdesc:a984f9f8298f6d6d0e914ccf3e87f219b"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds an entity from a set of vertices <br /></td></tr>
<tr class="separator:a984f9f8298f6d6d0e914ccf3e87f219b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed2c307897be17b3731efa7da377175"><td class="memItemLeft" align="right" valign="top"><a id="a9ed2c307897be17b3731efa7da377175"></a>
MeshEntity *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a9ed2c307897be17b3731efa7da377175">getEdgeVertOppositeVert</a> (<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *m, MeshEntity *edge, MeshEntity *v)</td></tr>
<tr class="memdesc:a9ed2c307897be17b3731efa7da377175"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the other vertex of an edge <br /></td></tr>
<tr class="separator:a9ed2c307897be17b3731efa7da377175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ddf84e7cec7c0834cd70d661047a5a"><td class="memItemLeft" align="right" valign="top"><a id="a58ddf84e7cec7c0834cd70d661047a5a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a58ddf84e7cec7c0834cd70d661047a5a">getBridgeAdjacent</a> (<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *m, MeshEntity *origin, int bridgeDimension, int targetDimension, <a class="el" href="namespaceapf.html#a12d882b4789bf98322cbe6f02c91b1f8">Adjacent</a> &amp;result)</td></tr>
<tr class="memdesc:a58ddf84e7cec7c0834cd70d661047a5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">get 2nd-order adjacent entities <br /></td></tr>
<tr class="separator:a58ddf84e7cec7c0834cd70d661047a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba448ac8886102662169334e4deb4d9"><td class="memItemLeft" align="right" valign="top"><a id="a1ba448ac8886102662169334e4deb4d9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a1ba448ac8886102662169334e4deb4d9">countEntitiesOfType</a> (<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *m, int type)</td></tr>
<tr class="memdesc:a1ba448ac8886102662169334e4deb4d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">count all on-part entities of one topological type <br /></td></tr>
<tr class="separator:a1ba448ac8886102662169334e4deb4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e3e83e0973a4aab8cb802e10714b65"><td class="memItemLeft" align="right" valign="top"><a id="a41e3e83e0973a4aab8cb802e10714b65"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a41e3e83e0973a4aab8cb802e10714b65">isSimplex</a> (int type)</td></tr>
<tr class="memdesc:a41e3e83e0973a4aab8cb802e10714b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">return true if the topological type is a simplex <br /></td></tr>
<tr class="separator:a41e3e83e0973a4aab8cb802e10714b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac591ef6eec60cf7f72077aaa2a3eb99f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapf_1_1Vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#ac591ef6eec60cf7f72077aaa2a3eb99f">getLinearCentroid</a> (<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *m, MeshEntity *e)</td></tr>
<tr class="memdesc:ac591ef6eec60cf7f72077aaa2a3eb99f"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the average of the entity's vertex coordinates  <a href="namespaceapf.html#ac591ef6eec60cf7f72077aaa2a3eb99f">More...</a><br /></td></tr>
<tr class="separator:ac591ef6eec60cf7f72077aaa2a3eb99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af5199eceb8f2e3e066c77d9e7392a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapf_1_1Sharing.html">Sharing</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a4af5199eceb8f2e3e066c77d9e7392a3">getSharing</a> (<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *m)</td></tr>
<tr class="memdesc:a4af5199eceb8f2e3e066c77d9e7392a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a default sharing object for this mesh  <a href="namespaceapf.html#a4af5199eceb8f2e3e066c77d9e7392a3">More...</a><br /></td></tr>
<tr class="separator:a4af5199eceb8f2e3e066c77d9e7392a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac96fc47d440599c228e96bbb87b2b2d2"><td class="memItemLeft" align="right" valign="top"><a id="ac96fc47d440599c228e96bbb87b2b2d2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#ac96fc47d440599c228e96bbb87b2b2d2">getPeers</a> (<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *m, int d, <a class="el" href="namespaceapf.html#a29a3b61c20263ec345eed4108116ccfb">Parts</a> &amp;peers)</td></tr>
<tr class="memdesc:ac96fc47d440599c228e96bbb87b2b2d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">scan the part for [vtx|edge|face]-adjacent part ids <br /></td></tr>
<tr class="separator:ac96fc47d440599c228e96bbb87b2b2d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82dd4758b562097e461aaec287ce951"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#ab82dd4758b562097e461aaec287ce951">findIn</a> (MeshEntity **a, int n, MeshEntity *e)</td></tr>
<tr class="memdesc:ab82dd4758b562097e461aaec287ce951"><td class="mdescLeft">&#160;</td><td class="mdescRight">find pointer (e) in array (a) of length (n)  <a href="namespaceapf.html#ab82dd4758b562097e461aaec287ce951">More...</a><br /></td></tr>
<tr class="separator:ab82dd4758b562097e461aaec287ce951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07afd339271516b1bb2f41e65c236ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#af07afd339271516b1bb2f41e65c236ea">findTriDown</a> (<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *m, MeshEntity **verts, MeshEntity **down)</td></tr>
<tr class="memdesc:af07afd339271516b1bb2f41e65c236ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">given the vertices of a triangle, find its edges  <a href="namespaceapf.html#af07afd339271516b1bb2f41e65c236ea">More...</a><br /></td></tr>
<tr class="separator:af07afd339271516b1bb2f41e65c236ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea387a42996d727e92c8fb72b0741e71"><td class="memItemLeft" align="right" valign="top"><a id="aea387a42996d727e92c8fb72b0741e71"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#aea387a42996d727e92c8fb72b0741e71">changeMeshShape</a> (<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *m, <a class="el" href="classapf_1_1FieldShape.html">FieldShape</a> *newShape, bool <a class="el" href="namespaceapf.html#a74b2d48997e8be5596a89e4536493441">project</a>=true)</td></tr>
<tr class="memdesc:aea387a42996d727e92c8fb72b0741e71"><td class="mdescLeft">&#160;</td><td class="mdescRight">deprecated wrapper for <a class="el" href="classapf_1_1Mesh.html#a648c4fbf43a147c94a6e420082961874" title="make a new coordinate field.">apf::Mesh::changeShape</a> <br /></td></tr>
<tr class="separator:aea387a42996d727e92c8fb72b0741e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58901b5327b2cced3d54bac594994ef3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a58901b5327b2cced3d54bac594994ef3">unfreezeFields</a> (<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *m)</td></tr>
<tr class="memdesc:a58901b5327b2cced3d54bac594994ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">unfreeze all associated fields  <a href="namespaceapf.html#a58901b5327b2cced3d54bac594994ef3">More...</a><br /></td></tr>
<tr class="separator:a58901b5327b2cced3d54bac594994ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b920221a1bd88d90b9d512aef30d7ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a6b920221a1bd88d90b9d512aef30d7ec">freezeFields</a> (<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *m)</td></tr>
<tr class="memdesc:a6b920221a1bd88d90b9d512aef30d7ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">freeze all associated fields  <a href="namespaceapf.html#a6b920221a1bd88d90b9d512aef30d7ec">More...</a><br /></td></tr>
<tr class="separator:a6b920221a1bd88d90b9d512aef30d7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04eb8d469b72008e023e8751ec98b311"><td class="memItemLeft" align="right" valign="top"><a id="a04eb8d469b72008e023e8751ec98b311"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a04eb8d469b72008e023e8751ec98b311">countEntitiesOn</a> (<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *m, ModelEntity *me, int dim)</td></tr>
<tr class="memdesc:a04eb8d469b72008e023e8751ec98b311"><td class="mdescLeft">&#160;</td><td class="mdescRight">count the number of mesh entities classified on a model entity <br /></td></tr>
<tr class="separator:a04eb8d469b72008e023e8751ec98b311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2662fb943f6c753ca1e11f2c2666794d"><td class="memItemLeft" align="right" valign="top"><a id="a2662fb943f6c753ca1e11f2c2666794d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a2662fb943f6c753ca1e11f2c2666794d">countOwned</a> (<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *m, int dim, <a class="el" href="structapf_1_1Sharing.html">Sharing</a> *shr=NULL)</td></tr>
<tr class="memdesc:a2662fb943f6c753ca1e11f2c2666794d"><td class="mdescLeft">&#160;</td><td class="mdescRight">count the number of owned entities of dimension (dim) using sharing shr the default sharing is used if none is provided <br /></td></tr>
<tr class="separator:a2662fb943f6c753ca1e11f2c2666794d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d93b402d648822e67b132bb9139c904"><td class="memItemLeft" align="right" valign="top"><a id="a3d93b402d648822e67b132bb9139c904"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a3d93b402d648822e67b132bb9139c904">printStats</a> (<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *m)</td></tr>
<tr class="memdesc:a3d93b402d648822e67b132bb9139c904"><td class="mdescLeft">&#160;</td><td class="mdescRight">print global mesh entity counts per dimension <br /></td></tr>
<tr class="separator:a3d93b402d648822e67b132bb9139c904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf3d9f02027d00d478c70a013e986b1e"><td class="memItemLeft" align="right" valign="top"><a id="adf3d9f02027d00d478c70a013e986b1e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#adf3d9f02027d00d478c70a013e986b1e">warnAboutEmptyParts</a> (<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *m)</td></tr>
<tr class="memdesc:adf3d9f02027d00d478c70a013e986b1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">print to stderr the number of empty parts, if any <br /></td></tr>
<tr class="separator:adf3d9f02027d00d478c70a013e986b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8101972d3ff3c8952e564d40a5078ff"><td class="memItemLeft" align="right" valign="top"><a id="ab8101972d3ff3c8952e564d40a5078ff"></a>
<a class="el" href="structapf_1_1Copy.html">Copy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#ab8101972d3ff3c8952e564d40a5078ff">getOtherCopy</a> (<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *m, MeshEntity *s)</td></tr>
<tr class="memdesc:ab8101972d3ff3c8952e564d40a5078ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">given a mesh face, return its remote copy <br /></td></tr>
<tr class="separator:ab8101972d3ff3c8952e564d40a5078ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f272efbfa825d1e4d15ceaca4baac04"><td class="memItemLeft" align="right" valign="top"><a id="a6f272efbfa825d1e4d15ceaca4baac04"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a6f272efbfa825d1e4d15ceaca4baac04">getFirstType</a> (<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *m, int dim)</td></tr>
<tr class="memdesc:a6f272efbfa825d1e4d15ceaca4baac04"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the type of the first entity in this dimension <br /></td></tr>
<tr class="separator:a6f272efbfa825d1e4d15ceaca4baac04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab906004ed9cb128d518f3278aeb99768"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#ab906004ed9cb128d518f3278aeb99768">getAlignment</a> (<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *m, MeshEntity *elem, MeshEntity *boundary, int &amp;which, bool &amp;flip, int &amp;<a class="el" href="namespaceapf.html#adb4c653b78d69109f4ac0f831ca9b43e">rotate</a>)</td></tr>
<tr class="memdesc:ab906004ed9cb128d518f3278aeb99768"><td class="mdescLeft">&#160;</td><td class="mdescRight">boundary entity alignment to an element  <a href="namespaceapf.html#ab906004ed9cb128d518f3278aeb99768">More...</a><br /></td></tr>
<tr class="separator:ab906004ed9cb128d518f3278aeb99768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa1384bcea95047a1b40c5c105a3a903"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#aaa1384bcea95047a1b40c5c105a3a903">migrate</a> (<a class="el" href="classapf_1_1Mesh2.html">Mesh2</a> *m, <a class="el" href="classapf_1_1Migration.html">Migration</a> *plan)</td></tr>
<tr class="memdesc:aaa1384bcea95047a1b40c5c105a3a903"><td class="mdescLeft">&#160;</td><td class="mdescRight">APF's migration function, works on <a class="el" href="classapf_1_1Mesh2.html" title="Extended mesh interface for modification.">apf::Mesh2</a>.  <a href="namespaceapf.html#aaa1384bcea95047a1b40c5c105a3a903">More...</a><br /></td></tr>
<tr class="separator:aaa1384bcea95047a1b40c5c105a3a903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16770e4cdc54e35c06e86254e5a8355f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a16770e4cdc54e35c06e86254e5a8355f">setMigrationLimit</a> (size_t maxElements, pcu::PCU *PCUObj)</td></tr>
<tr class="memdesc:a16770e4cdc54e35c06e86254e5a8355f"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the maximum elements that <a class="el" href="namespaceapf.html#aaa1384bcea95047a1b40c5c105a3a903" title="APF&#39;s migration function, works on apf::Mesh2.">apf::migrate</a> moves at once  <a href="namespaceapf.html#a16770e4cdc54e35c06e86254e5a8355f">More...</a><br /></td></tr>
<tr class="separator:a16770e4cdc54e35c06e86254e5a8355f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f5fee4fb7d38918b96a0f19645d9009"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a8f5fee4fb7d38918b96a0f19645d9009">displaceMesh</a> (<a class="el" href="classapf_1_1Mesh2.html">Mesh2</a> *m, Field *d, double factor=1.0)</td></tr>
<tr class="memdesc:a8f5fee4fb7d38918b96a0f19645d9009"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a field (times a factor) to the mesh coordinates  <a href="namespaceapf.html#a8f5fee4fb7d38918b96a0f19645d9009">More...</a><br /></td></tr>
<tr class="separator:a8f5fee4fb7d38918b96a0f19645d9009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af837304908b3e2376aa85a4283e3ec90"><td class="memItemLeft" align="right" valign="top"><a id="af837304908b3e2376aa85a4283e3ec90"></a>
MeshEntity *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#af837304908b3e2376aa85a4283e3ec90">makeOrFind</a> (<a class="el" href="classapf_1_1Mesh2.html">Mesh2</a> *m, ModelEntity *c, int type, MeshEntity **down, <a class="el" href="classapf_1_1BuildCallback.html">BuildCallback</a> *cb=0, bool *p_made=0)</td></tr>
<tr class="memdesc:af837304908b3e2376aa85a4283e3ec90"><td class="mdescLeft">&#160;</td><td class="mdescRight">like <a class="el" href="classapf_1_1Mesh2.html#ad1783114b947aae9ed4efda7184a5f70" title="Create a non-vertex mesh entity.">apf::Mesh2::createEntity</a>, but returns already existing entities <br /></td></tr>
<tr class="separator:af837304908b3e2376aa85a4283e3ec90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4a6608901d851a5d760bef899ca8e4a"><td class="memItemLeft" align="right" valign="top">MeshEntity *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#ae4a6608901d851a5d760bef899ca8e4a">buildElement</a> (<a class="el" href="classapf_1_1Mesh2.html">Mesh2</a> *m, ModelEntity *c, int type, MeshEntity **verts, <a class="el" href="classapf_1_1BuildCallback.html">BuildCallback</a> *cb=0)</td></tr>
<tr class="memdesc:ae4a6608901d851a5d760bef899ca8e4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">build an entity from its vertices  <a href="namespaceapf.html#ae4a6608901d851a5d760bef899ca8e4a">More...</a><br /></td></tr>
<tr class="separator:ae4a6608901d851a5d760bef899ca8e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44d7b4188599480d9ea5ae68139bb0f"><td class="memItemLeft" align="right" valign="top">MeshEntity *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#aa44d7b4188599480d9ea5ae68139bb0f">buildOneElement</a> (<a class="el" href="classapf_1_1Mesh2.html">Mesh2</a> *m, ModelEntity *c, int type, <a class="el" href="classapf_1_1Vector3.html">Vector3</a> const *points)</td></tr>
<tr class="memdesc:aa44d7b4188599480d9ea5ae68139bb0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">build a one-element mesh  <a href="namespaceapf.html#aa44d7b4188599480d9ea5ae68139bb0f">More...</a><br /></td></tr>
<tr class="separator:aa44d7b4188599480d9ea5ae68139bb0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a792eebd35597732f4ff0b4f63dab3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#ae8a792eebd35597732f4ff0b4f63dab3">initResidence</a> (<a class="el" href="classapf_1_1Mesh2.html">Mesh2</a> *m, int dim)</td></tr>
<tr class="memdesc:ae8a792eebd35597732f4ff0b4f63dab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set entity residence based on remote copies.  <a href="namespaceapf.html#ae8a792eebd35597732f4ff0b4f63dab3">More...</a><br /></td></tr>
<tr class="separator:ae8a792eebd35597732f4ff0b4f63dab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a626e7a91743ee2360316fc525a460d9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a626e7a91743ee2360316fc525a460d9e">stitchMesh</a> (<a class="el" href="classapf_1_1Mesh2.html">Mesh2</a> *m)</td></tr>
<tr class="memdesc:a626e7a91743ee2360316fc525a460d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">infer all remote copies from those of vertices  <a href="namespaceapf.html#a626e7a91743ee2360316fc525a460d9e">More...</a><br /></td></tr>
<tr class="separator:a626e7a91743ee2360316fc525a460d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7323d31aa94318541855c530f30253"><td class="memItemLeft" align="right" valign="top"><a id="abe7323d31aa94318541855c530f30253"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#abe7323d31aa94318541855c530f30253">clear</a> (<a class="el" href="classapf_1_1Mesh2.html">Mesh2</a> *m)</td></tr>
<tr class="memdesc:abe7323d31aa94318541855c530f30253"><td class="mdescLeft">&#160;</td><td class="mdescRight">removes all entities and fields. <br /></td></tr>
<tr class="separator:abe7323d31aa94318541855c530f30253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bda3647cf835f66149ed06cb7df16e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a7bda3647cf835f66149ed06cb7df16e3">destroyMesh</a> (<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *m)</td></tr>
<tr class="memdesc:a7bda3647cf835f66149ed06cb7df16e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys an <a class="el" href="classapf_1_1Mesh.html" title="Interface to a mesh part.">apf::Mesh</a>.  <a href="namespaceapf.html#a7bda3647cf835f66149ed06cb7df16e3">More...</a><br /></td></tr>
<tr class="separator:a7bda3647cf835f66149ed06cb7df16e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace5f1b3f0de2895610b4baab76a8d43a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceapf.html#a2432d4261391eda474007fb25c097a5c">MeshElement</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#ace5f1b3f0de2895610b4baab76a8d43a">createMeshElement</a> (<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *m, MeshEntity *e)</td></tr>
<tr class="memdesc:ace5f1b3f0de2895610b4baab76a8d43a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classapf_1_1Mesh.html" title="Interface to a mesh part.">Mesh</a> Element over an entity.  <a href="namespaceapf.html#ace5f1b3f0de2895610b4baab76a8d43a">More...</a><br /></td></tr>
<tr class="separator:ace5f1b3f0de2895610b4baab76a8d43a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e7a0817a30581f2975260e84155951"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceapf.html#a2432d4261391eda474007fb25c097a5c">MeshElement</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#af0e7a0817a30581f2975260e84155951">createMeshElement</a> (Field *c, MeshEntity *e)</td></tr>
<tr class="memdesc:af0e7a0817a30581f2975260e84155951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a non-standard <a class="el" href="classapf_1_1Mesh.html" title="Interface to a mesh part.">Mesh</a> Element over an entity.  <a href="namespaceapf.html#af0e7a0817a30581f2975260e84155951">More...</a><br /></td></tr>
<tr class="separator:af0e7a0817a30581f2975260e84155951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25bcf73c03d28876354b0647f5ad80ff"><td class="memItemLeft" align="right" valign="top"><a id="a25bcf73c03d28876354b0647f5ad80ff"></a>
MeshEntity *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a25bcf73c03d28876354b0647f5ad80ff">getMeshEntity</a> (<a class="el" href="namespaceapf.html#a2432d4261391eda474007fb25c097a5c">MeshElement</a> *me)</td></tr>
<tr class="memdesc:a25bcf73c03d28876354b0647f5ad80ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the mesh entity associated with an <a class="el" href="namespaceapf.html#a2432d4261391eda474007fb25c097a5c" title="Mesh Elements represent the mesh coordinate vector field.">apf::MeshElement</a>. <br /></td></tr>
<tr class="separator:a25bcf73c03d28876354b0647f5ad80ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae2bd20b6108fe74ce8ab1442883aee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#aaae2bd20b6108fe74ce8ab1442883aee">destroyMeshElement</a> (<a class="el" href="namespaceapf.html#a2432d4261391eda474007fb25c097a5c">MeshElement</a> *e)</td></tr>
<tr class="memdesc:aaae2bd20b6108fe74ce8ab1442883aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a <a class="el" href="classapf_1_1Mesh.html" title="Interface to a mesh part.">Mesh</a> Element.  <a href="namespaceapf.html#aaae2bd20b6108fe74ce8ab1442883aee">More...</a><br /></td></tr>
<tr class="separator:aaae2bd20b6108fe74ce8ab1442883aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a400d78f4f15ca30f6777e5c7c914d21e"><td class="memItemLeft" align="right" valign="top">Field *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a400d78f4f15ca30f6777e5c7c914d21e">createLagrangeField</a> (<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *m, const char *name, int valueType, int order)</td></tr>
<tr class="memdesc:a400d78f4f15ca30f6777e5c7c914d21e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an apf::Field using a Lagrange distribution.  <a href="namespaceapf.html#a400d78f4f15ca30f6777e5c7c914d21e">More...</a><br /></td></tr>
<tr class="separator:a400d78f4f15ca30f6777e5c7c914d21e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a038c413eb37a461bd7f45a46d9c6d2cf"><td class="memItemLeft" align="right" valign="top">Field *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a038c413eb37a461bd7f45a46d9c6d2cf">createStepField</a> (<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *m, const char *name, int valueType)</td></tr>
<tr class="memdesc:a038c413eb37a461bd7f45a46d9c6d2cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an apf::Field using a step distribution.  <a href="namespaceapf.html#a038c413eb37a461bd7f45a46d9c6d2cf">More...</a><br /></td></tr>
<tr class="separator:a038c413eb37a461bd7f45a46d9c6d2cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ed69b0b7d444f1e2e16609a74b5393"><td class="memItemLeft" align="right" valign="top">Field *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a88ed69b0b7d444f1e2e16609a74b5393">createIPField</a> (<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *m, const char *name, int valueType, int order)</td></tr>
<tr class="memdesc:a88ed69b0b7d444f1e2e16609a74b5393"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an apf::Field of integration point data.  <a href="namespaceapf.html#a88ed69b0b7d444f1e2e16609a74b5393">More...</a><br /></td></tr>
<tr class="separator:a88ed69b0b7d444f1e2e16609a74b5393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d0a29310d99940e8c870f9e33d300c1"><td class="memItemLeft" align="right" valign="top"><a id="a6d0a29310d99940e8c870f9e33d300c1"></a>
Field *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a6d0a29310d99940e8c870f9e33d300c1">createField</a> (<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *m, const char *name, int valueType, <a class="el" href="classapf_1_1FieldShape.html">FieldShape</a> *shape)</td></tr>
<tr class="memdesc:a6d0a29310d99940e8c870f9e33d300c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a Field from any builtin or user defined <a class="el" href="classapf_1_1FieldShape.html" title="Describes field distribution and shape functions.">FieldShape</a>. <br /></td></tr>
<tr class="separator:a6d0a29310d99940e8c870f9e33d300c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab806bccc289b22450a3364bcb8059a12"><td class="memItemLeft" align="right" valign="top"><a id="ab806bccc289b22450a3364bcb8059a12"></a>
Field *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#ab806bccc289b22450a3364bcb8059a12">createFieldOn</a> (<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *m, const char *name, int valueType)</td></tr>
<tr class="memdesc:ab806bccc289b22450a3364bcb8059a12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a field using the mesh's coordinate nodal distribution. <br /></td></tr>
<tr class="separator:ab806bccc289b22450a3364bcb8059a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b88a075efe41bae69973e6b7ae26a01"><td class="memItemLeft" align="right" valign="top">Field *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a4b88a075efe41bae69973e6b7ae26a01">createPackedField</a> (<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *m, const char *name, int components, <a class="el" href="classapf_1_1FieldShape.html">apf::FieldShape</a> *shape=0)</td></tr>
<tr class="memdesc:a4b88a075efe41bae69973e6b7ae26a01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a field of N components without a tensor type.  <a href="namespaceapf.html#a4b88a075efe41bae69973e6b7ae26a01">More...</a><br /></td></tr>
<tr class="separator:a4b88a075efe41bae69973e6b7ae26a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a699a92a3c4835803baaf476b57a98871"><td class="memItemLeft" align="right" valign="top"><a id="a699a92a3c4835803baaf476b57a98871"></a>
Field *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a699a92a3c4835803baaf476b57a98871">createGeneralField</a> (<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *m, const char *name, int valueType, int components, <a class="el" href="classapf_1_1FieldShape.html">FieldShape</a> *shape)</td></tr>
<tr class="memdesc:a699a92a3c4835803baaf476b57a98871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encompasses both packed and typed fields. <br /></td></tr>
<tr class="separator:a699a92a3c4835803baaf476b57a98871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9676300a7af8a3996f04687fcd5074d"><td class="memItemLeft" align="right" valign="top">Field *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#ac9676300a7af8a3996f04687fcd5074d">cloneField</a> (Field *f, <a class="el" href="classapf_1_1Mesh.html">Mesh</a> *onto)</td></tr>
<tr class="memdesc:ac9676300a7af8a3996f04687fcd5074d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a copy of a field on another <a class="el" href="classapf_1_1Mesh.html" title="Interface to a mesh part.">apf::Mesh</a>.  <a href="namespaceapf.html#ac9676300a7af8a3996f04687fcd5074d">More...</a><br /></td></tr>
<tr class="separator:ac9676300a7af8a3996f04687fcd5074d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b903550e7e7bcdbb5aa56159e3338a"><td class="memItemLeft" align="right" valign="top"><a id="ae5b903550e7e7bcdbb5aa56159e3338a"></a>
<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#ae5b903550e7e7bcdbb5aa56159e3338a">getMesh</a> (Field *f)</td></tr>
<tr class="memdesc:ae5b903550e7e7bcdbb5aa56159e3338a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the <a class="el" href="classapf_1_1Mesh.html" title="Interface to a mesh part.">Mesh</a> over which a Field is defined. <br /></td></tr>
<tr class="separator:ae5b903550e7e7bcdbb5aa56159e3338a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a7b64282862e4a6c95cc992fd1e5ca"><td class="memItemLeft" align="right" valign="top"><a id="af2a7b64282862e4a6c95cc992fd1e5ca"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#af2a7b64282862e4a6c95cc992fd1e5ca">hasEntity</a> (Field *f, MeshEntity *e)</td></tr>
<tr class="memdesc:af2a7b64282862e4a6c95cc992fd1e5ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff an entity has data associate with a field. <br /></td></tr>
<tr class="separator:af2a7b64282862e4a6c95cc992fd1e5ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c9303c704c21ebdc1eca5381941fe4a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a9c9303c704c21ebdc1eca5381941fe4a">getName</a> (Field *f)</td></tr>
<tr class="memdesc:a9c9303c704c21ebdc1eca5381941fe4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of a Field.  <a href="namespaceapf.html#a9c9303c704c21ebdc1eca5381941fe4a">More...</a><br /></td></tr>
<tr class="separator:a9c9303c704c21ebdc1eca5381941fe4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede3c746f5690d8e2d0c4042888e4584"><td class="memItemLeft" align="right" valign="top"><a id="aede3c746f5690d8e2d0c4042888e4584"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#aede3c746f5690d8e2d0c4042888e4584">getValueType</a> (Field *f)</td></tr>
<tr class="memdesc:aede3c746f5690d8e2d0c4042888e4584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the type of value a field distributes. <br /></td></tr>
<tr class="separator:aede3c746f5690d8e2d0c4042888e4584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b79d22c97ba66e7c5b483b864dd7124"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a2b79d22c97ba66e7c5b483b864dd7124">destroyField</a> (Field *f)</td></tr>
<tr class="memdesc:a2b79d22c97ba66e7c5b483b864dd7124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy an apf::Field.  <a href="namespaceapf.html#a2b79d22c97ba66e7c5b483b864dd7124">More...</a><br /></td></tr>
<tr class="separator:a2b79d22c97ba66e7c5b483b864dd7124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a062b8132296bdfc66e8d77f2137fdb0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a062b8132296bdfc66e8d77f2137fdb0f">setScalar</a> (Field *f, MeshEntity *e, int node, double value)</td></tr>
<tr class="memdesc:a062b8132296bdfc66e8d77f2137fdb0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a nodal value of a scalar field.  <a href="namespaceapf.html#a062b8132296bdfc66e8d77f2137fdb0f">More...</a><br /></td></tr>
<tr class="separator:a062b8132296bdfc66e8d77f2137fdb0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f49dd1ad24649b6feb4ade5b97e2c6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a21f49dd1ad24649b6feb4ade5b97e2c6">getScalar</a> (Field *f, MeshEntity *e, int node)</td></tr>
<tr class="memdesc:a21f49dd1ad24649b6feb4ade5b97e2c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the node value of a scalar field.  <a href="namespaceapf.html#a21f49dd1ad24649b6feb4ade5b97e2c6">More...</a><br /></td></tr>
<tr class="separator:a21f49dd1ad24649b6feb4ade5b97e2c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab12f19c06db0f1451b1c301b2b163f58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#ab12f19c06db0f1451b1c301b2b163f58">setVector</a> (Field *f, MeshEntity *e, int node, <a class="el" href="classapf_1_1Vector3.html">Vector3</a> const &amp;value)</td></tr>
<tr class="memdesc:ab12f19c06db0f1451b1c301b2b163f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the nodal value of a vector field.  <a href="namespaceapf.html#ab12f19c06db0f1451b1c301b2b163f58">More...</a><br /></td></tr>
<tr class="separator:ab12f19c06db0f1451b1c301b2b163f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41321354a5950274560da186d8d121ab"><td class="memItemLeft" align="right" valign="top"><a id="a41321354a5950274560da186d8d121ab"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a41321354a5950274560da186d8d121ab">getVector</a> (Field *f, MeshEntity *e, int node, <a class="el" href="classapf_1_1Vector3.html">Vector3</a> &amp;value)</td></tr>
<tr class="memdesc:a41321354a5950274560da186d8d121ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nodal value of a vector field. <br /></td></tr>
<tr class="separator:a41321354a5950274560da186d8d121ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9985cf69e3345d77e51124c81851481c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a9985cf69e3345d77e51124c81851481c">setMatrix</a> (Field *f, MeshEntity *e, int node, <a class="el" href="classapf_1_1Matrix3x3.html">Matrix3x3</a> const &amp;value)</td></tr>
<tr class="memdesc:a9985cf69e3345d77e51124c81851481c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the nodal value of a matrix field.  <a href="namespaceapf.html#a9985cf69e3345d77e51124c81851481c">More...</a><br /></td></tr>
<tr class="separator:a9985cf69e3345d77e51124c81851481c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78d2949c909f56ef9ad9a876a0bbb924"><td class="memItemLeft" align="right" valign="top"><a id="a78d2949c909f56ef9ad9a876a0bbb924"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a78d2949c909f56ef9ad9a876a0bbb924">getMatrix</a> (Field *f, MeshEntity *e, int node, <a class="el" href="classapf_1_1Matrix3x3.html">Matrix3x3</a> &amp;value)</td></tr>
<tr class="memdesc:a78d2949c909f56ef9ad9a876a0bbb924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nodal value of a matrix field. <br /></td></tr>
<tr class="separator:a78d2949c909f56ef9ad9a876a0bbb924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a46d64622615234c0e1ad3d0624637"><td class="memItemLeft" align="right" valign="top"><a id="aa3a46d64622615234c0e1ad3d0624637"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#aa3a46d64622615234c0e1ad3d0624637">setComponents</a> (Field *f, MeshEntity *e, int node, double const *components)</td></tr>
<tr class="memdesc:aa3a46d64622615234c0e1ad3d0624637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the nodal value from an array of component values. <br /></td></tr>
<tr class="separator:aa3a46d64622615234c0e1ad3d0624637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a28f381daa5e2b9d2509a53340cec5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a3a28f381daa5e2b9d2509a53340cec5d">getComponents</a> (Field *f, MeshEntity *e, int node, double *components)</td></tr>
<tr class="memdesc:a3a28f381daa5e2b9d2509a53340cec5d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structapf_1_1Copy.html" title="a reference to an object representing the same entity">Copy</a> the nodal value into an array of component values.  <a href="namespaceapf.html#a3a28f381daa5e2b9d2509a53340cec5d">More...</a><br /></td></tr>
<tr class="separator:a3a28f381daa5e2b9d2509a53340cec5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee6038584427e88583e5c9749ddc3384"><td class="memItemLeft" align="right" valign="top">Element *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#aee6038584427e88583e5c9749ddc3384">createElement</a> (Field *f, <a class="el" href="namespaceapf.html#a2432d4261391eda474007fb25c097a5c">MeshElement</a> *e)</td></tr>
<tr class="memdesc:aee6038584427e88583e5c9749ddc3384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a Field Element from a <a class="el" href="classapf_1_1Mesh.html" title="Interface to a mesh part.">Mesh</a> Element.  <a href="namespaceapf.html#aee6038584427e88583e5c9749ddc3384">More...</a><br /></td></tr>
<tr class="separator:aee6038584427e88583e5c9749ddc3384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd3f44db9edac67c1976e25a6c06219"><td class="memItemLeft" align="right" valign="top">Element *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a5dd3f44db9edac67c1976e25a6c06219">createElement</a> (Field *f, MeshEntity *e)</td></tr>
<tr class="memdesc:a5dd3f44db9edac67c1976e25a6c06219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a Field Element without a parent <a class="el" href="classapf_1_1Mesh.html" title="Interface to a mesh part.">Mesh</a> Element.  <a href="namespaceapf.html#a5dd3f44db9edac67c1976e25a6c06219">More...</a><br /></td></tr>
<tr class="separator:a5dd3f44db9edac67c1976e25a6c06219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1780811d0eda93fbe8e1cb6005ae8f6"><td class="memItemLeft" align="right" valign="top"><a id="ac1780811d0eda93fbe8e1cb6005ae8f6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#ac1780811d0eda93fbe8e1cb6005ae8f6">destroyElement</a> (Element *e)</td></tr>
<tr class="memdesc:ac1780811d0eda93fbe8e1cb6005ae8f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a Field Element. <br /></td></tr>
<tr class="separator:ac1780811d0eda93fbe8e1cb6005ae8f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d835945b28d94e965f12490e578f7a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceapf.html#a2432d4261391eda474007fb25c097a5c">MeshElement</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a2d835945b28d94e965f12490e578f7a1">getMeshElement</a> (Element *e)</td></tr>
<tr class="memdesc:a2d835945b28d94e965f12490e578f7a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classapf_1_1Mesh.html" title="Interface to a mesh part.">Mesh</a> Element of a Field Element.  <a href="namespaceapf.html#a2d835945b28d94e965f12490e578f7a1">More...</a><br /></td></tr>
<tr class="separator:a2d835945b28d94e965f12490e578f7a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc9cc7c31723fc95a36d3fb3ef20d815"><td class="memItemLeft" align="right" valign="top"><a id="afc9cc7c31723fc95a36d3fb3ef20d815"></a>
MeshEntity *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#afc9cc7c31723fc95a36d3fb3ef20d815">getMeshEntity</a> (Element *e)</td></tr>
<tr class="memdesc:afc9cc7c31723fc95a36d3fb3ef20d815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the mesh entity of an apf::Element. <br /></td></tr>
<tr class="separator:afc9cc7c31723fc95a36d3fb3ef20d815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93114a205e5418c53c8f72951d61d527"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a93114a205e5418c53c8f72951d61d527">getScalar</a> (Element *e, <a class="el" href="classapf_1_1Vector3.html">Vector3</a> const &amp;param)</td></tr>
<tr class="memdesc:a93114a205e5418c53c8f72951d61d527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a scalar field at a point.  <a href="namespaceapf.html#a93114a205e5418c53c8f72951d61d527">More...</a><br /></td></tr>
<tr class="separator:a93114a205e5418c53c8f72951d61d527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74d7e9574a568fa957b61cf403a53e10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a74d7e9574a568fa957b61cf403a53e10">getGrad</a> (Element *e, <a class="el" href="classapf_1_1Vector3.html">Vector3</a> const &amp;param, <a class="el" href="classapf_1_1Vector3.html">Vector3</a> &amp;grad)</td></tr>
<tr class="memdesc:a74d7e9574a568fa957b61cf403a53e10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the gradient of a scalar field w.r.t. global coordinates.  <a href="namespaceapf.html#a74d7e9574a568fa957b61cf403a53e10">More...</a><br /></td></tr>
<tr class="separator:a74d7e9574a568fa957b61cf403a53e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad575d3d0b4e2c208ff9eda31b4f0b281"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#ad575d3d0b4e2c208ff9eda31b4f0b281">getVector</a> (Element *e, <a class="el" href="classapf_1_1Vector3.html">Vector3</a> const &amp;param, <a class="el" href="classapf_1_1Vector3.html">Vector3</a> &amp;value)</td></tr>
<tr class="memdesc:ad575d3d0b4e2c208ff9eda31b4f0b281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a vector field at a point.  <a href="namespaceapf.html#ad575d3d0b4e2c208ff9eda31b4f0b281">More...</a><br /></td></tr>
<tr class="separator:ad575d3d0b4e2c208ff9eda31b4f0b281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b73ca5b7cf048976a69a0178fe52d1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a10b73ca5b7cf048976a69a0178fe52d1">getDiv</a> (Element *e, <a class="el" href="classapf_1_1Vector3.html">Vector3</a> const &amp;param)</td></tr>
<tr class="memdesc:a10b73ca5b7cf048976a69a0178fe52d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the divergence of a vector field at a point.  <a href="namespaceapf.html#a10b73ca5b7cf048976a69a0178fe52d1">More...</a><br /></td></tr>
<tr class="separator:a10b73ca5b7cf048976a69a0178fe52d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3171054c0ff9a4e155911ec832de7bb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a3171054c0ff9a4e155911ec832de7bb6">getCurl</a> (Element *e, <a class="el" href="classapf_1_1Vector3.html">Vector3</a> const &amp;param, <a class="el" href="classapf_1_1Vector3.html">Vector3</a> &amp;curl)</td></tr>
<tr class="memdesc:a3171054c0ff9a4e155911ec832de7bb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the curl of a vector field at a point.  <a href="namespaceapf.html#a3171054c0ff9a4e155911ec832de7bb6">More...</a><br /></td></tr>
<tr class="separator:a3171054c0ff9a4e155911ec832de7bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c85fe4ca92302918d0820aec729a2f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a2c85fe4ca92302918d0820aec729a2f3">getVectorGrad</a> (Element *e, <a class="el" href="classapf_1_1Vector3.html">Vector3</a> const &amp;param, <a class="el" href="classapf_1_1Matrix3x3.html">Matrix3x3</a> &amp;deriv)</td></tr>
<tr class="memdesc:a2c85fe4ca92302918d0820aec729a2f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the gradient of a vector field w.r.t. global coordinates.  <a href="namespaceapf.html#a2c85fe4ca92302918d0820aec729a2f3">More...</a><br /></td></tr>
<tr class="separator:a2c85fe4ca92302918d0820aec729a2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab9088db5d09e32dc5add2ae9c4f056e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#aab9088db5d09e32dc5add2ae9c4f056e">getMatrix</a> (Element *e, <a class="el" href="classapf_1_1Vector3.html">Vector3</a> const &amp;param, <a class="el" href="classapf_1_1Matrix3x3.html">Matrix3x3</a> &amp;value)</td></tr>
<tr class="memdesc:aab9088db5d09e32dc5add2ae9c4f056e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the value of a matrix field.  <a href="namespaceapf.html#aab9088db5d09e32dc5add2ae9c4f056e">More...</a><br /></td></tr>
<tr class="separator:aab9088db5d09e32dc5add2ae9c4f056e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2136dffb47de654b729396362b79bda4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a2136dffb47de654b729396362b79bda4">getMatrixGrad</a> (Element *e, <a class="el" href="classapf_1_1Vector3.html">Vector3</a> const &amp;param, <a class="el" href="classapf_1_1Vector.html">Vector</a>&lt; 27 &gt; &amp;value)</td></tr>
<tr class="memdesc:a2136dffb47de654b729396362b79bda4"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the gradient of a matrix field  <a href="namespaceapf.html#a2136dffb47de654b729396362b79bda4">More...</a><br /></td></tr>
<tr class="separator:a2136dffb47de654b729396362b79bda4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf435eee9b8c5a7f5b671d62ecd58656"><td class="memItemLeft" align="right" valign="top"><a id="aaf435eee9b8c5a7f5b671d62ecd58656"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#aaf435eee9b8c5a7f5b671d62ecd58656">getComponents</a> (Element *e, <a class="el" href="classapf_1_1Vector3.html">Vector3</a> const &amp;param, double *components)</td></tr>
<tr class="memdesc:aaf435eee9b8c5a7f5b671d62ecd58656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a field into an array of component values. <br /></td></tr>
<tr class="separator:aaf435eee9b8c5a7f5b671d62ecd58656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a8c7a2a41b08310447cc121097cb983"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a0a8c7a2a41b08310447cc121097cb983">countIntPoints</a> (<a class="el" href="namespaceapf.html#a2432d4261391eda474007fb25c097a5c">MeshElement</a> *e, int order)</td></tr>
<tr class="memdesc:a0a8c7a2a41b08310447cc121097cb983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of integration points for an element.  <a href="namespaceapf.html#a0a8c7a2a41b08310447cc121097cb983">More...</a><br /></td></tr>
<tr class="separator:a0a8c7a2a41b08310447cc121097cb983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e2f7a90a99e25e31dd5441b39f08f11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a7e2f7a90a99e25e31dd5441b39f08f11">getIntPoint</a> (<a class="el" href="namespaceapf.html#a2432d4261391eda474007fb25c097a5c">MeshElement</a> *e, int order, int point, <a class="el" href="classapf_1_1Vector3.html">Vector3</a> &amp;param)</td></tr>
<tr class="memdesc:a7e2f7a90a99e25e31dd5441b39f08f11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an integration point in an element.  <a href="namespaceapf.html#a7e2f7a90a99e25e31dd5441b39f08f11">More...</a><br /></td></tr>
<tr class="separator:a7e2f7a90a99e25e31dd5441b39f08f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f08a4de2c81f3dcff5d93fb0f33e1f5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a2f08a4de2c81f3dcff5d93fb0f33e1f5">getIntWeight</a> (<a class="el" href="namespaceapf.html#a2432d4261391eda474007fb25c097a5c">MeshElement</a> *e, int order, int point)</td></tr>
<tr class="memdesc:a2f08a4de2c81f3dcff5d93fb0f33e1f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the weight of an integration point in an element.  <a href="namespaceapf.html#a2f08a4de2c81f3dcff5d93fb0f33e1f5">More...</a><br /></td></tr>
<tr class="separator:a2f08a4de2c81f3dcff5d93fb0f33e1f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6506765e46caae8ab2bcc9df3367e7"><td class="memItemLeft" align="right" valign="top"><a id="a4c6506765e46caae8ab2bcc9df3367e7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a4c6506765e46caae8ab2bcc9df3367e7">mapLocalToGlobal</a> (<a class="el" href="namespaceapf.html#a2432d4261391eda474007fb25c097a5c">MeshElement</a> *e, <a class="el" href="classapf_1_1Vector3.html">Vector3</a> const &amp;local, <a class="el" href="classapf_1_1Vector3.html">Vector3</a> &amp;global)</td></tr>
<tr class="memdesc:a4c6506765e46caae8ab2bcc9df3367e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map a local coordinate to a global coordinate. <br /></td></tr>
<tr class="separator:a4c6506765e46caae8ab2bcc9df3367e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4287cd7f923a63c1382ad30fd0507e4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#ae4287cd7f923a63c1382ad30fd0507e4">getDV</a> (<a class="el" href="namespaceapf.html#a2432d4261391eda474007fb25c097a5c">MeshElement</a> *e, <a class="el" href="classapf_1_1Vector3.html">Vector3</a> const &amp;param)</td></tr>
<tr class="memdesc:ae4287cd7f923a63c1382ad30fd0507e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the differential volume at a point.  <a href="namespaceapf.html#ae4287cd7f923a63c1382ad30fd0507e4">More...</a><br /></td></tr>
<tr class="separator:ae4287cd7f923a63c1382ad30fd0507e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a611fe911507d50e2bb4702522f66ab83"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a611fe911507d50e2bb4702522f66ab83">measure</a> (<a class="el" href="namespaceapf.html#a2432d4261391eda474007fb25c097a5c">MeshElement</a> *e)</td></tr>
<tr class="memdesc:a611fe911507d50e2bb4702522f66ab83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures the volume, area, or length of a <a class="el" href="classapf_1_1Mesh.html" title="Interface to a mesh part.">Mesh</a> Element.  <a href="namespaceapf.html#a611fe911507d50e2bb4702522f66ab83">More...</a><br /></td></tr>
<tr class="separator:a611fe911507d50e2bb4702522f66ab83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11d34d97e12206457c6e1492c7771ad"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#ad11d34d97e12206457c6e1492c7771ad">measure</a> (<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *m, MeshEntity *e)</td></tr>
<tr class="memdesc:ad11d34d97e12206457c6e1492c7771ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures the volume, area, or length of a <a class="el" href="classapf_1_1Mesh.html" title="Interface to a mesh part.">Mesh</a> Entity.  <a href="namespaceapf.html#ad11d34d97e12206457c6e1492c7771ad">More...</a><br /></td></tr>
<tr class="separator:ad11d34d97e12206457c6e1492c7771ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e0426339c776bf8d76a718bd1a1e62"><td class="memItemLeft" align="right" valign="top"><a id="a81e0426339c776bf8d76a718bd1a1e62"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a81e0426339c776bf8d76a718bd1a1e62">getOrder</a> (<a class="el" href="namespaceapf.html#a2432d4261391eda474007fb25c097a5c">MeshElement</a> *e)</td></tr>
<tr class="memdesc:a81e0426339c776bf8d76a718bd1a1e62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the polynomial order of the coordinate field. <br /></td></tr>
<tr class="separator:a81e0426339c776bf8d76a718bd1a1e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351b98eee02f3bd393c06c9733e4f2f4"><td class="memItemLeft" align="right" valign="top"><a id="a351b98eee02f3bd393c06c9733e4f2f4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a351b98eee02f3bd393c06c9733e4f2f4">getJacobian</a> (<a class="el" href="namespaceapf.html#a2432d4261391eda474007fb25c097a5c">MeshElement</a> *e, <a class="el" href="classapf_1_1Vector3.html">Vector3</a> const &amp;local, <a class="el" href="classapf_1_1Matrix3x3.html">Matrix3x3</a> &amp;j)</td></tr>
<tr class="memdesc:a351b98eee02f3bd393c06c9733e4f2f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Jacobian at a local point. <br /></td></tr>
<tr class="separator:a351b98eee02f3bd393c06c9733e4f2f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a038f86d6baa21578815f05d0ab592330"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a038f86d6baa21578815f05d0ab592330">getJacobianInv</a> (<a class="el" href="namespaceapf.html#a2432d4261391eda474007fb25c097a5c">MeshElement</a> *e, <a class="el" href="classapf_1_1Vector3.html">Vector3</a> const &amp;local, <a class="el" href="classapf_1_1Matrix3x3.html">Matrix3x3</a> &amp;jinv)</td></tr>
<tr class="memdesc:a038f86d6baa21578815f05d0ab592330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Jacobian inverse at a local point.  <a href="namespaceapf.html#a038f86d6baa21578815f05d0ab592330">More...</a><br /></td></tr>
<tr class="separator:a038f86d6baa21578815f05d0ab592330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8887da228f381495b0fc64e1ed05ef7f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a8887da228f381495b0fc64e1ed05ef7f">computeCosAngle</a> (<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *m, MeshEntity *pe, MeshEntity *e1, MeshEntity *e2, const <a class="el" href="classapf_1_1Matrix3x3.html">Matrix3x3</a> &amp;Q)</td></tr>
<tr class="memdesc:a8887da228f381495b0fc64e1ed05ef7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the cosine of the angle between 2 entities of the parent entity.  <a href="namespaceapf.html#a8887da228f381495b0fc64e1ed05ef7f">More...</a><br /></td></tr>
<tr class="separator:a8887da228f381495b0fc64e1ed05ef7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc17aa58ccf7f217ac613b31641a8848"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#acc17aa58ccf7f217ac613b31641a8848">computeShortestHeightInTet</a> (<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *m, MeshEntity *tet, const <a class="el" href="classapf_1_1Matrix3x3.html">Matrix3x3</a> &amp;Q=<a class="el" href="classapf_1_1Matrix3x3.html">Matrix3x3</a>(1., 0., 0., 0., 1., 0., 0., 0., 1.))</td></tr>
<tr class="memdesc:acc17aa58ccf7f217ac613b31641a8848"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the shortest height in a tet.  <a href="namespaceapf.html#acc17aa58ccf7f217ac613b31641a8848">More...</a><br /></td></tr>
<tr class="separator:acc17aa58ccf7f217ac613b31641a8848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a032b8f4e5af4f9fb95280ed8ab82e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#af7a032b8f4e5af4f9fb95280ed8ab82e">computeLargestHeightInTet</a> (<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *m, MeshEntity *tet, const <a class="el" href="classapf_1_1Matrix3x3.html">Matrix3x3</a> &amp;Q=<a class="el" href="classapf_1_1Matrix3x3.html">Matrix3x3</a>(1., 0., 0., 0., 1., 0., 0., 0., 1.))</td></tr>
<tr class="memdesc:af7a032b8f4e5af4f9fb95280ed8ab82e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the largest height in a tet.  <a href="namespaceapf.html#af7a032b8f4e5af4f9fb95280ed8ab82e">More...</a><br /></td></tr>
<tr class="separator:af7a032b8f4e5af4f9fb95280ed8ab82e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c65bc4f2bd7ca1cd97010263bd6d01a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a9c65bc4f2bd7ca1cd97010263bd6d01a">computeShortestHeightInTri</a> (<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *m, MeshEntity *tri, const <a class="el" href="classapf_1_1Matrix3x3.html">Matrix3x3</a> &amp;Q=<a class="el" href="classapf_1_1Matrix3x3.html">Matrix3x3</a>(1., 0., 0., 0., 1., 0., 0., 0., 1.))</td></tr>
<tr class="memdesc:a9c65bc4f2bd7ca1cd97010263bd6d01a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the shortest height in a tri.  <a href="namespaceapf.html#a9c65bc4f2bd7ca1cd97010263bd6d01a">More...</a><br /></td></tr>
<tr class="separator:a9c65bc4f2bd7ca1cd97010263bd6d01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a248ed46bc77893a76e2ad1865d4a58c8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a248ed46bc77893a76e2ad1865d4a58c8">computeLargestHeightInTri</a> (<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *m, MeshEntity *tri, const <a class="el" href="classapf_1_1Matrix3x3.html">Matrix3x3</a> &amp;Q=<a class="el" href="classapf_1_1Matrix3x3.html">Matrix3x3</a>(1., 0., 0., 0., 1., 0., 0., 0., 1.))</td></tr>
<tr class="memdesc:a248ed46bc77893a76e2ad1865d4a58c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the largest height in a tri.  <a href="namespaceapf.html#a248ed46bc77893a76e2ad1865d4a58c8">More...</a><br /></td></tr>
<tr class="separator:a248ed46bc77893a76e2ad1865d4a58c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ef08c6cf2af320e8346bd3abb3e2cb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a00ef08c6cf2af320e8346bd3abb3e2cb">countNodes</a> (Element *e)</td></tr>
<tr class="memdesc:a00ef08c6cf2af320e8346bd3abb3e2cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of element nodes.  <a href="namespaceapf.html#a00ef08c6cf2af320e8346bd3abb3e2cb">More...</a><br /></td></tr>
<tr class="separator:a00ef08c6cf2af320e8346bd3abb3e2cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68bf11c033812574b949bd0e1687d99c"><td class="memItemLeft" align="right" valign="top"><a id="a68bf11c033812574b949bd0e1687d99c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a68bf11c033812574b949bd0e1687d99c">getScalarNodes</a> (Element *e, NewArray&lt; double &gt; &amp;values)</td></tr>
<tr class="memdesc:a68bf11c033812574b949bd0e1687d99c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element nodal values for a scalar field. <br /></td></tr>
<tr class="separator:a68bf11c033812574b949bd0e1687d99c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f0ad884afd6eddea6ab01be9e06db1"><td class="memItemLeft" align="right" valign="top"><a id="a90f0ad884afd6eddea6ab01be9e06db1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a90f0ad884afd6eddea6ab01be9e06db1">getVectorNodes</a> (Element *e, NewArray&lt; <a class="el" href="classapf_1_1Vector3.html">Vector3</a> &gt; &amp;values)</td></tr>
<tr class="memdesc:a90f0ad884afd6eddea6ab01be9e06db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element nodal values for a vector field. <br /></td></tr>
<tr class="separator:a90f0ad884afd6eddea6ab01be9e06db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a931379415261f28db516fab3f689d9"><td class="memItemLeft" align="right" valign="top"><a id="a5a931379415261f28db516fab3f689d9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a5a931379415261f28db516fab3f689d9">getMatrixNodes</a> (Element *e, NewArray&lt; <a class="el" href="classapf_1_1Matrix3x3.html">Matrix3x3</a> &gt; &amp;values)</td></tr>
<tr class="memdesc:a5a931379415261f28db516fab3f689d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element nodal values for a matrix field. <br /></td></tr>
<tr class="separator:a5a931379415261f28db516fab3f689d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e9c3eaa9f8ec5f59612d1f2386f37f"><td class="memItemLeft" align="right" valign="top"><a id="ac2e9c3eaa9f8ec5f59612d1f2386f37f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#ac2e9c3eaa9f8ec5f59612d1f2386f37f">getShapeValues</a> (Element *e, <a class="el" href="classapf_1_1Vector3.html">Vector3</a> const &amp;local, NewArray&lt; double &gt; &amp;values)</td></tr>
<tr class="memdesc:ac2e9c3eaa9f8ec5f59612d1f2386f37f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the shape function values at a point. <br /></td></tr>
<tr class="separator:ac2e9c3eaa9f8ec5f59612d1f2386f37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12329911aa8d53e5db0eb00d18c86882"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a12329911aa8d53e5db0eb00d18c86882">getShapeGrads</a> (Element *e, <a class="el" href="classapf_1_1Vector3.html">Vector3</a> const &amp;local, NewArray&lt; <a class="el" href="classapf_1_1Vector3.html">Vector3</a> &gt; &amp;grads)</td></tr>
<tr class="memdesc:a12329911aa8d53e5db0eb00d18c86882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the shape function gradients at a point.  <a href="namespaceapf.html#a12329911aa8d53e5db0eb00d18c86882">More...</a><br /></td></tr>
<tr class="separator:a12329911aa8d53e5db0eb00d18c86882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a0eda0e2d7d8943e38deac40e7ca168"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a7a0eda0e2d7d8943e38deac40e7ca168">getVectorShapeValues</a> (Element *e, <a class="el" href="classapf_1_1Vector3.html">Vector3</a> const &amp;local, NewArray&lt; <a class="el" href="classapf_1_1Vector3.html">Vector3</a> &gt; &amp;values)</td></tr>
<tr class="memdesc:a7a0eda0e2d7d8943e38deac40e7ca168"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the vector shape function values at a point.  <a href="namespaceapf.html#a7a0eda0e2d7d8943e38deac40e7ca168">More...</a><br /></td></tr>
<tr class="separator:a7a0eda0e2d7d8943e38deac40e7ca168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad139a15b35e66fec23d5c110789ccb45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#ad139a15b35e66fec23d5c110789ccb45">getCurlShapeValues</a> (Element *e, <a class="el" href="classapf_1_1Vector3.html">Vector3</a> const &amp;local, NewArray&lt; <a class="el" href="classapf_1_1Vector3.html">Vector3</a> &gt; &amp;values)</td></tr>
<tr class="memdesc:ad139a15b35e66fec23d5c110789ccb45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the vector curl shape function values at a point.  <a href="namespaceapf.html#ad139a15b35e66fec23d5c110789ccb45">More...</a><br /></td></tr>
<tr class="separator:ad139a15b35e66fec23d5c110789ccb45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80275d8bbf3c8aa3b5e5a798e7e2bd4"><td class="memItemLeft" align="right" valign="top"><a id="ab80275d8bbf3c8aa3b5e5a798e7e2bd4"></a>
<a class="el" href="classapf_1_1FieldShape.html">FieldShape</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#ab80275d8bbf3c8aa3b5e5a798e7e2bd4">getShape</a> (Field *f)</td></tr>
<tr class="memdesc:ab80275d8bbf3c8aa3b5e5a798e7e2bd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the <a class="el" href="classapf_1_1FieldShape.html" title="Describes field distribution and shape functions.">apf::FieldShape</a> used by a field. <br /></td></tr>
<tr class="separator:ab80275d8bbf3c8aa3b5e5a798e7e2bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bce38caf1b20620595d9d064a83e2ac"><td class="memItemLeft" align="right" valign="top"><a id="a0bce38caf1b20620595d9d064a83e2ac"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a0bce38caf1b20620595d9d064a83e2ac">countComponents</a> (Field *f)</td></tr>
<tr class="memdesc:a0bce38caf1b20620595d9d064a83e2ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of scalar components in the field's value type. <br /></td></tr>
<tr class="separator:a0bce38caf1b20620595d9d064a83e2ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac224e97b2c5827c9d8b3be218466e379"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#ac224e97b2c5827c9d8b3be218466e379">writeVtkFiles</a> (const char *prefix, <a class="el" href="classapf_1_1Mesh.html">Mesh</a> *m, int cellDim=-1)</td></tr>
<tr class="memdesc:ac224e97b2c5827c9d8b3be218466e379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a set of parallel VTK Unstructured <a class="el" href="classapf_1_1Mesh.html" title="Interface to a mesh part.">Mesh</a> files from an <a class="el" href="classapf_1_1Mesh.html" title="Interface to a mesh part.">apf::Mesh</a> with binary (base64) encoding and zlib compression (if LION_COMPRESS=ON)  <a href="namespaceapf.html#ac224e97b2c5827c9d8b3be218466e379">More...</a><br /></td></tr>
<tr class="separator:ac224e97b2c5827c9d8b3be218466e379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa549df4e77abc8f2900ff95cb34fe12e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#aa549df4e77abc8f2900ff95cb34fe12e">writeVtkFiles</a> (const char *prefix, <a class="el" href="classapf_1_1Mesh.html">Mesh</a> *m, std::vector&lt; std::string &gt; writeFields, int cellDim=-1)</td></tr>
<tr class="memdesc:aa549df4e77abc8f2900ff95cb34fe12e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a set of parallel VTK Unstructured <a class="el" href="classapf_1_1Mesh.html" title="Interface to a mesh part.">Mesh</a> files from an <a class="el" href="classapf_1_1Mesh.html" title="Interface to a mesh part.">apf::Mesh</a> with binary (base64) encoding and zlib compression (if LION_COMPRESS=ON)  <a href="namespaceapf.html#aa549df4e77abc8f2900ff95cb34fe12e">More...</a><br /></td></tr>
<tr class="separator:aa549df4e77abc8f2900ff95cb34fe12e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62142dfe765839a3c5493cb1f12caf7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a62142dfe765839a3c5493cb1f12caf7c">writeOneVtkFile</a> (const char *prefix, <a class="el" href="classapf_1_1Mesh.html">Mesh</a> *m)</td></tr>
<tr class="memdesc:a62142dfe765839a3c5493cb1f12caf7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output just the .vtu file with ASCII encoding for this part.  <a href="namespaceapf.html#a62142dfe765839a3c5493cb1f12caf7c">More...</a><br /></td></tr>
<tr class="separator:a62142dfe765839a3c5493cb1f12caf7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022623745e62596e3670032e550c2362"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a022623745e62596e3670032e550c2362">writeASCIIVtkFiles</a> (const char *prefix, <a class="el" href="classapf_1_1Mesh.html">Mesh</a> *m)</td></tr>
<tr class="memdesc:a022623745e62596e3670032e550c2362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a set of parallel VTK Unstructured <a class="el" href="classapf_1_1Mesh.html" title="Interface to a mesh part.">Mesh</a> files from an <a class="el" href="classapf_1_1Mesh.html" title="Interface to a mesh part.">apf::Mesh</a> with ASCII encoding.  <a href="namespaceapf.html#a022623745e62596e3670032e550c2362">More...</a><br /></td></tr>
<tr class="separator:a022623745e62596e3670032e550c2362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fed5ae41533bb1ae81c03a4422e6d54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a0fed5ae41533bb1ae81c03a4422e6d54">writeASCIIVtkFiles</a> (const char *prefix, <a class="el" href="classapf_1_1Mesh.html">Mesh</a> *m, std::vector&lt; std::string &gt; writeFields)</td></tr>
<tr class="memdesc:a0fed5ae41533bb1ae81c03a4422e6d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a set of parallel VTK Unstructured <a class="el" href="classapf_1_1Mesh.html" title="Interface to a mesh part.">Mesh</a> files from an <a class="el" href="classapf_1_1Mesh.html" title="Interface to a mesh part.">apf::Mesh</a> with ASCII encoding.  <a href="namespaceapf.html#a0fed5ae41533bb1ae81c03a4422e6d54">More...</a><br /></td></tr>
<tr class="separator:a0fed5ae41533bb1ae81c03a4422e6d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad7c9deb4ebfe9510973ed3c568ac7ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#aad7c9deb4ebfe9510973ed3c568ac7ec">writeNedelecVtkFiles</a> (const char *prefix, <a class="el" href="classapf_1_1Mesh.html">Mesh</a> *m)</td></tr>
<tr class="memdesc:aad7c9deb4ebfe9510973ed3c568ac7ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output .vtk files with ASCII encoding for this part.  <a href="namespaceapf.html#aad7c9deb4ebfe9510973ed3c568ac7ec">More...</a><br /></td></tr>
<tr class="separator:aad7c9deb4ebfe9510973ed3c568ac7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2f5179943d09291029e91ecdbed6d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a3c2f5179943d09291029e91ecdbed6d5">getGaussPoint</a> (int type, int order, int point, <a class="el" href="classapf_1_1Vector3.html">Vector3</a> &amp;param)</td></tr>
<tr class="memdesc:a3c2f5179943d09291029e91ecdbed6d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the location of a gaussian integration point.  <a href="namespaceapf.html#a3c2f5179943d09291029e91ecdbed6d5">More...</a><br /></td></tr>
<tr class="separator:a3c2f5179943d09291029e91ecdbed6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac18fd2a04daf44ce29f22e64f3897e"><td class="memItemLeft" align="right" valign="top"><a id="a2ac18fd2a04daf44ce29f22e64f3897e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a2ac18fd2a04daf44ce29f22e64f3897e">countGaussPoints</a> (int type, int order)</td></tr>
<tr class="memdesc:a2ac18fd2a04daf44ce29f22e64f3897e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of Gaussian integration points. <br /></td></tr>
<tr class="separator:a2ac18fd2a04daf44ce29f22e64f3897e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53933a5e18058aafd842e6ecb75d5759"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a53933a5e18058aafd842e6ecb75d5759">getJacobianDeterminant</a> (<a class="el" href="classapf_1_1Matrix3x3.html">Matrix3x3</a> const &amp;J, int dimension)</td></tr>
<tr class="memdesc:a53933a5e18058aafd842e6ecb75d5759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Jacobian determinant or dimensional equivalent.  <a href="namespaceapf.html#a53933a5e18058aafd842e6ecb75d5759">More...</a><br /></td></tr>
<tr class="separator:a53933a5e18058aafd842e6ecb75d5759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ca6d66a7a88ecb49500f51cca821d50"><td class="memItemLeft" align="right" valign="top"><a id="a2ca6d66a7a88ecb49500f51cca821d50"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a2ca6d66a7a88ecb49500f51cca821d50">getDimension</a> (<a class="el" href="namespaceapf.html#a2432d4261391eda474007fb25c097a5c">MeshElement</a> *me)</td></tr>
<tr class="memdesc:a2ca6d66a7a88ecb49500f51cca821d50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the dimension of a MeshElement's MeshEntity. <br /></td></tr>
<tr class="separator:a2ca6d66a7a88ecb49500f51cca821d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a654c12ae2c4f2b04312999665d9530e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a654c12ae2c4f2b04312999665d9530e3">synchronize</a> (Field *f, <a class="el" href="structapf_1_1Sharing.html">Sharing</a> *shr=0)</td></tr>
<tr class="memdesc:a654c12ae2c4f2b04312999665d9530e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronize field values along partition boundary.  <a href="namespaceapf.html#a654c12ae2c4f2b04312999665d9530e3">More...</a><br /></td></tr>
<tr class="separator:a654c12ae2c4f2b04312999665d9530e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3589c872e3d40b311a323832d506504"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#ad3589c872e3d40b311a323832d506504">accumulate</a> (Field *f, <a class="el" href="structapf_1_1Sharing.html">Sharing</a> *shr=0, bool delete_shr=false)</td></tr>
<tr class="memdesc:ad3589c872e3d40b311a323832d506504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add field values along partition boundary.  <a href="namespaceapf.html#ad3589c872e3d40b311a323832d506504">More...</a><br /></td></tr>
<tr class="separator:ad3589c872e3d40b311a323832d506504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d6feacdf3007409aa31960fd2ff037f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a2d6feacdf3007409aa31960fd2ff037f">sharedReduction</a> (Field *f, <a class="el" href="structapf_1_1Sharing.html">Sharing</a> *shr, bool delete_shr, const <a class="el" href="classapf_1_1ReductionOp.html">ReductionOp</a>&lt; double &gt; &amp;sum=ReductionSum&lt; double &gt;())</td></tr>
<tr class="memdesc:a2d6feacdf3007409aa31960fd2ff037f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a reudction operator along partition boundaries.  <a href="namespaceapf.html#a2d6feacdf3007409aa31960fd2ff037f">More...</a><br /></td></tr>
<tr class="separator:a2d6feacdf3007409aa31960fd2ff037f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5abcdd24193fa472bc1d4a6a334c8f12"><td class="memItemLeft" align="right" valign="top"><a id="a5abcdd24193fa472bc1d4a6a334c8f12"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a5abcdd24193fa472bc1d4a6a334c8f12">isPrintable</a> (Field *f)</td></tr>
<tr class="memdesc:a5abcdd24193fa472bc1d4a6a334c8f12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a Field/Numbering/GlobalNumbering is complete and therefore printable to visualization files. This is a collective operation. <br /></td></tr>
<tr class="separator:a5abcdd24193fa472bc1d4a6a334c8f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e25204d8a3b5dfe0c240afee898c93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a52e25204d8a3b5dfe0c240afee898c93">fail</a> (const char *why) __attribute__((noreturn))</td></tr>
<tr class="memdesc:a52e25204d8a3b5dfe0c240afee898c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare failure of code inside APF.  <a href="namespaceapf.html#a52e25204d8a3b5dfe0c240afee898c93">More...</a><br /></td></tr>
<tr class="separator:a52e25204d8a3b5dfe0c240afee898c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426080089c4f3b1aefa8429a5c20cbbe"><td class="memItemLeft" align="right" valign="top"><a id="a426080089c4f3b1aefa8429a5c20cbbe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a426080089c4f3b1aefa8429a5c20cbbe">freeze</a> (Field *f)</td></tr>
<tr class="memdesc:a426080089c4f3b1aefa8429a5c20cbbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a Field from Tag to array storage. <br /></td></tr>
<tr class="separator:a426080089c4f3b1aefa8429a5c20cbbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65fdc7e521b047fbae0f80d42589dd51"><td class="memItemLeft" align="right" valign="top"><a id="a65fdc7e521b047fbae0f80d42589dd51"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a65fdc7e521b047fbae0f80d42589dd51">unfreeze</a> (Field *f)</td></tr>
<tr class="memdesc:a65fdc7e521b047fbae0f80d42589dd51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a Field from array to Tag storage. <br /></td></tr>
<tr class="separator:a65fdc7e521b047fbae0f80d42589dd51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff7f9dd09ed235feecd3372b1dc0be0e"><td class="memItemLeft" align="right" valign="top"><a id="aff7f9dd09ed235feecd3372b1dc0be0e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#aff7f9dd09ed235feecd3372b1dc0be0e">isFrozen</a> (Field *f)</td></tr>
<tr class="memdesc:aff7f9dd09ed235feecd3372b1dc0be0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the Field uses array storage. <br /></td></tr>
<tr class="separator:aff7f9dd09ed235feecd3372b1dc0be0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e9d9ae4647ae4737de0b05368b7ffe"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a45e9d9ae4647ae4737de0b05368b7ffe">getArrayData</a> (Field *f)</td></tr>
<tr class="memdesc:a45e9d9ae4647ae4737de0b05368b7ffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the contiguous array storing this field.  <a href="namespaceapf.html#a45e9d9ae4647ae4737de0b05368b7ffe">More...</a><br /></td></tr>
<tr class="separator:a45e9d9ae4647ae4737de0b05368b7ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4673fcc229448f1ce6be39e12daaad6c"><td class="memItemLeft" align="right" valign="top"><a id="a4673fcc229448f1ce6be39e12daaad6c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a4673fcc229448f1ce6be39e12daaad6c">zeroField</a> (Field *f)</td></tr>
<tr class="memdesc:a4673fcc229448f1ce6be39e12daaad6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize all nodal values with all-zero components. <br /></td></tr>
<tr class="separator:a4673fcc229448f1ce6be39e12daaad6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae44b6579152d6c9bf8cf994a1aef1fb4"><td class="memItemLeft" align="right" valign="top">Field *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#ae44b6579152d6c9bf8cf994a1aef1fb4">recoverGradientByVolume</a> (Field *f)</td></tr>
<tr class="memdesc:ae44b6579152d6c9bf8cf994a1aef1fb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a nodal gradient field from a nodal input field.  <a href="namespaceapf.html#ae44b6579152d6c9bf8cf994a1aef1fb4">More...</a><br /></td></tr>
<tr class="separator:ae44b6579152d6c9bf8cf994a1aef1fb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5c4b036bd59124ee10502529f1e646"><td class="memItemLeft" align="right" valign="top"><a id="a3c5c4b036bd59124ee10502529f1e646"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a3c5c4b036bd59124ee10502529f1e646">projectField</a> (Field *to, Field *from)</td></tr>
<tr class="memdesc:a3c5c4b036bd59124ee10502529f1e646"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project a field from an existing field. <br /></td></tr>
<tr class="separator:a3c5c4b036bd59124ee10502529f1e646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0d6ff54687a13a7a3e54e9885697ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#afa0d6ff54687a13a7a3e54e9885697ea">getBF</a> (<a class="el" href="classapf_1_1FieldShape.html">FieldShape</a> *s, <a class="el" href="namespaceapf.html#a2432d4261391eda474007fb25c097a5c">MeshElement</a> *e, <a class="el" href="classapf_1_1Vector3.html">Vector3</a> const &amp;p, NewArray&lt; double &gt; &amp;BF)</td></tr>
<tr class="memdesc:afa0d6ff54687a13a7a3e54e9885697ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the basis functions over a mesh element.  <a href="namespaceapf.html#afa0d6ff54687a13a7a3e54e9885697ea">More...</a><br /></td></tr>
<tr class="separator:afa0d6ff54687a13a7a3e54e9885697ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4edc5bad16354c92a63f8d275cc0bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a1e4edc5bad16354c92a63f8d275cc0bb">getGradBF</a> (<a class="el" href="classapf_1_1FieldShape.html">FieldShape</a> *s, <a class="el" href="namespaceapf.html#a2432d4261391eda474007fb25c097a5c">MeshElement</a> *e, <a class="el" href="classapf_1_1Vector3.html">Vector3</a> const &amp;p, NewArray&lt; <a class="el" href="classapf_1_1Vector3.html">Vector3</a> &gt; &amp;gradBF)</td></tr>
<tr class="memdesc:a1e4edc5bad16354c92a63f8d275cc0bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get global gradients of basis functions over a mesh element.  <a href="namespaceapf.html#a1e4edc5bad16354c92a63f8d275cc0bb">More...</a><br /></td></tr>
<tr class="separator:a1e4edc5bad16354c92a63f8d275cc0bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55068a766b0d6e1c63432c621af73bca"><td class="memItemLeft" align="right" valign="top"><a id="a55068a766b0d6e1c63432c621af73bca"></a>
<a class="el" href="namespaceapf.html#a662a796b32a9173981bfc6e1ebe60ba1">Numbering</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a55068a766b0d6e1c63432c621af73bca">createNumbering</a> (Field *f)</td></tr>
<tr class="memdesc:a55068a766b0d6e1c63432c621af73bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a Numbering of degrees of freedom of a Field. <br /></td></tr>
<tr class="separator:a55068a766b0d6e1c63432c621af73bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a587984a40675f8c24d83dd4462a89023"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceapf.html#a662a796b32a9173981bfc6e1ebe60ba1">Numbering</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a587984a40675f8c24d83dd4462a89023">createNumbering</a> (<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *mesh, const char *name, <a class="el" href="classapf_1_1FieldShape.html">FieldShape</a> *shape, int components)</td></tr>
<tr class="memdesc:a587984a40675f8c24d83dd4462a89023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a generally-defined Numbering.  <a href="namespaceapf.html#a587984a40675f8c24d83dd4462a89023">More...</a><br /></td></tr>
<tr class="separator:a587984a40675f8c24d83dd4462a89023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14dc8db7fa93ea3b62c5a788cb05a205"><td class="memItemLeft" align="right" valign="top"><a id="a14dc8db7fa93ea3b62c5a788cb05a205"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a14dc8db7fa93ea3b62c5a788cb05a205">destroyNumbering</a> (<a class="el" href="namespaceapf.html#a662a796b32a9173981bfc6e1ebe60ba1">Numbering</a> *n)</td></tr>
<tr class="memdesc:a14dc8db7fa93ea3b62c5a788cb05a205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a Numbering. <br /></td></tr>
<tr class="separator:a14dc8db7fa93ea3b62c5a788cb05a205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b2bad33dc710bf0713c236478d5696"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a46b2bad33dc710bf0713c236478d5696">fix</a> (<a class="el" href="namespaceapf.html#a662a796b32a9173981bfc6e1ebe60ba1">Numbering</a> *n, MeshEntity *e, int node, int component, bool fixed)</td></tr>
<tr class="memdesc:a46b2bad33dc710bf0713c236478d5696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the fixed/free status of a degree of freedom,.  <a href="namespaceapf.html#a46b2bad33dc710bf0713c236478d5696">More...</a><br /></td></tr>
<tr class="separator:a46b2bad33dc710bf0713c236478d5696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7701171312e7a66287b45237c1505ba0"><td class="memItemLeft" align="right" valign="top"><a id="a7701171312e7a66287b45237c1505ba0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a7701171312e7a66287b45237c1505ba0">isFixed</a> (<a class="el" href="namespaceapf.html#a662a796b32a9173981bfc6e1ebe60ba1">Numbering</a> *n, MeshEntity *e, int node, int component)</td></tr>
<tr class="memdesc:a7701171312e7a66287b45237c1505ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a degree of freedom is fixed. <br /></td></tr>
<tr class="separator:a7701171312e7a66287b45237c1505ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada513ae752940d3b8e282e3511a361d4"><td class="memItemLeft" align="right" valign="top"><a id="ada513ae752940d3b8e282e3511a361d4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#ada513ae752940d3b8e282e3511a361d4">isNumbered</a> (<a class="el" href="namespaceapf.html#a662a796b32a9173981bfc6e1ebe60ba1">Numbering</a> *n, MeshEntity *e, int node, int component)</td></tr>
<tr class="memdesc:ada513ae752940d3b8e282e3511a361d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a degree of freedom is numbered. <br /></td></tr>
<tr class="separator:ada513ae752940d3b8e282e3511a361d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a8fafe58c4c2ec60a572692ffbaa1fd"><td class="memItemLeft" align="right" valign="top"><a id="a3a8fafe58c4c2ec60a572692ffbaa1fd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a3a8fafe58c4c2ec60a572692ffbaa1fd">number</a> (<a class="el" href="namespaceapf.html#a662a796b32a9173981bfc6e1ebe60ba1">Numbering</a> *n, MeshEntity *e, int node, int component, int number)</td></tr>
<tr class="memdesc:a3a8fafe58c4c2ec60a572692ffbaa1fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">number a degree of freedom <br /></td></tr>
<tr class="separator:a3a8fafe58c4c2ec60a572692ffbaa1fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae992e0e27c054c1bb1c9d618ac9c47bd"><td class="memItemLeft" align="right" valign="top"><a id="ae992e0e27c054c1bb1c9d618ac9c47bd"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#ae992e0e27c054c1bb1c9d618ac9c47bd">getNumber</a> (<a class="el" href="namespaceapf.html#a662a796b32a9173981bfc6e1ebe60ba1">Numbering</a> *n, MeshEntity *e, int node, int component)</td></tr>
<tr class="memdesc:ae992e0e27c054c1bb1c9d618ac9c47bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a degree of freedom number <br /></td></tr>
<tr class="separator:ae992e0e27c054c1bb1c9d618ac9c47bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affda2acc4595b586f8435671753504eb"><td class="memItemLeft" align="right" valign="top"><a id="affda2acc4595b586f8435671753504eb"></a>
Field *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#affda2acc4595b586f8435671753504eb">getField</a> (<a class="el" href="namespaceapf.html#a662a796b32a9173981bfc6e1ebe60ba1">Numbering</a> *n)</td></tr>
<tr class="memdesc:affda2acc4595b586f8435671753504eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the field being numbered <br /></td></tr>
<tr class="separator:affda2acc4595b586f8435671753504eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e3a94de0102cb3b3e215552e1fae578"><td class="memItemLeft" align="right" valign="top"><a id="a3e3a94de0102cb3b3e215552e1fae578"></a>
<a class="el" href="classapf_1_1FieldShape.html">FieldShape</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a3e3a94de0102cb3b3e215552e1fae578">getShape</a> (<a class="el" href="namespaceapf.html#a662a796b32a9173981bfc6e1ebe60ba1">Numbering</a> *n)</td></tr>
<tr class="memdesc:a3e3a94de0102cb3b3e215552e1fae578"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the <a class="el" href="classapf_1_1FieldShape.html" title="Describes field distribution and shape functions.">FieldShape</a> used by a Numbering <br /></td></tr>
<tr class="separator:a3e3a94de0102cb3b3e215552e1fae578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb3837ed3a51c2364bf72cf4b90bbbd"><td class="memItemLeft" align="right" valign="top"><a id="a7eb3837ed3a51c2364bf72cf4b90bbbd"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a7eb3837ed3a51c2364bf72cf4b90bbbd">getName</a> (<a class="el" href="namespaceapf.html#a662a796b32a9173981bfc6e1ebe60ba1">Numbering</a> *n)</td></tr>
<tr class="memdesc:a7eb3837ed3a51c2364bf72cf4b90bbbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the name of a Numbering <br /></td></tr>
<tr class="separator:a7eb3837ed3a51c2364bf72cf4b90bbbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4253b723c708421cc3cb048aba82f8"><td class="memItemLeft" align="right" valign="top"><a id="afb4253b723c708421cc3cb048aba82f8"></a>
<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#afb4253b723c708421cc3cb048aba82f8">getMesh</a> (<a class="el" href="namespaceapf.html#a662a796b32a9173981bfc6e1ebe60ba1">Numbering</a> *n)</td></tr>
<tr class="memdesc:afb4253b723c708421cc3cb048aba82f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the mesh associated with a Numbering <br /></td></tr>
<tr class="separator:afb4253b723c708421cc3cb048aba82f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58876c2d1a1f92d6ce3b46c4c0ba8583"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a58876c2d1a1f92d6ce3b46c4c0ba8583">getElementNumbers</a> (<a class="el" href="namespaceapf.html#a662a796b32a9173981bfc6e1ebe60ba1">Numbering</a> *n, MeshEntity *e, NewArray&lt; int &gt; &amp;numbers)</td></tr>
<tr class="memdesc:a58876c2d1a1f92d6ce3b46c4c0ba8583"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the node numbers of an element  <a href="namespaceapf.html#a58876c2d1a1f92d6ce3b46c4c0ba8583">More...</a><br /></td></tr>
<tr class="separator:a58876c2d1a1f92d6ce3b46c4c0ba8583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26c280ed2d860c1eb5c70e4ef5e84130"><td class="memItemLeft" align="right" valign="top"><a id="a26c280ed2d860c1eb5c70e4ef5e84130"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a26c280ed2d860c1eb5c70e4ef5e84130">countFixed</a> (<a class="el" href="namespaceapf.html#a662a796b32a9173981bfc6e1ebe60ba1">Numbering</a> *n)</td></tr>
<tr class="memdesc:a26c280ed2d860c1eb5c70e4ef5e84130"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the number of fixed degrees of freedom <br /></td></tr>
<tr class="separator:a26c280ed2d860c1eb5c70e4ef5e84130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2242ed13e21887a766f0d8ccfc34571"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#ac2242ed13e21887a766f0d8ccfc34571">synchronize</a> (<a class="el" href="namespaceapf.html#a662a796b32a9173981bfc6e1ebe60ba1">Numbering</a> *n, <a class="el" href="structapf_1_1Sharing.html">Sharing</a> *shr=0, bool delete_shr=false)</td></tr>
<tr class="memdesc:ac2242ed13e21887a766f0d8ccfc34571"><td class="mdescLeft">&#160;</td><td class="mdescRight">numbers non-owned nodes with the values from their owners  <a href="namespaceapf.html#ac2242ed13e21887a766f0d8ccfc34571">More...</a><br /></td></tr>
<tr class="separator:ac2242ed13e21887a766f0d8ccfc34571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fba2d8ca52b7858ffffdac07372b3dc"><td class="memItemLeft" align="right" valign="top"><a id="a8fba2d8ca52b7858ffffdac07372b3dc"></a>
<a class="el" href="namespaceapf.html#a662a796b32a9173981bfc6e1ebe60ba1">Numbering</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a8fba2d8ca52b7858ffffdac07372b3dc">numberOwnedDimension</a> (<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *mesh, const char *name, int dim, <a class="el" href="structapf_1_1Sharing.html">Sharing</a> *shr=0)</td></tr>
<tr class="memdesc:a8fba2d8ca52b7858ffffdac07372b3dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">number the local owned entities of a given dimension <br /></td></tr>
<tr class="separator:a8fba2d8ca52b7858ffffdac07372b3dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33930b542f5e628f255c4dd530c99327"><td class="memItemLeft" align="right" valign="top"><a id="a33930b542f5e628f255c4dd530c99327"></a>
<a class="el" href="namespaceapf.html#a662a796b32a9173981bfc6e1ebe60ba1">Numbering</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a33930b542f5e628f255c4dd530c99327">numberOverlapDimension</a> (<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *mesh, const char *name, int dim)</td></tr>
<tr class="memdesc:a33930b542f5e628f255c4dd530c99327"><td class="mdescLeft">&#160;</td><td class="mdescRight">number all local entities of a given dimension <br /></td></tr>
<tr class="separator:a33930b542f5e628f255c4dd530c99327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a10e4714db232f97b8e1e60002bcc4"><td class="memItemLeft" align="right" valign="top"><a id="a22a10e4714db232f97b8e1e60002bcc4"></a>
<a class="el" href="namespaceapf.html#a662a796b32a9173981bfc6e1ebe60ba1">Numbering</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a22a10e4714db232f97b8e1e60002bcc4">numberElements</a> (<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *mesh, const char *name)</td></tr>
<tr class="memdesc:a22a10e4714db232f97b8e1e60002bcc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">number the local elements <br /></td></tr>
<tr class="separator:a22a10e4714db232f97b8e1e60002bcc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731461d2b82dd5a3298466daea7378a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceapf.html#a662a796b32a9173981bfc6e1ebe60ba1">Numbering</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a731461d2b82dd5a3298466daea7378a1">numberOverlapNodes</a> (<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *mesh, const char *name, <a class="el" href="classapf_1_1FieldShape.html">FieldShape</a> *s=0)</td></tr>
<tr class="memdesc:a731461d2b82dd5a3298466daea7378a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">number all local nodes  <a href="namespaceapf.html#a731461d2b82dd5a3298466daea7378a1">More...</a><br /></td></tr>
<tr class="separator:a731461d2b82dd5a3298466daea7378a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade73c5914c4ce70310c7a92b4f99e837"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceapf.html#a662a796b32a9173981bfc6e1ebe60ba1">Numbering</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#ade73c5914c4ce70310c7a92b4f99e837">numberOwnedNodes</a> (<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *mesh, const char *name, <a class="el" href="classapf_1_1FieldShape.html">FieldShape</a> *s=0, <a class="el" href="structapf_1_1Sharing.html">Sharing</a> *shr=0)</td></tr>
<tr class="memdesc:ade73c5914c4ce70310c7a92b4f99e837"><td class="mdescLeft">&#160;</td><td class="mdescRight">number the local owned nodes  <a href="namespaceapf.html#ade73c5914c4ce70310c7a92b4f99e837">More...</a><br /></td></tr>
<tr class="separator:ade73c5914c4ce70310c7a92b4f99e837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa83bbf7bef4a7d19f9c0f1bbf832c99f"><td class="memItemLeft" align="right" valign="top"><a id="aa83bbf7bef4a7d19f9c0f1bbf832c99f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#aa83bbf7bef4a7d19f9c0f1bbf832c99f">countNodes</a> (<a class="el" href="namespaceapf.html#a662a796b32a9173981bfc6e1ebe60ba1">Numbering</a> *n)</td></tr>
<tr class="memdesc:aa83bbf7bef4a7d19f9c0f1bbf832c99f"><td class="mdescLeft">&#160;</td><td class="mdescRight">count the number of nodes that have been numbered <br /></td></tr>
<tr class="separator:aa83bbf7bef4a7d19f9c0f1bbf832c99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b7f4e66b2310574df6d62f915bbc84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a93b7f4e66b2310574df6d62f915bbc84">getNodes</a> (<a class="el" href="namespaceapf.html#a662a796b32a9173981bfc6e1ebe60ba1">Numbering</a> *n, DynamicArray&lt; <a class="el" href="structapf_1_1Node.html">Node</a> &gt; &amp;nodes)</td></tr>
<tr class="memdesc:a93b7f4e66b2310574df6d62f915bbc84"><td class="mdescLeft">&#160;</td><td class="mdescRight">get an array of numbered nodes  <a href="namespaceapf.html#a93b7f4e66b2310574df6d62f915bbc84">More...</a><br /></td></tr>
<tr class="separator:a93b7f4e66b2310574df6d62f915bbc84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18897db6d81708aa09febf8625effb40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a18897db6d81708aa09febf8625effb40">getNodesOnClosure</a> (<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *m, ModelEntity *me, DynamicArray&lt; <a class="el" href="structapf_1_1Node.html">Node</a> &gt; &amp;on, <a class="el" href="classapf_1_1FieldShape.html">FieldShape</a> *sh=0)</td></tr>
<tr class="memdesc:a18897db6d81708aa09febf8625effb40"><td class="mdescLeft">&#160;</td><td class="mdescRight">get nodes on the closure of a model entity  <a href="namespaceapf.html#a18897db6d81708aa09febf8625effb40">More...</a><br /></td></tr>
<tr class="separator:a18897db6d81708aa09febf8625effb40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f1b3e0b0e1d3a287c98b062a66b54d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceapf.html#a691865cc4ddfa6781e8aba4e338617e8">GlobalNumbering</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a47f1b3e0b0e1d3a287c98b062a66b54d">createGlobalNumbering</a> (<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *mesh, const char *name, <a class="el" href="classapf_1_1FieldShape.html">FieldShape</a> *shape, int components=1)</td></tr>
<tr class="memdesc:a47f1b3e0b0e1d3a287c98b062a66b54d"><td class="mdescLeft">&#160;</td><td class="mdescRight">create global numbering  <a href="namespaceapf.html#a47f1b3e0b0e1d3a287c98b062a66b54d">More...</a><br /></td></tr>
<tr class="separator:a47f1b3e0b0e1d3a287c98b062a66b54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9317346954db3e5b5f3e1d378c20d9d7"><td class="memItemLeft" align="right" valign="top"><a id="a9317346954db3e5b5f3e1d378c20d9d7"></a>
<a class="el" href="namespaceapf.html#a691865cc4ddfa6781e8aba4e338617e8">GlobalNumbering</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a9317346954db3e5b5f3e1d378c20d9d7">createGlobalNumbering</a> (Field *f)</td></tr>
<tr class="memdesc:a9317346954db3e5b5f3e1d378c20d9d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a Numbering of degrees of freedom of a Field. <br /></td></tr>
<tr class="separator:a9317346954db3e5b5f3e1d378c20d9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb0b811843ae4fd6a6642cab2980f00"><td class="memItemLeft" align="right" valign="top"><a id="a5eb0b811843ae4fd6a6642cab2980f00"></a>
<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a5eb0b811843ae4fd6a6642cab2980f00">getMesh</a> (<a class="el" href="namespaceapf.html#a691865cc4ddfa6781e8aba4e338617e8">GlobalNumbering</a> *n)</td></tr>
<tr class="memdesc:a5eb0b811843ae4fd6a6642cab2980f00"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the mesh associated with a global numbering <br /></td></tr>
<tr class="separator:a5eb0b811843ae4fd6a6642cab2980f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f8aa6766c610218d48ad66e8ecf7118"><td class="memItemLeft" align="right" valign="top"><a id="a6f8aa6766c610218d48ad66e8ecf7118"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a6f8aa6766c610218d48ad66e8ecf7118">countComponents</a> (<a class="el" href="namespaceapf.html#a691865cc4ddfa6781e8aba4e338617e8">GlobalNumbering</a> *n)</td></tr>
<tr class="memdesc:a6f8aa6766c610218d48ad66e8ecf7118"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the components associated with a global numbering <br /></td></tr>
<tr class="separator:a6f8aa6766c610218d48ad66e8ecf7118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf826c186da4bb88bd568b1c7b12568c"><td class="memItemLeft" align="right" valign="top"><a id="aaf826c186da4bb88bd568b1c7b12568c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#aaf826c186da4bb88bd568b1c7b12568c">number</a> (<a class="el" href="namespaceapf.html#a691865cc4ddfa6781e8aba4e338617e8">GlobalNumbering</a> *n, MeshEntity *e, int node, long number)</td></tr>
<tr class="memdesc:aaf826c186da4bb88bd568b1c7b12568c"><td class="mdescLeft">&#160;</td><td class="mdescRight">assign a global number <br /></td></tr>
<tr class="separator:aaf826c186da4bb88bd568b1c7b12568c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbfc951f7d8bbde1ecd6e5c4502f46a0"><td class="memItemLeft" align="right" valign="top"><a id="afbfc951f7d8bbde1ecd6e5c4502f46a0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#afbfc951f7d8bbde1ecd6e5c4502f46a0">number</a> (<a class="el" href="namespaceapf.html#a691865cc4ddfa6781e8aba4e338617e8">GlobalNumbering</a> *n, <a class="el" href="structapf_1_1Node.html">Node</a> node, long number, int component=0)</td></tr>
<tr class="memdesc:afbfc951f7d8bbde1ecd6e5c4502f46a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">assign a global number <br /></td></tr>
<tr class="separator:afbfc951f7d8bbde1ecd6e5c4502f46a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe2b75e952d1c949728c828ecd53d3b"><td class="memItemLeft" align="right" valign="top"><a id="a1fe2b75e952d1c949728c828ecd53d3b"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a1fe2b75e952d1c949728c828ecd53d3b">getNumber</a> (<a class="el" href="namespaceapf.html#a691865cc4ddfa6781e8aba4e338617e8">GlobalNumbering</a> *n, <a class="el" href="structapf_1_1Node.html">Node</a> node, int component=0)</td></tr>
<tr class="memdesc:a1fe2b75e952d1c949728c828ecd53d3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a global number <br /></td></tr>
<tr class="separator:a1fe2b75e952d1c949728c828ecd53d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca13cc927038201ff20b5dcb293c630b"><td class="memItemLeft" align="right" valign="top"><a id="aca13cc927038201ff20b5dcb293c630b"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#aca13cc927038201ff20b5dcb293c630b">getNumber</a> (<a class="el" href="namespaceapf.html#a691865cc4ddfa6781e8aba4e338617e8">GlobalNumbering</a> *n, MeshEntity *e, int node, int component=0)</td></tr>
<tr class="memdesc:aca13cc927038201ff20b5dcb293c630b"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a global number <br /></td></tr>
<tr class="separator:aca13cc927038201ff20b5dcb293c630b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e1325efa26cf808845bb4fa8fbba6f"><td class="memItemLeft" align="right" valign="top"><a id="ac4e1325efa26cf808845bb4fa8fbba6f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#ac4e1325efa26cf808845bb4fa8fbba6f">getElementNumbers</a> (<a class="el" href="namespaceapf.html#a691865cc4ddfa6781e8aba4e338617e8">GlobalNumbering</a> *n, MeshEntity *e, NewArray&lt; long &gt; &amp;numbers)</td></tr>
<tr class="memdesc:ac4e1325efa26cf808845bb4fa8fbba6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">get an element's global node numbers <br /></td></tr>
<tr class="separator:ac4e1325efa26cf808845bb4fa8fbba6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff13080b70ad28e966e24edc22001f2"><td class="memItemLeft" align="right" valign="top"><a id="afff13080b70ad28e966e24edc22001f2"></a>
Field *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#afff13080b70ad28e966e24edc22001f2">getField</a> (<a class="el" href="namespaceapf.html#a691865cc4ddfa6781e8aba4e338617e8">GlobalNumbering</a> *n)</td></tr>
<tr class="memdesc:afff13080b70ad28e966e24edc22001f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the field being numbered <br /></td></tr>
<tr class="separator:afff13080b70ad28e966e24edc22001f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f0844e05ef6ed735ebb0784c761ee8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceapf.html#a691865cc4ddfa6781e8aba4e338617e8">GlobalNumbering</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a96f0844e05ef6ed735ebb0784c761ee8">makeGlobal</a> (<a class="el" href="namespaceapf.html#a662a796b32a9173981bfc6e1ebe60ba1">Numbering</a> *n, bool destroy=true)</td></tr>
<tr class="memdesc:a96f0844e05ef6ed735ebb0784c761ee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts a local numbering into a global numbering.  <a href="namespaceapf.html#a96f0844e05ef6ed735ebb0784c761ee8">More...</a><br /></td></tr>
<tr class="separator:a96f0844e05ef6ed735ebb0784c761ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34fc3e4f81c7311922627972ee24a12"><td class="memItemLeft" align="right" valign="top"><a id="ae34fc3e4f81c7311922627972ee24a12"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#ae34fc3e4f81c7311922627972ee24a12">synchronize</a> (<a class="el" href="namespaceapf.html#a691865cc4ddfa6781e8aba4e338617e8">GlobalNumbering</a> *n, <a class="el" href="structapf_1_1Sharing.html">Sharing</a> *shr=0)</td></tr>
<tr class="memdesc:ae34fc3e4f81c7311922627972ee24a12"><td class="mdescLeft">&#160;</td><td class="mdescRight">see the Numbering equivalent and <a class="el" href="namespaceapf.html#a96f0844e05ef6ed735ebb0784c761ee8" title="converts a local numbering into a global numbering.">apf::makeGlobal</a> <br /></td></tr>
<tr class="separator:ae34fc3e4f81c7311922627972ee24a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5236154e521e2f4e4b31dcebea3e3c91"><td class="memItemLeft" align="right" valign="top"><a id="a5236154e521e2f4e4b31dcebea3e3c91"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a5236154e521e2f4e4b31dcebea3e3c91">destroyGlobalNumbering</a> (<a class="el" href="namespaceapf.html#a691865cc4ddfa6781e8aba4e338617e8">GlobalNumbering</a> *n)</td></tr>
<tr class="memdesc:a5236154e521e2f4e4b31dcebea3e3c91"><td class="mdescLeft">&#160;</td><td class="mdescRight">destroy a global numbering <br /></td></tr>
<tr class="separator:a5236154e521e2f4e4b31dcebea3e3c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad9401b6bd1c03b8adabebb280fe29c"><td class="memItemLeft" align="right" valign="top"><a id="aaad9401b6bd1c03b8adabebb280fe29c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#aaad9401b6bd1c03b8adabebb280fe29c">getNodes</a> (<a class="el" href="namespaceapf.html#a691865cc4ddfa6781e8aba4e338617e8">GlobalNumbering</a> *n, DynamicArray&lt; <a class="el" href="structapf_1_1Node.html">Node</a> &gt; &amp;nodes)</td></tr>
<tr class="memdesc:aaad9401b6bd1c03b8adabebb280fe29c"><td class="mdescLeft">&#160;</td><td class="mdescRight">see the Numbering equivalent <br /></td></tr>
<tr class="separator:aaad9401b6bd1c03b8adabebb280fe29c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49da9cc521228907c81c74158b0eb265"><td class="memItemLeft" align="right" valign="top">MeshTag *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a49da9cc521228907c81c74158b0eb265">reorder</a> (<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *mesh, const char *name)</td></tr>
<tr class="memdesc:a49da9cc521228907c81c74158b0eb265"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number by adjacency graph traversal.  <a href="namespaceapf.html#a49da9cc521228907c81c74158b0eb265">More...</a><br /></td></tr>
<tr class="separator:a49da9cc521228907c81c74158b0eb265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b00e79aa070682a9b3ed74301ada196"><td class="memItemLeft" align="right" valign="top"><a id="a7b00e79aa070682a9b3ed74301ada196"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a7b00e79aa070682a9b3ed74301ada196">naiveOrder</a> (<a class="el" href="namespaceapf.html#a662a796b32a9173981bfc6e1ebe60ba1">Numbering</a> *num, <a class="el" href="structapf_1_1Sharing.html">Sharing</a> *sharing=NULL)</td></tr>
<tr class="memdesc:a7b00e79aa070682a9b3ed74301ada196"><td class="mdescLeft">&#160;</td><td class="mdescRight">number all components by simple iteration <br /></td></tr>
<tr class="separator:a7b00e79aa070682a9b3ed74301ada196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d710fb72e69e54c182173cc917c1d6"><td class="memItemLeft" align="right" valign="top"><a id="a58d710fb72e69e54c182173cc917c1d6"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a58d710fb72e69e54c182173cc917c1d6">NaiveOrder</a> (<a class="el" href="namespaceapf.html#a662a796b32a9173981bfc6e1ebe60ba1">Numbering</a> *num)</td></tr>
<tr class="memdesc:a58d710fb72e69e54c182173cc917c1d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">todo : mark as deprecated <br /></td></tr>
<tr class="separator:a58d710fb72e69e54c182173cc917c1d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad8656ce87a4b1d3150e6c028a0033fa"><td class="memItemLeft" align="right" valign="top"><a id="aad8656ce87a4b1d3150e6c028a0033fa"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#aad8656ce87a4b1d3150e6c028a0033fa">adjReorder</a> (<a class="el" href="namespaceapf.html#a662a796b32a9173981bfc6e1ebe60ba1">Numbering</a> *num, <a class="el" href="structapf_1_1Sharing.html">Sharing</a> *sharing=NULL)</td></tr>
<tr class="memdesc:aad8656ce87a4b1d3150e6c028a0033fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">like <a class="el" href="namespaceapf.html#a49da9cc521228907c81c74158b0eb265" title="Number by adjacency graph traversal.">apf::reorder</a>, but numbers all free nodal components <br /></td></tr>
<tr class="separator:aad8656ce87a4b1d3150e6c028a0033fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08aaeeb36a65eebb425b05ba436e7de"><td class="memItemLeft" align="right" valign="top"><a id="ad08aaeeb36a65eebb425b05ba436e7de"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#ad08aaeeb36a65eebb425b05ba436e7de">AdjReorder</a> (<a class="el" href="namespaceapf.html#a662a796b32a9173981bfc6e1ebe60ba1">Numbering</a> *num)</td></tr>
<tr class="memdesc:ad08aaeeb36a65eebb425b05ba436e7de"><td class="mdescLeft">&#160;</td><td class="mdescRight">todo : mark as deprecated <br /></td></tr>
<tr class="separator:ad08aaeeb36a65eebb425b05ba436e7de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42393b57103bd5fad1c9bb95e07dcf42"><td class="memItemLeft" align="right" valign="top"><a id="a42393b57103bd5fad1c9bb95e07dcf42"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a42393b57103bd5fad1c9bb95e07dcf42">setNumberingOffset</a> (<a class="el" href="namespaceapf.html#a662a796b32a9173981bfc6e1ebe60ba1">Numbering</a> *num, int off, <a class="el" href="structapf_1_1Sharing.html">Sharing</a> *sharing=NULL)</td></tr>
<tr class="memdesc:a42393b57103bd5fad1c9bb95e07dcf42"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an offset to all free nodal component numbers <br /></td></tr>
<tr class="separator:a42393b57103bd5fad1c9bb95e07dcf42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab91257b4f54962ab3de216ed44a6b4ca"><td class="memItemLeft" align="right" valign="top"><a id="ab91257b4f54962ab3de216ed44a6b4ca"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#ab91257b4f54962ab3de216ed44a6b4ca">SetNumberingOffset</a> (<a class="el" href="namespaceapf.html#a662a796b32a9173981bfc6e1ebe60ba1">Numbering</a> *num, int off)</td></tr>
<tr class="memdesc:ab91257b4f54962ab3de216ed44a6b4ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">todo : mark as deprecated <br /></td></tr>
<tr class="separator:ab91257b4f54962ab3de216ed44a6b4ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d6933d64022aa4a3a5c0902eed5856"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapf_1_1FieldShape.html">FieldShape</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a93d6933d64022aa4a3a5c0902eed5856">getLagrange</a> (int order)</td></tr>
<tr class="memdesc:a93d6933d64022aa4a3a5c0902eed5856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Lagrangian shape function of some polynomial order.  <a href="namespaceapf.html#a93d6933d64022aa4a3a5c0902eed5856">More...</a><br /></td></tr>
<tr class="separator:a93d6933d64022aa4a3a5c0902eed5856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92cb2bc04b20dc773cf12735573ec6d"><td class="memItemLeft" align="right" valign="top"><a id="ae92cb2bc04b20dc773cf12735573ec6d"></a>
<a class="el" href="classapf_1_1FieldShape.html">FieldShape</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#ae92cb2bc04b20dc773cf12735573ec6d">getSerendipity</a> ()</td></tr>
<tr class="memdesc:ae92cb2bc04b20dc773cf12735573ec6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Serendipity shape functions of second order. <br /></td></tr>
<tr class="separator:ae92cb2bc04b20dc773cf12735573ec6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae247d84abe28de29cdf1b8cd16184e60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapf_1_1FieldShape.html">FieldShape</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#ae247d84abe28de29cdf1b8cd16184e60">getConstant</a> (int dimension)</td></tr>
<tr class="memdesc:ae247d84abe28de29cdf1b8cd16184e60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Constant shape function over some dimension.  <a href="namespaceapf.html#ae247d84abe28de29cdf1b8cd16184e60">More...</a><br /></td></tr>
<tr class="separator:ae247d84abe28de29cdf1b8cd16184e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb55d5a00dbc06ae779d4b36084777c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapf_1_1FieldShape.html">FieldShape</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a3bb55d5a00dbc06ae779d4b36084777c">getIPShape</a> (int dimension, int order)</td></tr>
<tr class="memdesc:a3bb55d5a00dbc06ae779d4b36084777c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Integration Point distribution.  <a href="namespaceapf.html#a3bb55d5a00dbc06ae779d4b36084777c">More...</a><br /></td></tr>
<tr class="separator:a3bb55d5a00dbc06ae779d4b36084777c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c16cb6e7b8fd7d0a3411d1a91d6f4fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapf_1_1FieldShape.html">FieldShape</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a0c16cb6e7b8fd7d0a3411d1a91d6f4fd">getVoronoiShape</a> (int dimension, int order)</td></tr>
<tr class="memdesc:a0c16cb6e7b8fd7d0a3411d1a91d6f4fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Voronoi shape function.  <a href="namespaceapf.html#a0c16cb6e7b8fd7d0a3411d1a91d6f4fd">More...</a><br /></td></tr>
<tr class="separator:a0c16cb6e7b8fd7d0a3411d1a91d6f4fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1b318dc5a6c5f6167ab4614ff138cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapf_1_1FieldShape.html">FieldShape</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a7b1b318dc5a6c5f6167ab4614ff138cd">getIPFitShape</a> (int dimension, int order)</td></tr>
<tr class="memdesc:a7b1b318dc5a6c5f6167ab4614ff138cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the IP Fit shape function.  <a href="namespaceapf.html#a7b1b318dc5a6c5f6167ab4614ff138cd">More...</a><br /></td></tr>
<tr class="separator:a7b1b318dc5a6c5f6167ab4614ff138cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a0aba576e8b368d1b7a20cba45f52c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapf_1_1FieldShape.html">FieldShape</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a1a0aba576e8b368d1b7a20cba45f52c0">getHierarchic</a> (int order)</td></tr>
<tr class="memdesc:a1a0aba576e8b368d1b7a20cba45f52c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the quadratic hierarchic shape function.  <a href="namespaceapf.html#a1a0aba576e8b368d1b7a20cba45f52c0">More...</a><br /></td></tr>
<tr class="separator:a1a0aba576e8b368d1b7a20cba45f52c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9467a0599c5ac57b5c0f7b8ceda3d4db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapf_1_1FieldShape.html">FieldShape</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a9467a0599c5ac57b5c0f7b8ceda3d4db">getNedelec</a> (int order)</td></tr>
<tr class="memdesc:a9467a0599c5ac57b5c0f7b8ceda3d4db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Nedelec shape function of a given order.  <a href="namespaceapf.html#a9467a0599c5ac57b5c0f7b8ceda3d4db">More...</a><br /></td></tr>
<tr class="separator:a9467a0599c5ac57b5c0f7b8ceda3d4db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a155685c98d1f0276796d3f68d10caac2"><td class="memItemLeft" align="right" valign="top"><a id="a155685c98d1f0276796d3f68d10caac2"></a>
<a class="el" href="classapf_1_1FieldShape.html">FieldShape</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a155685c98d1f0276796d3f68d10caac2">getL2Shape</a> (int order, int type)</td></tr>
<tr class="memdesc:a155685c98d1f0276796d3f68d10caac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the L2 shapes of a given order and entity type. <br /></td></tr>
<tr class="separator:a155685c98d1f0276796d3f68d10caac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af62e9232d16aa3aa18e08384e3c2c4e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapf_1_1FieldShape.html">FieldShape</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#af62e9232d16aa3aa18e08384e3c2c4e4">getH1Shape</a> (int order)</td></tr>
<tr class="memdesc:af62e9232d16aa3aa18e08384e3c2c4e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the H1 shapes of a given order.  <a href="namespaceapf.html#af62e9232d16aa3aa18e08384e3c2c4e4">More...</a><br /></td></tr>
<tr class="separator:af62e9232d16aa3aa18e08384e3c2c4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae78d4f6fe29340a379809db022f5e98d"><td class="memItemLeft" align="right" valign="top"><a id="ae78d4f6fe29340a379809db022f5e98d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#ae78d4f6fe29340a379809db022f5e98d">projectHierarchicField</a> (Field *to, Field *from)</td></tr>
<tr class="memdesc:ae78d4f6fe29340a379809db022f5e98d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project a hierarchic field. <br /></td></tr>
<tr class="separator:ae78d4f6fe29340a379809db022f5e98d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9a1ef865897a91f69c659342836c57"><td class="memItemLeft" align="right" valign="top"><a id="abb9a1ef865897a91f69c659342836c57"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#abb9a1ef865897a91f69c659342836c57">projectNedelecField</a> (Field *to, Field *from)</td></tr>
<tr class="memdesc:abb9a1ef865897a91f69c659342836c57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project a Nedelec field. <br /></td></tr>
<tr class="separator:abb9a1ef865897a91f69c659342836c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b0a7a1a979703711ec27a7d9af96eef"><td class="memItemLeft" align="right" valign="top"><a id="a8b0a7a1a979703711ec27a7d9af96eef"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a8b0a7a1a979703711ec27a7d9af96eef">projectL2Field</a> (Field *to, Field *from)</td></tr>
<tr class="memdesc:a8b0a7a1a979703711ec27a7d9af96eef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project a L2 field. <br /></td></tr>
<tr class="separator:a8b0a7a1a979703711ec27a7d9af96eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae79d0f88cd75286949baaa4813e7c35f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#ae79d0f88cd75286949baaa4813e7c35f">countElementNodes</a> (<a class="el" href="classapf_1_1FieldShape.html">FieldShape</a> *s, int type)</td></tr>
<tr class="memdesc:ae79d0f88cd75286949baaa4813e7c35f"><td class="mdescLeft">&#160;</td><td class="mdescRight">count the number of nodes affecting an element type  <a href="namespaceapf.html#ae79d0f88cd75286949baaa4813e7c35f">More...</a><br /></td></tr>
<tr class="separator:ae79d0f88cd75286949baaa4813e7c35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0670f7ef62be57864c080ace1aa780be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a0670f7ef62be57864c080ace1aa780be">getElementNodeXis</a> (<a class="el" href="classapf_1_1FieldShape.html">FieldShape</a> *s, int type, apf::NewArray&lt; <a class="el" href="classapf_1_1Vector3.html">apf::Vector3</a> &gt; &amp;xis)</td></tr>
<tr class="memdesc:a0670f7ef62be57864c080ace1aa780be"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the xi coordinates for all the nodes  <a href="namespaceapf.html#a0670f7ef62be57864c080ace1aa780be">More...</a><br /></td></tr>
<tr class="separator:a0670f7ef62be57864c080ace1aa780be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67fb608f9d0cd79029539c7054152cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#ab67fb608f9d0cd79029539c7054152cc">getElementNodeXis</a> (<a class="el" href="classapf_1_1FieldShape.html">FieldShape</a> *s, <a class="el" href="classapf_1_1Mesh.html">Mesh</a> *m, MeshEntity *e, apf::NewArray&lt; <a class="el" href="classapf_1_1Vector3.html">apf::Vector3</a> &gt; &amp;xis)</td></tr>
<tr class="memdesc:ab67fb608f9d0cd79029539c7054152cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the xi coordinates for all the nodes  <a href="namespaceapf.html#ab67fb608f9d0cd79029539c7054152cc">More...</a><br /></td></tr>
<tr class="separator:ab67fb608f9d0cd79029539c7054152cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c09873de7fd7855f417e4f0cba10f2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapf_1_1Vector3.html">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a7c09873de7fd7855f417e4f0cba10f2b">boundaryToElementXi</a> (<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *m, MeshEntity *boundary, MeshEntity *element, <a class="el" href="classapf_1_1Vector3.html">Vector3</a> const &amp;xi)</td></tr>
<tr class="memdesc:a7c09873de7fd7855f417e4f0cba10f2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reparameterize from boundary entity to element.  <a href="namespaceapf.html#a7c09873de7fd7855f417e4f0cba10f2b">More...</a><br /></td></tr>
<tr class="separator:a7c09873de7fd7855f417e4f0cba10f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d0d84a601f50e97c8d308d7bbff107f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a6d0d84a601f50e97c8d308d7bbff107f">convert</a> (<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *in, <a class="el" href="classapf_1_1Mesh2.html">Mesh2</a> *out, MeshEntity **nodes=NULL, MeshEntity **elems=NULL, bool copy_data=true)</td></tr>
<tr class="memdesc:a6d0d84a601f50e97c8d308d7bbff107f"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert one mesh data structure to another  <a href="namespaceapf.html#a6d0d84a601f50e97c8d308d7bbff107f">More...</a><br /></td></tr>
<tr class="separator:a6d0d84a601f50e97c8d308d7bbff107f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f4fbff831d4ad2f4a3b117eacbed9d3"><td class="memItemLeft" align="right" valign="top">NewElements&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a4f4fbff831d4ad2f4a3b117eacbed9d3">assemble</a> (<a class="el" href="classapf_1_1Mesh2.html">Mesh2</a> *m, const apf::Gid *conn, int nelem, int etype, <a class="el" href="namespaceapf.html#ad41eed81404b62d897ea31da38a53f73">GlobalToVert</a> &amp;globalToVert)</td></tr>
<tr class="memdesc:a4f4fbff831d4ad2f4a3b117eacbed9d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">assemble a mixed-cell-type mesh from just a connectivity array  <a href="namespaceapf.html#a4f4fbff831d4ad2f4a3b117eacbed9d3">More...</a><br /></td></tr>
<tr class="separator:a4f4fbff831d4ad2f4a3b117eacbed9d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c249034dbd85eaa1c944a6731815fcd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a1c249034dbd85eaa1c944a6731815fcd">finalise</a> (<a class="el" href="classapf_1_1Mesh2.html">Mesh2</a> *m, <a class="el" href="namespaceapf.html#ad41eed81404b62d897ea31da38a53f73">GlobalToVert</a> &amp;globalToVert)</td></tr>
<tr class="memdesc:a1c249034dbd85eaa1c944a6731815fcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">finalise construction of a mixed-cell-type mesh from just a connectivity array  <a href="namespaceapf.html#a1c249034dbd85eaa1c944a6731815fcd">More...</a><br /></td></tr>
<tr class="separator:a1c249034dbd85eaa1c944a6731815fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d01fdd080194c513506232443f98d74"><td class="memItemLeft" align="right" valign="top">NewElements&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a5d01fdd080194c513506232443f98d74">construct</a> (<a class="el" href="classapf_1_1Mesh2.html">Mesh2</a> *m, const apf::Gid *conn, int nelem, int etype, <a class="el" href="namespaceapf.html#ad41eed81404b62d897ea31da38a53f73">GlobalToVert</a> &amp;globalToVert)</td></tr>
<tr class="memdesc:a5d01fdd080194c513506232443f98d74"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct a mesh from just a connectivity array  <a href="namespaceapf.html#a5d01fdd080194c513506232443f98d74">More...</a><br /></td></tr>
<tr class="separator:a5d01fdd080194c513506232443f98d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe3657e4785a44df6b3a822895a004a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a3fe3657e4785a44df6b3a822895a004a">setCoords</a> (<a class="el" href="classapf_1_1Mesh2.html">Mesh2</a> *m, const double *coords, int nverts, <a class="el" href="namespaceapf.html#ad41eed81404b62d897ea31da38a53f73">GlobalToVert</a> &amp;globalToVert)</td></tr>
<tr class="memdesc:a3fe3657e4785a44df6b3a822895a004a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign coordinates to the mesh.  <a href="namespaceapf.html#a3fe3657e4785a44df6b3a822895a004a">More...</a><br /></td></tr>
<tr class="separator:a3fe3657e4785a44df6b3a822895a004a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7441f1006483757cfc8df11ce96d69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a0f7441f1006483757cfc8df11ce96d69">setMatches</a> (<a class="el" href="classapf_1_1Mesh2.html">Mesh2</a> *m, const Gid *matches, int nverts, <a class="el" href="namespaceapf.html#ad41eed81404b62d897ea31da38a53f73">GlobalToVert</a> &amp;globalToVert)</td></tr>
<tr class="memdesc:a0f7441f1006483757cfc8df11ce96d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign matching to the mesh.  <a href="namespaceapf.html#a0f7441f1006483757cfc8df11ce96d69">More...</a><br /></td></tr>
<tr class="separator:a0f7441f1006483757cfc8df11ce96d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40263f043f08164b5e83e672db2ad16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#af40263f043f08164b5e83e672db2ad16">destruct</a> (<a class="el" href="classapf_1_1Mesh2.html">Mesh2</a> *m, Gid *&amp;conn, int &amp;nelem, int &amp;etype, int cellDim=-1)</td></tr>
<tr class="memdesc:af40263f043f08164b5e83e672db2ad16"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert an <a class="el" href="classapf_1_1Mesh2.html" title="Extended mesh interface for modification.">apf::Mesh2</a> object into a connectivity array  <a href="namespaceapf.html#af40263f043f08164b5e83e672db2ad16">More...</a><br /></td></tr>
<tr class="separator:af40263f043f08164b5e83e672db2ad16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d57b8d5abcb3ef2021517560105875"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a16d57b8d5abcb3ef2021517560105875">extractCoords</a> (<a class="el" href="classapf_1_1Mesh2.html">Mesh2</a> *m, double *&amp;coords, int &amp;nverts)</td></tr>
<tr class="memdesc:a16d57b8d5abcb3ef2021517560105875"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a contiguous set of global vertex coordinates  <a href="namespaceapf.html#a16d57b8d5abcb3ef2021517560105875">More...</a><br /></td></tr>
<tr class="separator:a16d57b8d5abcb3ef2021517560105875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceef52755ed5ed9af187024cb7175ec2"><td class="memItemLeft" align="right" valign="top"><a id="aceef52755ed5ed9af187024cb7175ec2"></a>
<a class="el" href="classapf_1_1Vector.html">Vector</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#aceef52755ed5ed9af187024cb7175ec2">cross</a> (<a class="el" href="classapf_1_1Vector.html">Vector</a>&lt; 3 &gt; const &amp;a, <a class="el" href="classapf_1_1Vector.html">Vector</a>&lt; 3 &gt; const &amp;b)</td></tr>
<tr class="memdesc:aceef52755ed5ed9af187024cb7175ec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">3D vector cross product <br /></td></tr>
<tr class="separator:aceef52755ed5ed9af187024cb7175ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b2d48997e8be5596a89e4536493441"><td class="memTemplParams" colspan="2"><a id="a74b2d48997e8be5596a89e4536493441"></a>
template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a74b2d48997e8be5596a89e4536493441"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classapf_1_1Vector.html">Vector</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a74b2d48997e8be5596a89e4536493441">project</a> (<a class="el" href="classapf_1_1Vector.html">Vector</a>&lt; N &gt; const &amp;a, <a class="el" href="classapf_1_1Vector.html">Vector</a>&lt; N &gt; const &amp;b)</td></tr>
<tr class="memdesc:a74b2d48997e8be5596a89e4536493441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns vector (a) projected onto vector (b) <br /></td></tr>
<tr class="separator:a74b2d48997e8be5596a89e4536493441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c7d3863be8117c5f460e84f9c03bba"><td class="memTemplParams" colspan="2"><a id="aa1c7d3863be8117c5f460e84f9c03bba"></a>
template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:aa1c7d3863be8117c5f460e84f9c03bba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classapf_1_1Vector.html">Vector</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceapf.html#aa1c7d3863be8117c5f460e84f9c03bba">reject</a> (<a class="el" href="classapf_1_1Vector.html">Vector</a>&lt; N &gt; const &amp;a, <a class="el" href="classapf_1_1Vector.html">Vector</a>&lt; N &gt; const &amp;b)</td></tr>
<tr class="memdesc:aa1c7d3863be8117c5f460e84f9c03bba"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector rejection <br /></td></tr>
<tr class="separator:aa1c7d3863be8117c5f460e84f9c03bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af255a80fb2147e7ffe550e2c58ccf831"><td class="memTemplParams" colspan="2"><a id="af255a80fb2147e7ffe550e2c58ccf831"></a>
template&lt;std::size_t M, std::size_t N&gt; </td></tr>
<tr class="memitem:af255a80fb2147e7ffe550e2c58ccf831"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classapf_1_1Matrix.html">Matrix</a>&lt; N, M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceapf.html#af255a80fb2147e7ffe550e2c58ccf831">transpose</a> (<a class="el" href="classapf_1_1Matrix.html">Matrix</a>&lt; M, N &gt; const &amp;m)</td></tr>
<tr class="memdesc:af255a80fb2147e7ffe550e2c58ccf831"><td class="mdescLeft">&#160;</td><td class="mdescRight">transpose a matrix <br /></td></tr>
<tr class="separator:af255a80fb2147e7ffe550e2c58ccf831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a23e4e1f17de71069e6d1be423a2f3"><td class="memTemplParams" colspan="2"><a id="a80a23e4e1f17de71069e6d1be423a2f3"></a>
template&lt;std::size_t M, std::size_t N&gt; </td></tr>
<tr class="memitem:a80a23e4e1f17de71069e6d1be423a2f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classapf_1_1Matrix.html">Matrix</a>&lt; M, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a80a23e4e1f17de71069e6d1be423a2f3">tensorProduct</a> (<a class="el" href="classapf_1_1Vector.html">Vector</a>&lt; M &gt; const &amp;a, <a class="el" href="classapf_1_1Vector.html">Vector</a>&lt; N &gt; const &amp;b)</td></tr>
<tr class="memdesc:a80a23e4e1f17de71069e6d1be423a2f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">tensor product of two vectors <br /></td></tr>
<tr class="separator:a80a23e4e1f17de71069e6d1be423a2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a6911a0f79a056f07fcc7c4208b2c0"><td class="memTemplParams" colspan="2">template&lt;std::size_t M, std::size_t N&gt; </td></tr>
<tr class="memitem:aa5a6911a0f79a056f07fcc7c4208b2c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classapf_1_1Matrix.html">Matrix</a>&lt; M-1, N-1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceapf.html#aa5a6911a0f79a056f07fcc7c4208b2c0">getMinor</a> (<a class="el" href="classapf_1_1Matrix.html">Matrix</a>&lt; M, N &gt; const &amp;A, std::size_t i, std::size_t j)</td></tr>
<tr class="memdesc:aa5a6911a0f79a056f07fcc7c4208b2c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the minor matrix associated with entry (i,j) of matrix A  <a href="namespaceapf.html#aa5a6911a0f79a056f07fcc7c4208b2c0">More...</a><br /></td></tr>
<tr class="separator:aa5a6911a0f79a056f07fcc7c4208b2c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c90a5e449bf1b4d8ea66f674f9fbcbe"><td class="memTemplParams" colspan="2">template&lt;std::size_t M, std::size_t N&gt; </td></tr>
<tr class="memitem:a8c90a5e449bf1b4d8ea66f674f9fbcbe"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a8c90a5e449bf1b4d8ea66f674f9fbcbe">getCofactor</a> (<a class="el" href="classapf_1_1Matrix.html">Matrix</a>&lt; M, N &gt; const &amp;A, std::size_t i, std::size_t j)</td></tr>
<tr class="memdesc:a8c90a5e449bf1b4d8ea66f674f9fbcbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the cofactor associated with entry (i,j) of matrix A  <a href="namespaceapf.html#a8c90a5e449bf1b4d8ea66f674f9fbcbe">More...</a><br /></td></tr>
<tr class="separator:a8c90a5e449bf1b4d8ea66f674f9fbcbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2654c14a6dbcfa539c1dd273f06a6c"><td class="memTemplParams" colspan="2">template&lt;std::size_t M, std::size_t N&gt; </td></tr>
<tr class="memitem:a8e2654c14a6dbcfa539c1dd273f06a6c"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a8e2654c14a6dbcfa539c1dd273f06a6c">getDeterminant</a> (<a class="el" href="classapf_1_1Matrix.html">Matrix</a>&lt; M, N &gt; const &amp;A)</td></tr>
<tr class="memdesc:a8e2654c14a6dbcfa539c1dd273f06a6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the determinant of a matrix A  <a href="namespaceapf.html#a8e2654c14a6dbcfa539c1dd273f06a6c">More...</a><br /></td></tr>
<tr class="separator:a8e2654c14a6dbcfa539c1dd273f06a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add361489c254987ebecc21fbdf1801ae"><td class="memItemLeft" align="right" valign="top"><a id="add361489c254987ebecc21fbdf1801ae"></a>
<a class="el" href="classapf_1_1Matrix.html">Matrix</a>&lt; 3, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#add361489c254987ebecc21fbdf1801ae">cofactor</a> (<a class="el" href="classapf_1_1Matrix.html">Matrix</a>&lt; 3, 3 &gt; const &amp;m)</td></tr>
<tr class="memdesc:add361489c254987ebecc21fbdf1801ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the matrix of cofactors for a given matrix <br /></td></tr>
<tr class="separator:add361489c254987ebecc21fbdf1801ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf2d5f061d8884ad1fd6e0c145ad8f1"><td class="memItemLeft" align="right" valign="top"><a id="aacf2d5f061d8884ad1fd6e0c145ad8f1"></a>
<a class="el" href="classapf_1_1Matrix.html">Matrix</a>&lt; 2, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#aacf2d5f061d8884ad1fd6e0c145ad8f1">invert</a> (<a class="el" href="classapf_1_1Matrix.html">Matrix</a>&lt; 2, 2 &gt; const &amp;m)</td></tr>
<tr class="memdesc:aacf2d5f061d8884ad1fd6e0c145ad8f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">invert a 2 by 2 matrix <br /></td></tr>
<tr class="separator:aacf2d5f061d8884ad1fd6e0c145ad8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289f130df6dafe7f304016596f71df3c"><td class="memItemLeft" align="right" valign="top"><a id="a289f130df6dafe7f304016596f71df3c"></a>
<a class="el" href="classapf_1_1Matrix.html">Matrix</a>&lt; 3, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a289f130df6dafe7f304016596f71df3c">invert</a> (<a class="el" href="classapf_1_1Matrix.html">Matrix</a>&lt; 3, 3 &gt; const &amp;m)</td></tr>
<tr class="memdesc:a289f130df6dafe7f304016596f71df3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">invert a 3 by 3 matrix <br /></td></tr>
<tr class="separator:a289f130df6dafe7f304016596f71df3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a970e3c2c865b70a1dffa09aa2db45d"><td class="memTemplParams" colspan="2"><a id="a9a970e3c2c865b70a1dffa09aa2db45d"></a>
template&lt;std::size_t M, std::size_t N&gt; </td></tr>
<tr class="memitem:a9a970e3c2c865b70a1dffa09aa2db45d"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a9a970e3c2c865b70a1dffa09aa2db45d">getInnerProduct</a> (<a class="el" href="classapf_1_1Matrix.html">Matrix</a>&lt; M, N &gt; const &amp;a, <a class="el" href="classapf_1_1Matrix.html">Matrix</a>&lt; M, N &gt; const &amp;b)</td></tr>
<tr class="memdesc:a9a970e3c2c865b70a1dffa09aa2db45d"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the component-wise inner product of two matrices <br /></td></tr>
<tr class="separator:a9a970e3c2c865b70a1dffa09aa2db45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31abb8bad477de2b1cef275969105d06"><td class="memItemLeft" align="right" valign="top"><a id="a31abb8bad477de2b1cef275969105d06"></a>
<a class="el" href="classapf_1_1Matrix3x3.html">Matrix3x3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a31abb8bad477de2b1cef275969105d06">cross</a> (<a class="el" href="classapf_1_1Vector3.html">Vector3</a> const &amp;u)</td></tr>
<tr class="memdesc:a31abb8bad477de2b1cef275969105d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the skew-symmetric cross product matrix of a vector <br /></td></tr>
<tr class="separator:a31abb8bad477de2b1cef275969105d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb4c653b78d69109f4ac0f831ca9b43e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapf_1_1Matrix3x3.html">Matrix3x3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#adb4c653b78d69109f4ac0f831ca9b43e">rotate</a> (<a class="el" href="classapf_1_1Vector3.html">Vector3</a> const &amp;u, double a)</td></tr>
<tr class="memdesc:adb4c653b78d69109f4ac0f831ca9b43e"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the rotation matrix around an axis  <a href="namespaceapf.html#adb4c653b78d69109f4ac0f831ca9b43e">More...</a><br /></td></tr>
<tr class="separator:adb4c653b78d69109f4ac0f831ca9b43e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9bbae38d369d4419755dbece22e116"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapf_1_1Matrix3x3.html">Matrix3x3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a7c9bbae38d369d4419755dbece22e116">getFrame</a> (<a class="el" href="classapf_1_1Vector3.html">Vector3</a> const &amp;v)</td></tr>
<tr class="memdesc:a7c9bbae38d369d4419755dbece22e116"><td class="mdescLeft">&#160;</td><td class="mdescRight">derive an orthogonal frame whose x axis is the given vector  <a href="namespaceapf.html#a7c9bbae38d369d4419755dbece22e116">More...</a><br /></td></tr>
<tr class="separator:a7c9bbae38d369d4419755dbece22e116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac78fd5e495e68200c896a796e76f55c7"><td class="memItemLeft" align="right" valign="top"><a id="ac78fd5e495e68200c896a796e76f55c7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#ac78fd5e495e68200c896a796e76f55c7">eigen</a> (<a class="el" href="classapf_1_1Matrix3x3.html">Matrix3x3</a> const &amp;A, <a class="el" href="classapf_1_1Vector.html">Vector</a>&lt; 3 &gt; *eigenVectors, double *eigenValues)</td></tr>
<tr class="memdesc:ac78fd5e495e68200c896a796e76f55c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the eigenvectors and eigenvalues of a 3 by 3 matrix <br /></td></tr>
<tr class="separator:ac78fd5e495e68200c896a796e76f55c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e9fca4a3ecfdfe3195624743b321e9"><td class="memTemplParams" colspan="2">template&lt;std::size_t M&gt; </td></tr>
<tr class="memitem:a69e9fca4a3ecfdfe3195624743b321e9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a69e9fca4a3ecfdfe3195624743b321e9">applyMatrixFunc</a> (<a class="el" href="classapf_1_1Matrix.html">Matrix</a>&lt; M, M &gt; const &amp;A, double(*callback)(double), <a class="el" href="classapf_1_1Matrix.html">Matrix</a>&lt; M, M &gt; &amp;newMat)</td></tr>
<tr class="separator:a69e9fca4a3ecfdfe3195624743b321e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abecb25a13cdd902b22ce485b45a8c0ab"><td class="memTemplParams" colspan="2"><a id="abecb25a13cdd902b22ce485b45a8c0ab"></a>
template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:abecb25a13cdd902b22ce485b45a8c0ab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classapf_1_1DynamicVector.html">DynamicVector</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceapf.html#abecb25a13cdd902b22ce485b45a8c0ab">fromVector</a> (<a class="el" href="classapf_1_1Vector.html">Vector</a>&lt; N &gt; other)</td></tr>
<tr class="memdesc:abecb25a13cdd902b22ce485b45a8c0ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert an <a class="el" href="classapf_1_1Vector.html" title="template-generic vector of N doubles">apf::Vector</a> into an <a class="el" href="classapf_1_1DynamicVector.html" title="A runtime-sized linear algebra vector of doubles.">apf::DynamicVector</a> <br /></td></tr>
<tr class="separator:abecb25a13cdd902b22ce485b45a8c0ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49de1b1b11048a338e079e44714a004f"><td class="memItemLeft" align="right" valign="top"><a id="a49de1b1b11048a338e079e44714a004f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a49de1b1b11048a338e079e44714a004f">multiply</a> (<a class="el" href="classapf_1_1DynamicMatrix.html">DynamicMatrix</a> const &amp;a, <a class="el" href="classapf_1_1DynamicVector.html">DynamicVector</a> const &amp;b, <a class="el" href="classapf_1_1DynamicVector.html">DynamicVector</a> &amp;r)</td></tr>
<tr class="memdesc:a49de1b1b11048a338e079e44714a004f"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiply a <a class="el" href="classapf_1_1DynamicMatrix.html" title="A runtime-sized dense matrix.">DynamicMatrix</a> by a <a class="el" href="classapf_1_1DynamicVector.html" title="A runtime-sized linear algebra vector of doubles.">DynamicVector</a> <br /></td></tr>
<tr class="separator:a49de1b1b11048a338e079e44714a004f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27fb218b2f39ff11d2934fc382c8f81c"><td class="memItemLeft" align="right" valign="top"><a id="a27fb218b2f39ff11d2934fc382c8f81c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a27fb218b2f39ff11d2934fc382c8f81c">multiply</a> (<a class="el" href="classapf_1_1DynamicVector.html">DynamicVector</a> const &amp;b, <a class="el" href="classapf_1_1DynamicMatrix.html">DynamicMatrix</a> const &amp;a, <a class="el" href="classapf_1_1DynamicVector.html">DynamicVector</a> &amp;r)</td></tr>
<tr class="memdesc:a27fb218b2f39ff11d2934fc382c8f81c"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiply a <a class="el" href="classapf_1_1DynamicVector.html" title="A runtime-sized linear algebra vector of doubles.">DynamicVector</a> by a <a class="el" href="classapf_1_1DynamicMatrix.html" title="A runtime-sized dense matrix.">DynamicMatrix</a> <br /></td></tr>
<tr class="separator:a27fb218b2f39ff11d2934fc382c8f81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3ef0993acec8ceb87776e5d5741c91b"><td class="memItemLeft" align="right" valign="top"><a id="ab3ef0993acec8ceb87776e5d5741c91b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#ab3ef0993acec8ceb87776e5d5741c91b">multiply</a> (<a class="el" href="classapf_1_1DynamicMatrix.html">DynamicMatrix</a> const &amp;a, <a class="el" href="classapf_1_1DynamicMatrix.html">DynamicMatrix</a> const &amp;b, <a class="el" href="classapf_1_1DynamicMatrix.html">DynamicMatrix</a> &amp;r)</td></tr>
<tr class="memdesc:ab3ef0993acec8ceb87776e5d5741c91b"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiply two <a class="el" href="classapf_1_1DynamicMatrix.html" title="A runtime-sized dense matrix.">DynamicMatrix</a> objects <br /></td></tr>
<tr class="separator:ab3ef0993acec8ceb87776e5d5741c91b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9975d06790595f0b0d8eade9517525b"><td class="memItemLeft" align="right" valign="top"><a id="af9975d06790595f0b0d8eade9517525b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#af9975d06790595f0b0d8eade9517525b">transpose</a> (<a class="el" href="classapf_1_1DynamicMatrix.html">DynamicMatrix</a> const &amp;a, <a class="el" href="classapf_1_1DynamicMatrix.html">DynamicMatrix</a> &amp;r)</td></tr>
<tr class="memdesc:af9975d06790595f0b0d8eade9517525b"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the transpose of a <a class="el" href="classapf_1_1DynamicMatrix.html" title="A runtime-sized dense matrix.">DynamicMatrix</a> <br /></td></tr>
<tr class="separator:af9975d06790595f0b0d8eade9517525b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f831811e27e3ba46e93f5ae4f2752f"><td class="memTemplParams" colspan="2"><a id="a66f831811e27e3ba46e93f5ae4f2752f"></a>
template&lt;std::size_t N, std::size_t M&gt; </td></tr>
<tr class="memitem:a66f831811e27e3ba46e93f5ae4f2752f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classapf_1_1DynamicMatrix.html">DynamicMatrix</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a66f831811e27e3ba46e93f5ae4f2752f">fromMatrix</a> (<a class="el" href="classapf_1_1Matrix.html">Matrix</a>&lt; N, M &gt; other)</td></tr>
<tr class="memdesc:a66f831811e27e3ba46e93f5ae4f2752f"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert an <a class="el" href="classapf_1_1Matrix.html" title="template-generic matrix of M by N doubles">apf::Matrix</a> into an <a class="el" href="classapf_1_1DynamicMatrix.html" title="A runtime-sized dense matrix.">apf::DynamicMatrix</a> <br /></td></tr>
<tr class="separator:a66f831811e27e3ba46e93f5ae4f2752f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69273da0fbc721b7fcd7b07fe426869b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a69273da0fbc721b7fcd7b07fe426869b">remapPartition</a> (<a class="el" href="classapf_1_1Mesh2.html">apf::Mesh2</a> *m, <a class="el" href="structapf_1_1Remap.html">Remap</a> &amp;remap)</td></tr>
<tr class="memdesc:a69273da0fbc721b7fcd7b07fe426869b"><td class="mdescLeft">&#160;</td><td class="mdescRight">remap all part ids in the mesh structure  <a href="namespaceapf.html#a69273da0fbc721b7fcd7b07fe426869b">More...</a><br /></td></tr>
<tr class="separator:a69273da0fbc721b7fcd7b07fe426869b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad75e869033ad646273d19238c95490ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapf_1_1Mesh2.html">Mesh2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#ad75e869033ad646273d19238c95490ed">makeEmptyMdsMesh</a> (<a class="el" href="structgmi__model.html">gmi_model</a> *model, int dim, bool isMatched, pcu::PCU *PCUObj)</td></tr>
<tr class="memdesc:ad75e869033ad646273d19238c95490ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">create an empty MDS part  <a href="namespaceapf.html#ad75e869033ad646273d19238c95490ed">More...</a><br /></td></tr>
<tr class="separator:ad75e869033ad646273d19238c95490ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acceabc812612189f46a8b76ae696e1a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapf_1_1Mesh2.html">Mesh2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#acceabc812612189f46a8b76ae696e1a5">loadMdsMesh</a> (const char *modelfile, const char *meshfile, pcu::PCU *PCUObj)</td></tr>
<tr class="memdesc:acceabc812612189f46a8b76ae696e1a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">load an MDS mesh and model from file  <a href="namespaceapf.html#acceabc812612189f46a8b76ae696e1a5">More...</a><br /></td></tr>
<tr class="separator:acceabc812612189f46a8b76ae696e1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a68d0848bbc927582586a38c3ebc85a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapf_1_1Mesh2.html">Mesh2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a4a68d0848bbc927582586a38c3ebc85a">loadMdsMesh</a> (<a class="el" href="structgmi__model.html">gmi_model</a> *model, const char *meshfile, pcu::PCU *PCUObj)</td></tr>
<tr class="memdesc:a4a68d0848bbc927582586a38c3ebc85a"><td class="mdescLeft">&#160;</td><td class="mdescRight">load an MDS mesh from files  <a href="namespaceapf.html#a4a68d0848bbc927582586a38c3ebc85a">More...</a><br /></td></tr>
<tr class="separator:a4a68d0848bbc927582586a38c3ebc85a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca78ad6a2b3ef8f32c9e49638f1e38c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapf_1_1Mesh2.html">Mesh2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a7ca78ad6a2b3ef8f32c9e49638f1e38c">createMdsMesh</a> (<a class="el" href="structgmi__model.html">gmi_model</a> *model, <a class="el" href="classapf_1_1Mesh.html">Mesh</a> *from, bool <a class="el" href="namespaceapf.html#a49da9cc521228907c81c74158b0eb265">reorder</a>=false, bool copy_data=true)</td></tr>
<tr class="memdesc:a7ca78ad6a2b3ef8f32c9e49638f1e38c"><td class="mdescLeft">&#160;</td><td class="mdescRight">create an MDS mesh from an existing mesh  <a href="namespaceapf.html#a7ca78ad6a2b3ef8f32c9e49638f1e38c">More...</a><br /></td></tr>
<tr class="separator:a7ca78ad6a2b3ef8f32c9e49638f1e38c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f9b7315893d20ac27d3b32efa453c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a74f9b7315893d20ac27d3b32efa453c7">reorderMdsMesh</a> (<a class="el" href="classapf_1_1Mesh2.html">Mesh2</a> *mesh, MeshTag *t=0)</td></tr>
<tr class="memdesc:a74f9b7315893d20ac27d3b32efa453c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply adjacency-based reordering  <a href="namespaceapf.html#a74f9b7315893d20ac27d3b32efa453c7">More...</a><br /></td></tr>
<tr class="separator:a74f9b7315893d20ac27d3b32efa453c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de8b0937205404f33aa98cc5329c257"><td class="memItemLeft" align="right" valign="top"><a id="a0de8b0937205404f33aa98cc5329c257"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a0de8b0937205404f33aa98cc5329c257">alignMdsMatches</a> (<a class="el" href="classapf_1_1Mesh2.html">Mesh2</a> *in)</td></tr>
<tr class="memdesc:a0de8b0937205404f33aa98cc5329c257"><td class="mdescLeft">&#160;</td><td class="mdescRight">align the downward adjacencies of matched entities <br /></td></tr>
<tr class="separator:a0de8b0937205404f33aa98cc5329c257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3d6d85a39959aa784ff3d04c941894"><td class="memItemLeft" align="right" valign="top"><a id="a2c3d6d85a39959aa784ff3d04c941894"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a2c3d6d85a39959aa784ff3d04c941894">alignMdsRemotes</a> (<a class="el" href="classapf_1_1Mesh2.html">Mesh2</a> *in)</td></tr>
<tr class="memdesc:a2c3d6d85a39959aa784ff3d04c941894"><td class="mdescLeft">&#160;</td><td class="mdescRight">align the downward adjacencies of remote copies <br /></td></tr>
<tr class="separator:a2c3d6d85a39959aa784ff3d04c941894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619beb8ada85832d9bb604a0ca7ae865"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a619beb8ada85832d9bb604a0ca7ae865">deriveMdsModel</a> (<a class="el" href="classapf_1_1Mesh2.html">Mesh2</a> *in)</td></tr>
<tr class="memdesc:a619beb8ada85832d9bb604a0ca7ae865"><td class="mdescLeft">&#160;</td><td class="mdescRight">build a null model such that <a class="el" href="namespaceapf.html#aacc951388f86b0fcce7a428905d09203" title="run consistency checks on an apf::Mesh structure">apf::verify</a> accepts the mesh.  <a href="namespaceapf.html#a619beb8ada85832d9bb604a0ca7ae865">More...</a><br /></td></tr>
<tr class="separator:a619beb8ada85832d9bb604a0ca7ae865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f03eb0ab471313994a3cc12910e513"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a80f03eb0ab471313994a3cc12910e513">deriveMdlFromManifold</a> (<a class="el" href="classapf_1_1Mesh2.html">Mesh2</a> *mesh, bool *isModelVert, int nBFaces, int(*bFaces)[5], <a class="el" href="namespaceapf.html#ad41eed81404b62d897ea31da38a53f73">GlobalToVert</a> &amp;globalToVert, std::map&lt; int, apf::MeshEntity * &gt; &amp;globalToRegion)</td></tr>
<tr class="memdesc:a80f03eb0ab471313994a3cc12910e513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the mesh vertices that are also model vertices, and the classification on boundary mesh faces, constructs the classification on the rest of the boundary entities.  <a href="namespaceapf.html#a80f03eb0ab471313994a3cc12910e513">More...</a><br /></td></tr>
<tr class="separator:a80f03eb0ab471313994a3cc12910e513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6361743deaa5515a0ad17f70a15424c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#aa6361743deaa5515a0ad17f70a15424c">derive2DMdlFromManifold</a> (<a class="el" href="classapf_1_1Mesh2.html">Mesh2</a> *mesh, bool *isModelVert, int nBEdges, int(*bEdges)[4], <a class="el" href="namespaceapf.html#ad41eed81404b62d897ea31da38a53f73">GlobalToVert</a> &amp;globalToVert, std::map&lt; int, apf::MeshEntity * &gt; &amp;globalToFace)</td></tr>
<tr class="memdesc:aa6361743deaa5515a0ad17f70a15424c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the mesh vertices that are also model vertices, and the classification on boundary mesh edges, constructs the classification on the rest of the boundary entities for a 2-D mesh.  <a href="namespaceapf.html#aa6361743deaa5515a0ad17f70a15424c">More...</a><br /></td></tr>
<tr class="separator:aa6361743deaa5515a0ad17f70a15424c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef521ab351092c61cef2f9b5fda28ddd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#aef521ab351092c61cef2f9b5fda28ddd">changeMdsDimension</a> (<a class="el" href="classapf_1_1Mesh2.html">Mesh2</a> *in, int d)</td></tr>
<tr class="memdesc:aef521ab351092c61cef2f9b5fda28ddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">change the dimension of an MDS mesh  <a href="namespaceapf.html#aef521ab351092c61cef2f9b5fda28ddd">More...</a><br /></td></tr>
<tr class="separator:aef521ab351092c61cef2f9b5fda28ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbeaf82d73a7bf53e1429add81f06bfe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#afbeaf82d73a7bf53e1429add81f06bfe">getMdsIndex</a> (<a class="el" href="classapf_1_1Mesh2.html">Mesh2</a> *in, MeshEntity *e)</td></tr>
<tr class="memdesc:afbeaf82d73a7bf53e1429add81f06bfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the dimension-unique index for this entity  <a href="namespaceapf.html#afbeaf82d73a7bf53e1429add81f06bfe">More...</a><br /></td></tr>
<tr class="separator:afbeaf82d73a7bf53e1429add81f06bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c6382a417b2c47b4140ccda120c92fd"><td class="memItemLeft" align="right" valign="top">MeshEntity *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a3c6382a417b2c47b4140ccda120c92fd">getMdsEntity</a> (<a class="el" href="classapf_1_1Mesh2.html">Mesh2</a> *in, int dimension, int index)</td></tr>
<tr class="memdesc:a3c6382a417b2c47b4140ccda120c92fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">retrieve an entity by dimension and index  <a href="namespaceapf.html#a3c6382a417b2c47b4140ccda120c92fd">More...</a><br /></td></tr>
<tr class="separator:a3c6382a417b2c47b4140ccda120c92fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860880da18799bb81b55f5a8cd4e648f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapf_1_1Mesh2.html">Mesh2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a860880da18799bb81b55f5a8cd4e648f">loadMdsFromANSYS</a> (const char *nodefile, const char *elemfile, pcu::PCU *PCUObj)</td></tr>
<tr class="memdesc:a860880da18799bb81b55f5a8cd4e648f"><td class="mdescLeft">&#160;</td><td class="mdescRight">load an MDS mesh from ANSYS .node and .elem files  <a href="namespaceapf.html#a860880da18799bb81b55f5a8cd4e648f">More...</a><br /></td></tr>
<tr class="separator:a860880da18799bb81b55f5a8cd4e648f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8074bec4c889d9ed3a76a2c178e3e9a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapf_1_1Splitter.html">Splitter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a8074bec4c889d9ed3a76a2c178e3e9a9">makeZoltanSplitter</a> (<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *mesh, int method, int approach, bool debug=false, bool sync=true)</td></tr>
<tr class="memdesc:a8074bec4c889d9ed3a76a2c178e3e9a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a Zoltan <a class="el" href="classapf_1_1Splitter.html" title="Splits a mesh part into many.">Splitter</a> object.  <a href="namespaceapf.html#a8074bec4c889d9ed3a76a2c178e3e9a9">More...</a><br /></td></tr>
<tr class="separator:a8074bec4c889d9ed3a76a2c178e3e9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7948c4241abc16e6fccfef9892d61311"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapf_1_1Splitter.html">Splitter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a7948c4241abc16e6fccfef9892d61311">makeZoltanGlobalSplitter</a> (<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *mesh, int method, int approach, bool debug=false)</td></tr>
<tr class="memdesc:a7948c4241abc16e6fccfef9892d61311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a Zoltan <a class="el" href="classapf_1_1Splitter.html" title="Splits a mesh part into many.">Splitter</a> object.  <a href="namespaceapf.html#a7948c4241abc16e6fccfef9892d61311">More...</a><br /></td></tr>
<tr class="separator:a7948c4241abc16e6fccfef9892d61311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e7fc3b4f495d47ab6af0020f36ebfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classapf_1_1Balancer.html">Balancer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a06e7fc3b4f495d47ab6af0020f36ebfc">makeZoltanBalancer</a> (<a class="el" href="classapf_1_1Mesh.html">Mesh</a> *mesh, int method, int approach, bool debug=false)</td></tr>
<tr class="memdesc:a06e7fc3b4f495d47ab6af0020f36ebfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a Zoltan <a class="el" href="classapf_1_1Balancer.html" title="Load balance over all mesh parts.">Balancer</a> object.  <a href="namespaceapf.html#a06e7fc3b4f495d47ab6af0020f36ebfc">More...</a><br /></td></tr>
<tr class="separator:a06e7fc3b4f495d47ab6af0020f36ebfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb8a13df4b1cd6f42baad3a7d335cb6"><td class="memItemLeft" align="right" valign="top">MeshTag *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a7eb8a13df4b1cd6f42baad3a7d335cb6">tagOpposites</a> (<a class="el" href="namespaceapf.html#a691865cc4ddfa6781e8aba4e338617e8">GlobalNumbering</a> *gn, const char *name)</td></tr>
<tr class="memdesc:a7eb8a13df4b1cd6f42baad3a7d335cb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag global ids of opposite elements to boundary faces.  <a href="namespaceapf.html#a7eb8a13df4b1cd6f42baad3a7d335cb6">More...</a><br /></td></tr>
<tr class="separator:a7eb8a13df4b1cd6f42baad3a7d335cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a674978bde719b096c97b16c7f0f134ba"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a674978bde719b096c97b16c7f0f134ba">getElementToElement</a> (<a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *m)</td></tr>
<tr class="memdesc:a674978bde719b096c97b16c7f0f134ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an element-to-element connectivity array.  <a href="namespaceapf.html#a674978bde719b096c97b16c7f0f134ba">More...</a><br /></td></tr>
<tr class="separator:a674978bde719b096c97b16c7f0f134ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a28997f63061808e3bca795be03a8ff74"><td class="memItemLeft" align="right" valign="top"><a id="a28997f63061808e3bca795be03a8ff74"></a>
int const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a28997f63061808e3bca795be03a8ff74">tri_edge_verts</a> [3][2]</td></tr>
<tr class="memdesc:a28997f63061808e3bca795be03a8ff74"><td class="mdescLeft">&#160;</td><td class="mdescRight">map from triangle edge order to triangle vertex order <br /></td></tr>
<tr class="separator:a28997f63061808e3bca795be03a8ff74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc09814050aeb6e7d018434f6722598"><td class="memItemLeft" align="right" valign="top"><a id="affc09814050aeb6e7d018434f6722598"></a>
int const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#affc09814050aeb6e7d018434f6722598">quad_edge_verts</a> [4][2]</td></tr>
<tr class="memdesc:affc09814050aeb6e7d018434f6722598"><td class="mdescLeft">&#160;</td><td class="mdescRight">map from quad edge order to quad vertex order <br /></td></tr>
<tr class="separator:affc09814050aeb6e7d018434f6722598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b8e2c679a468bb9344650278d18f1c"><td class="memItemLeft" align="right" valign="top"><a id="a67b8e2c679a468bb9344650278d18f1c"></a>
int const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a67b8e2c679a468bb9344650278d18f1c">tet_edge_verts</a> [6][2]</td></tr>
<tr class="memdesc:a67b8e2c679a468bb9344650278d18f1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">map from tet edge order to tet vertex order <br /></td></tr>
<tr class="separator:a67b8e2c679a468bb9344650278d18f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04e1dc2d87929677f9b290e2c5b1a5c7"><td class="memItemLeft" align="right" valign="top"><a id="a04e1dc2d87929677f9b290e2c5b1a5c7"></a>
int const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a04e1dc2d87929677f9b290e2c5b1a5c7">prism_edge_verts</a> [9][2]</td></tr>
<tr class="memdesc:a04e1dc2d87929677f9b290e2c5b1a5c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">map from prism edge order to prism vertex order <br /></td></tr>
<tr class="separator:a04e1dc2d87929677f9b290e2c5b1a5c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3d482eb8a395466d12bcd8fd1c6f0a"><td class="memItemLeft" align="right" valign="top"><a id="aed3d482eb8a395466d12bcd8fd1c6f0a"></a>
int const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#aed3d482eb8a395466d12bcd8fd1c6f0a">pyramid_edge_verts</a> [8][2]</td></tr>
<tr class="memdesc:aed3d482eb8a395466d12bcd8fd1c6f0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">map from pyramid edge order to pyramid vertex order <br /></td></tr>
<tr class="separator:aed3d482eb8a395466d12bcd8fd1c6f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf9d55f654371b760b5345700593013"><td class="memItemLeft" align="right" valign="top"><a id="afcf9d55f654371b760b5345700593013"></a>
int const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#afcf9d55f654371b760b5345700593013">tet_tri_verts</a> [4][3]</td></tr>
<tr class="memdesc:afcf9d55f654371b760b5345700593013"><td class="mdescLeft">&#160;</td><td class="mdescRight">map from tet triangle order to tet vertex order <br /></td></tr>
<tr class="separator:afcf9d55f654371b760b5345700593013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544e70b3715423e33c55712d4d5034d1"><td class="memItemLeft" align="right" valign="top"><a id="a544e70b3715423e33c55712d4d5034d1"></a>
int const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a544e70b3715423e33c55712d4d5034d1">hex_quad_verts</a> [6][4]</td></tr>
<tr class="memdesc:a544e70b3715423e33c55712d4d5034d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">map from hex quad order to hex vertex order <br /></td></tr>
<tr class="separator:a544e70b3715423e33c55712d4d5034d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f73a0e3c768e283ffbb4a8166c3c0b6"><td class="memItemLeft" align="right" valign="top"><a id="a1f73a0e3c768e283ffbb4a8166c3c0b6"></a>
int const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a1f73a0e3c768e283ffbb4a8166c3c0b6">prism_tri_verts</a> [2][3]</td></tr>
<tr class="memdesc:a1f73a0e3c768e283ffbb4a8166c3c0b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">map from prism triangle order to prism vertex order <br /></td></tr>
<tr class="separator:a1f73a0e3c768e283ffbb4a8166c3c0b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a0b16188d6e790f755ffc3d1fc17e8"><td class="memItemLeft" align="right" valign="top"><a id="a05a0b16188d6e790f755ffc3d1fc17e8"></a>
int const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a05a0b16188d6e790f755ffc3d1fc17e8">prism_quad_verts</a> [3][4]</td></tr>
<tr class="memdesc:a05a0b16188d6e790f755ffc3d1fc17e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">map from prism quad order to prism vertex order <br /></td></tr>
<tr class="separator:a05a0b16188d6e790f755ffc3d1fc17e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0513fccb705eb3a1f54e2a57c165aebf"><td class="memItemLeft" align="right" valign="top"><a id="a0513fccb705eb3a1f54e2a57c165aebf"></a>
int const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a0513fccb705eb3a1f54e2a57c165aebf">pyramid_tri_verts</a> [4][3]</td></tr>
<tr class="memdesc:a0513fccb705eb3a1f54e2a57c165aebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">map from pyramid triangle order to pyramid vertex order <br /></td></tr>
<tr class="separator:a0513fccb705eb3a1f54e2a57c165aebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d5b986f43beadd2e9967a366850a0a"><td class="memItemLeft" align="right" valign="top">double const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceapf.html#a59d5b986f43beadd2e9967a366850a0a">pi</a></td></tr>
<tr class="memdesc:a59d5b986f43beadd2e9967a366850a0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The mathematical constant pi.  <a href="namespaceapf.html#a59d5b986f43beadd2e9967a366850a0a">More...</a><br /></td></tr>
<tr class="separator:a59d5b986f43beadd2e9967a366850a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>All APF symbols are contained in this namespace. </p>
<p>Wrapping a namespace over everything gives reasonable insurance against future symbol conflicts with other packages while very common names are being used, like <a class="el" href="classapf_1_1Mesh.html" title="Interface to a mesh part.">Mesh</a> or VECTOR. Users will be able to use the simple names directly with a using statement, likewise all APF code is written without apf:: </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a12d882b4789bf98322cbe6f02c91b1f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12d882b4789bf98322cbe6f02c91b1f8">&#9670;&nbsp;</a></span>Adjacent</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef DynamicArray&lt;MeshEntity*&gt; <a class="el" href="namespaceapf.html#a12d882b4789bf98322cbe6f02c91b1f8">apf::Adjacent</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set of adjacent mesh entities. </p>
<p>see also <a class="el" href="namespaceapf.html#a041eedcdfef4c64dafb2936219978328" title="a static array type downward adjacency queries.">apf::Downward</a> and <a class="el" href="structapf_1_1Up.html" title="statically sized container for upward adjacency queries.">apf::Up</a> </p>

<p class="definition">Definition at line <a class="el" href="apfMesh_8h_source.html#l00047">47</a> of file <a class="el" href="apfMesh_8h_source.html">apfMesh.h</a>.</p>

</div>
</div>
<a id="a4fdcb1e40963596d8345f0328e7d65b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fdcb1e40963596d8345f0328e7d65b1">&#9670;&nbsp;</a></span>Copies</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;int,MeshEntity*&gt; <a class="el" href="namespaceapf.html#a4fdcb1e40963596d8345f0328e7d65b1">apf::Copies</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remote copy container. </p>
<p>the key is the part id, the value is the on-part pointer to the remote copy </p>

<p class="definition">Definition at line <a class="el" href="apfMesh_8h_source.html#l00042">42</a> of file <a class="el" href="apfMesh_8h_source.html">apfMesh.h</a>.</p>

</div>
</div>
<a id="a041eedcdfef4c64dafb2936219978328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a041eedcdfef4c64dafb2936219978328">&#9670;&nbsp;</a></span>Downward</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef MeshEntity* apf::Downward[12]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a static array type downward adjacency queries. </p>
<p>using statically sized arrays saves time by avoiding dynamic allocation, and downward adjacencies have a guaranteed bound. </p>

<p class="definition">Definition at line <a class="el" href="apfMesh_8h_source.html#l00053">53</a> of file <a class="el" href="apfMesh_8h_source.html">apfMesh.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a496b3a52d5026c0afdb138b46ea25cca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a496b3a52d5026c0afdb138b46ea25cca">&#9670;&nbsp;</a></span>ValueType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceapf.html#a496b3a52d5026c0afdb138b46ea25cca">apf::ValueType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of value the field stores. </p>
<p>The near future may bring more complex tensors. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a496b3a52d5026c0afdb138b46ea25ccaab8dc994c7c9cd1be3a1b9b176b8ccc65"></a>SCALAR&#160;</td><td class="fielddoc"><p>a single scalar value. </p>
</td></tr>
<tr><td class="fieldname"><a id="a496b3a52d5026c0afdb138b46ea25ccaa963e21a78ec85257a262d62c14f93160"></a>VECTOR&#160;</td><td class="fielddoc"><p>a 3D vector value </p>
</td></tr>
<tr><td class="fieldname"><a id="a496b3a52d5026c0afdb138b46ea25ccaafb466e4ed43caf8134a8d67013877f3d"></a>MATRIX&#160;</td><td class="fielddoc"><p>a 3x3 matrix </p>
</td></tr>
<tr><td class="fieldname"><a id="a496b3a52d5026c0afdb138b46ea25ccaa2bedc04cff0e3de6562d2d9855658e42"></a>PACKED&#160;</td><td class="fielddoc"><p>a user-defined set of components </p>
</td></tr>
<tr><td class="fieldname"><a id="a496b3a52d5026c0afdb138b46ea25ccaac7e6014a273fb05e198991f5a5ff8504"></a>VALUE_TYPES&#160;</td><td class="fielddoc"><p>placeholder used to set array sizes </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="apf_8h_source.html#l00133">133</a> of file <a class="el" href="apf_8h_source.html">apf.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;               {</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;  <a class="code" href="namespaceapf.html#a496b3a52d5026c0afdb138b46ea25ccaab8dc994c7c9cd1be3a1b9b176b8ccc65">SCALAR</a>,</div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;  <a class="code" href="namespaceapf.html#a496b3a52d5026c0afdb138b46ea25ccaa963e21a78ec85257a262d62c14f93160">VECTOR</a>,</div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;  <a class="code" href="namespaceapf.html#a496b3a52d5026c0afdb138b46ea25ccaafb466e4ed43caf8134a8d67013877f3d">MATRIX</a>,</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;  <a class="code" href="namespaceapf.html#a496b3a52d5026c0afdb138b46ea25ccaa2bedc04cff0e3de6562d2d9855658e42">PACKED</a>,</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;  <a class="code" href="namespaceapf.html#a496b3a52d5026c0afdb138b46ea25ccaac7e6014a273fb05e198991f5a5ff8504">VALUE_TYPES</a></div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;};</div>
<div class="ttc" id="anamespaceapf_html_a496b3a52d5026c0afdb138b46ea25ccaa2bedc04cff0e3de6562d2d9855658e42"><div class="ttname"><a href="namespaceapf.html#a496b3a52d5026c0afdb138b46ea25ccaa2bedc04cff0e3de6562d2d9855658e42">apf::PACKED</a></div><div class="ttdeci">@ PACKED</div><div class="ttdoc">a user-defined set of components</div><div class="ttdef"><b>Definition:</b> <a href="apf_8h_source.html#l00141">apf.h:141</a></div></div>
<div class="ttc" id="anamespaceapf_html_a496b3a52d5026c0afdb138b46ea25ccaa963e21a78ec85257a262d62c14f93160"><div class="ttname"><a href="namespaceapf.html#a496b3a52d5026c0afdb138b46ea25ccaa963e21a78ec85257a262d62c14f93160">apf::VECTOR</a></div><div class="ttdeci">@ VECTOR</div><div class="ttdoc">a 3D vector value</div><div class="ttdef"><b>Definition:</b> <a href="apf_8h_source.html#l00137">apf.h:137</a></div></div>
<div class="ttc" id="anamespaceapf_html_a496b3a52d5026c0afdb138b46ea25ccaab8dc994c7c9cd1be3a1b9b176b8ccc65"><div class="ttname"><a href="namespaceapf.html#a496b3a52d5026c0afdb138b46ea25ccaab8dc994c7c9cd1be3a1b9b176b8ccc65">apf::SCALAR</a></div><div class="ttdeci">@ SCALAR</div><div class="ttdoc">a single scalar value.</div><div class="ttdef"><b>Definition:</b> <a href="apf_8h_source.html#l00135">apf.h:135</a></div></div>
<div class="ttc" id="anamespaceapf_html_a496b3a52d5026c0afdb138b46ea25ccaac7e6014a273fb05e198991f5a5ff8504"><div class="ttname"><a href="namespaceapf.html#a496b3a52d5026c0afdb138b46ea25ccaac7e6014a273fb05e198991f5a5ff8504">apf::VALUE_TYPES</a></div><div class="ttdeci">@ VALUE_TYPES</div><div class="ttdoc">placeholder used to set array sizes</div><div class="ttdef"><b>Definition:</b> <a href="apf_8h_source.html#l00144">apf.h:143</a></div></div>
<div class="ttc" id="anamespaceapf_html_a496b3a52d5026c0afdb138b46ea25ccaafb466e4ed43caf8134a8d67013877f3d"><div class="ttname"><a href="namespaceapf.html#a496b3a52d5026c0afdb138b46ea25ccaafb466e4ed43caf8134a8d67013877f3d">apf::MATRIX</a></div><div class="ttdeci">@ MATRIX</div><div class="ttdoc">a 3x3 matrix</div><div class="ttdef"><b>Definition:</b> <a href="apf_8h_source.html#l00139">apf.h:139</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a4cbe5a6d7973e9a17036406a3cead028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cbe5a6d7973e9a17036406a3cead028">&#9670;&nbsp;</a></span>ZoltanApproach</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceapf.html#a4cbe5a6d7973e9a17036406a3cead028">apf::ZoltanApproach</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Zoltan partitioning approach. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4cbe5a6d7973e9a17036406a3cead028a8cb25195e6e91535fb91ec8693f3ba9f"></a>PARTITION&#160;</td><td class="fielddoc"><p>(Hyper)Graph - does not consider the initial distribution </p>
</td></tr>
<tr><td class="fieldname"><a id="a4cbe5a6d7973e9a17036406a3cead028a61e3517c772e8d7ada0efb663e147063"></a>REPARTITION&#160;</td><td class="fielddoc"><p>(Hyper)Graph - considers the initial distribution </p>
</td></tr>
<tr><td class="fieldname"><a id="a4cbe5a6d7973e9a17036406a3cead028ab295d9106368298122ff7c02701b5e45"></a>REFINE&#160;</td><td class="fielddoc"><p>(HYPER)Graph - targets partitions needing only small changes </p>
</td></tr>
<tr><td class="fieldname"><a id="a4cbe5a6d7973e9a17036406a3cead028ae6d3431a5438bf549c9ce3c7e9118eb6"></a>PART_KWAY&#160;</td><td class="fielddoc"><p>Graph - multilevel. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4cbe5a6d7973e9a17036406a3cead028a26ca6977a5dfc333fd0478c4e495a304"></a>PART_GEOM&#160;</td><td class="fielddoc"><p>Graph - space filling curves. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4cbe5a6d7973e9a17036406a3cead028a02f85ed97912e559830f3c477facf458"></a>PART_GEOM_KWAY&#160;</td><td class="fielddoc"><p>Graph - hybrid method combining PART_KWAY and PART_GEOM. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4cbe5a6d7973e9a17036406a3cead028ab381b0c6fa3cb9e4980ce664a7026b77"></a>ADAPT_REPART&#160;</td><td class="fielddoc"><p>Graph - targets graphs generated from adaptively refined meshes. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4cbe5a6d7973e9a17036406a3cead028a861462a65cf82c41d73959677370694a"></a>REFINE_KWAY&#160;</td><td class="fielddoc"><p>Graph - targets partitions needing only small changes. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="apfZoltan_8h_source.html#l00050">50</a> of file <a class="el" href="apfZoltan_8h_source.html">apfZoltan.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;                    {</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;  <a class="code" href="namespaceapf.html#a4cbe5a6d7973e9a17036406a3cead028a8cb25195e6e91535fb91ec8693f3ba9f">PARTITION</a>,</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;  <a class="code" href="namespaceapf.html#a4cbe5a6d7973e9a17036406a3cead028a61e3517c772e8d7ada0efb663e147063">REPARTITION</a>,</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;  <a class="code" href="namespaceapf.html#a4cbe5a6d7973e9a17036406a3cead028ab295d9106368298122ff7c02701b5e45">REFINE</a>,</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;  <a class="code" href="namespaceapf.html#a4cbe5a6d7973e9a17036406a3cead028ae6d3431a5438bf549c9ce3c7e9118eb6">PART_KWAY</a>,</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;  <a class="code" href="namespaceapf.html#a4cbe5a6d7973e9a17036406a3cead028a26ca6977a5dfc333fd0478c4e495a304">PART_GEOM</a>,</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;  <a class="code" href="namespaceapf.html#a4cbe5a6d7973e9a17036406a3cead028a02f85ed97912e559830f3c477facf458">PART_GEOM_KWAY</a>,</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;  <a class="code" href="namespaceapf.html#a4cbe5a6d7973e9a17036406a3cead028ab381b0c6fa3cb9e4980ce664a7026b77">ADAPT_REPART</a>,</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;  <a class="code" href="namespaceapf.html#a4cbe5a6d7973e9a17036406a3cead028a861462a65cf82c41d73959677370694a">REFINE_KWAY</a></div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;};</div>
<div class="ttc" id="anamespaceapf_html_a4cbe5a6d7973e9a17036406a3cead028a02f85ed97912e559830f3c477facf458"><div class="ttname"><a href="namespaceapf.html#a4cbe5a6d7973e9a17036406a3cead028a02f85ed97912e559830f3c477facf458">apf::PART_GEOM_KWAY</a></div><div class="ttdeci">@ PART_GEOM_KWAY</div><div class="ttdoc">Graph - hybrid method combining PART_KWAY and PART_GEOM.</div><div class="ttdef"><b>Definition:</b> <a href="apfZoltan_8h_source.html#l00062">apfZoltan.h:62</a></div></div>
<div class="ttc" id="anamespaceapf_html_a4cbe5a6d7973e9a17036406a3cead028a26ca6977a5dfc333fd0478c4e495a304"><div class="ttname"><a href="namespaceapf.html#a4cbe5a6d7973e9a17036406a3cead028a26ca6977a5dfc333fd0478c4e495a304">apf::PART_GEOM</a></div><div class="ttdeci">@ PART_GEOM</div><div class="ttdoc">Graph - space filling curves.</div><div class="ttdef"><b>Definition:</b> <a href="apfZoltan_8h_source.html#l00060">apfZoltan.h:60</a></div></div>
<div class="ttc" id="anamespaceapf_html_a4cbe5a6d7973e9a17036406a3cead028a61e3517c772e8d7ada0efb663e147063"><div class="ttname"><a href="namespaceapf.html#a4cbe5a6d7973e9a17036406a3cead028a61e3517c772e8d7ada0efb663e147063">apf::REPARTITION</a></div><div class="ttdeci">@ REPARTITION</div><div class="ttdoc">(Hyper)Graph - considers the initial distribution</div><div class="ttdef"><b>Definition:</b> <a href="apfZoltan_8h_source.html#l00054">apfZoltan.h:54</a></div></div>
<div class="ttc" id="anamespaceapf_html_a4cbe5a6d7973e9a17036406a3cead028a861462a65cf82c41d73959677370694a"><div class="ttname"><a href="namespaceapf.html#a4cbe5a6d7973e9a17036406a3cead028a861462a65cf82c41d73959677370694a">apf::REFINE_KWAY</a></div><div class="ttdeci">@ REFINE_KWAY</div><div class="ttdoc">Graph - targets partitions needing only small changes.</div><div class="ttdef"><b>Definition:</b> <a href="apfZoltan_8h_source.html#l00067">apfZoltan.h:66</a></div></div>
<div class="ttc" id="anamespaceapf_html_a4cbe5a6d7973e9a17036406a3cead028a8cb25195e6e91535fb91ec8693f3ba9f"><div class="ttname"><a href="namespaceapf.html#a4cbe5a6d7973e9a17036406a3cead028a8cb25195e6e91535fb91ec8693f3ba9f">apf::PARTITION</a></div><div class="ttdeci">@ PARTITION</div><div class="ttdoc">(Hyper)Graph - does not consider the initial distribution</div><div class="ttdef"><b>Definition:</b> <a href="apfZoltan_8h_source.html#l00052">apfZoltan.h:52</a></div></div>
<div class="ttc" id="anamespaceapf_html_a4cbe5a6d7973e9a17036406a3cead028ab295d9106368298122ff7c02701b5e45"><div class="ttname"><a href="namespaceapf.html#a4cbe5a6d7973e9a17036406a3cead028ab295d9106368298122ff7c02701b5e45">apf::REFINE</a></div><div class="ttdeci">@ REFINE</div><div class="ttdoc">(HYPER)Graph - targets partitions needing only small changes</div><div class="ttdef"><b>Definition:</b> <a href="apfZoltan_8h_source.html#l00056">apfZoltan.h:56</a></div></div>
<div class="ttc" id="anamespaceapf_html_a4cbe5a6d7973e9a17036406a3cead028ab381b0c6fa3cb9e4980ce664a7026b77"><div class="ttname"><a href="namespaceapf.html#a4cbe5a6d7973e9a17036406a3cead028ab381b0c6fa3cb9e4980ce664a7026b77">apf::ADAPT_REPART</a></div><div class="ttdeci">@ ADAPT_REPART</div><div class="ttdoc">Graph - targets graphs generated from adaptively refined meshes.</div><div class="ttdef"><b>Definition:</b> <a href="apfZoltan_8h_source.html#l00064">apfZoltan.h:64</a></div></div>
<div class="ttc" id="anamespaceapf_html_a4cbe5a6d7973e9a17036406a3cead028ae6d3431a5438bf549c9ce3c7e9118eb6"><div class="ttname"><a href="namespaceapf.html#a4cbe5a6d7973e9a17036406a3cead028ae6d3431a5438bf549c9ce3c7e9118eb6">apf::PART_KWAY</a></div><div class="ttdeci">@ PART_KWAY</div><div class="ttdoc">Graph - multilevel.</div><div class="ttdef"><b>Definition:</b> <a href="apfZoltan_8h_source.html#l00058">apfZoltan.h:58</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a43962b2ec3f0b13035fcdd6b605c0542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43962b2ec3f0b13035fcdd6b605c0542">&#9670;&nbsp;</a></span>ZoltanMethod</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceapf.html#a43962b2ec3f0b13035fcdd6b605c0542">apf::ZoltanMethod</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Zoltan partitioning method. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a43962b2ec3f0b13035fcdd6b605c0542a4a4bf3caf26566014c77301edef9645c"></a>RCB&#160;</td><td class="fielddoc"><p>Recursive Coordinate Bisection. </p>
</td></tr>
<tr><td class="fieldname"><a id="a43962b2ec3f0b13035fcdd6b605c0542a607255cecabcbb1b1ffabd23e131d83d"></a>RIB&#160;</td><td class="fielddoc"><p>Recursive Inertial Bisection. </p>
</td></tr>
<tr><td class="fieldname"><a id="a43962b2ec3f0b13035fcdd6b605c0542afd0f04e6c7f37704263c158f7cbb20e3"></a>HYPERGRAPH&#160;</td><td class="fielddoc"><p>Hyper-graph partitioning. </p>
</td></tr>
<tr><td class="fieldname"><a id="a43962b2ec3f0b13035fcdd6b605c0542aeb776aa18738bd7e607f65389a957e22"></a>PARMETIS&#160;</td><td class="fielddoc"><p>Use ParMetis. </p>
</td></tr>
<tr><td class="fieldname"><a id="a43962b2ec3f0b13035fcdd6b605c0542a7c9c0a487322ecba8b41d0331fbc5d1b"></a>GRAPH&#160;</td><td class="fielddoc"><p>General graph partitionig. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="apfZoltan_8h_source.html#l00036">36</a> of file <a class="el" href="apfZoltan_8h_source.html">apfZoltan.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;                  {</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;  <a class="code" href="namespaceapf.html#a43962b2ec3f0b13035fcdd6b605c0542a4a4bf3caf26566014c77301edef9645c">RCB</a>,</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;  <a class="code" href="namespaceapf.html#a43962b2ec3f0b13035fcdd6b605c0542a607255cecabcbb1b1ffabd23e131d83d">RIB</a>,</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;  <a class="code" href="namespaceapf.html#a43962b2ec3f0b13035fcdd6b605c0542afd0f04e6c7f37704263c158f7cbb20e3">HYPERGRAPH</a>,</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;  <a class="code" href="namespaceapf.html#a43962b2ec3f0b13035fcdd6b605c0542aeb776aa18738bd7e607f65389a957e22">PARMETIS</a>,</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;  <a class="code" href="namespaceapf.html#a43962b2ec3f0b13035fcdd6b605c0542a7c9c0a487322ecba8b41d0331fbc5d1b">GRAPH</a></div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;};</div>
<div class="ttc" id="anamespaceapf_html_a43962b2ec3f0b13035fcdd6b605c0542a4a4bf3caf26566014c77301edef9645c"><div class="ttname"><a href="namespaceapf.html#a43962b2ec3f0b13035fcdd6b605c0542a4a4bf3caf26566014c77301edef9645c">apf::RCB</a></div><div class="ttdeci">@ RCB</div><div class="ttdoc">Recursive Coordinate Bisection.</div><div class="ttdef"><b>Definition:</b> <a href="apfZoltan_8h_source.html#l00038">apfZoltan.h:38</a></div></div>
<div class="ttc" id="anamespaceapf_html_a43962b2ec3f0b13035fcdd6b605c0542a607255cecabcbb1b1ffabd23e131d83d"><div class="ttname"><a href="namespaceapf.html#a43962b2ec3f0b13035fcdd6b605c0542a607255cecabcbb1b1ffabd23e131d83d">apf::RIB</a></div><div class="ttdeci">@ RIB</div><div class="ttdoc">Recursive Inertial Bisection.</div><div class="ttdef"><b>Definition:</b> <a href="apfZoltan_8h_source.html#l00040">apfZoltan.h:40</a></div></div>
<div class="ttc" id="anamespaceapf_html_a43962b2ec3f0b13035fcdd6b605c0542a7c9c0a487322ecba8b41d0331fbc5d1b"><div class="ttname"><a href="namespaceapf.html#a43962b2ec3f0b13035fcdd6b605c0542a7c9c0a487322ecba8b41d0331fbc5d1b">apf::GRAPH</a></div><div class="ttdeci">@ GRAPH</div><div class="ttdoc">General graph partitionig.</div><div class="ttdef"><b>Definition:</b> <a href="apfZoltan_8h_source.html#l00047">apfZoltan.h:46</a></div></div>
<div class="ttc" id="anamespaceapf_html_a43962b2ec3f0b13035fcdd6b605c0542aeb776aa18738bd7e607f65389a957e22"><div class="ttname"><a href="namespaceapf.html#a43962b2ec3f0b13035fcdd6b605c0542aeb776aa18738bd7e607f65389a957e22">apf::PARMETIS</a></div><div class="ttdeci">@ PARMETIS</div><div class="ttdoc">Use ParMetis.</div><div class="ttdef"><b>Definition:</b> <a href="apfZoltan_8h_source.html#l00044">apfZoltan.h:44</a></div></div>
<div class="ttc" id="anamespaceapf_html_a43962b2ec3f0b13035fcdd6b605c0542afd0f04e6c7f37704263c158f7cbb20e3"><div class="ttname"><a href="namespaceapf.html#a43962b2ec3f0b13035fcdd6b605c0542afd0f04e6c7f37704263c158f7cbb20e3">apf::HYPERGRAPH</a></div><div class="ttdeci">@ HYPERGRAPH</div><div class="ttdoc">Hyper-graph partitioning.</div><div class="ttdef"><b>Definition:</b> <a href="apfZoltan_8h_source.html#l00042">apfZoltan.h:42</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ad3589c872e3d40b311a323832d506504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3589c872e3d40b311a323832d506504">&#9670;&nbsp;</a></span>accumulate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::accumulate </td>
          <td>(</td>
          <td class="paramtype">Field *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapf_1_1Sharing.html">Sharing</a> *&#160;</td>
          <td class="paramname"><em>shr</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>delete_shr</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add field values along partition boundary. </p>
<p>Using the copies described by an <a class="el" href="structapf_1_1Sharing.html" title="abstract description of entity copy sharing">apf::Sharing</a> object, add up the field values of all copies of an entity and assign the sum as the value for all copies. </p>

</div>
</div>
<a id="a69e9fca4a3ecfdfe3195624743b321e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69e9fca4a3ecfdfe3195624743b321e9">&#9670;&nbsp;</a></span>applyMatrixFunc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void apf::applyMatrixFunc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Matrix.html">Matrix</a>&lt; M, M &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double(*)(double)&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1Matrix.html">Matrix</a>&lt; M, M &gt; &amp;&#160;</td>
          <td class="paramname"><em>newMat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function applies a function to a symmetric tensor. Using the polar decomposition theorem. One example is taking the sqrt of a tensor </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>a square matrix </td></tr>
    <tr><td class="paramname">callback</td><td>a function pointer that takes a double and returns a double. This is the function that will be applied to the matrix. </td></tr>
    <tr><td class="paramname">newMat</td><td>a matrix that contains the results of the operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f4fbff831d4ad2f4a3b117eacbed9d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f4fbff831d4ad2f4a3b117eacbed9d3">&#9670;&nbsp;</a></span>assemble()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NewElements apf::assemble </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh2.html">Mesh2</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const apf::Gid *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nelem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>etype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceapf.html#ad41eed81404b62d897ea31da38a53f73">GlobalToVert</a> &amp;&#160;</td>
          <td class="paramname"><em>globalToVert</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>assemble a mixed-cell-type mesh from just a connectivity array </p>
<p>construct is now split into two functions, assemble and finalise. The premise of assemble being that it is called multiple times for a given cell type, across several different cell types in the input mesh. </p>

</div>
</div>
<a id="a7c09873de7fd7855f417e4f0cba10f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c09873de7fd7855f417e4f0cba10f2b">&#9670;&nbsp;</a></span>boundaryToElementXi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapf_1_1Vector3.html">Vector3</a> apf::boundaryToElementXi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshEntity *&#160;</td>
          <td class="paramname"><em>boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshEntity *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1Vector3.html">Vector3</a> const &amp;&#160;</td>
          <td class="paramname"><em>xi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reparameterize from boundary entity to element. </p>
<p>This function converts a point in the local parametric space of a boundary mesh entity into the equivalent point in the local parametric space of an adjacent element. </p>

</div>
</div>
<a id="ae4a6608901d851a5d760bef899ca8e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4a6608901d851a5d760bef899ca8e4a">&#9670;&nbsp;</a></span>buildElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MeshEntity* apf::buildElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh2.html">Mesh2</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ModelEntity *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshEntity **&#160;</td>
          <td class="paramname"><em>verts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1BuildCallback.html">BuildCallback</a> *&#160;</td>
          <td class="paramname"><em>cb</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>build an entity from its vertices </p>
<p>any missing intermediate entities will also be built, and all will be classified to (c). If a non-zero <a class="el" href="classapf_1_1BuildCallback.html" title="User-defined entity creation callback.">BuildCallback</a> pointer is given, it will be called for each entity created, including intermediate ones. </p>

</div>
</div>
<a id="aa44d7b4188599480d9ea5ae68139bb0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa44d7b4188599480d9ea5ae68139bb0f">&#9670;&nbsp;</a></span>buildOneElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MeshEntity* apf::buildOneElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh2.html">Mesh2</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ModelEntity *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1Vector3.html">Vector3</a> const *&#160;</td>
          <td class="paramname"><em>points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>build a one-element mesh </p>
<p>this is mostly useful for debugging </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>this doesn't get used much, maybe remove it </dd></dl>

</div>
</div>
<a id="aef521ab351092c61cef2f9b5fda28ddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef521ab351092c61cef2f9b5fda28ddd">&#9670;&nbsp;</a></span>changeMdsDimension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::changeMdsDimension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh2.html">Mesh2</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>change the dimension of an MDS mesh </p>
<p>this should be called before adding entities of dimension higher than the previous mesh dimension (when building a higher dimensional mesh from a lower one), or after removing all entities of higher dimension (when reducing a high dimensional mesh to a lower one) </p>

</div>
</div>
<a id="ac9676300a7af8a3996f04687fcd5074d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9676300a7af8a3996f04687fcd5074d">&#9670;&nbsp;</a></span>cloneField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Field* apf::cloneField </td>
          <td>(</td>
          <td class="paramtype">Field *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">Mesh</a> *&#160;</td>
          <td class="paramname"><em>onto</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declare a copy of a field on another <a class="el" href="classapf_1_1Mesh.html" title="Interface to a mesh part.">apf::Mesh</a>. </p>
<p>This will just make a Field object with the same properties, but not fill in any data. </p>

</div>
</div>
<a id="a8887da228f381495b0fc64e1ed05ef7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8887da228f381495b0fc64e1ed05ef7f">&#9670;&nbsp;</a></span>computeCosAngle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apf::computeCosAngle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshEntity *&#160;</td>
          <td class="paramname"><em>pe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshEntity *&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshEntity *&#160;</td>
          <td class="paramname"><em>e2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapf_1_1Matrix3x3.html">Matrix3x3</a> &amp;&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the cosine of the angle between 2 entities of the parent entity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>mesh </td></tr>
    <tr><td class="paramname">pe</td><td>parent entity </td></tr>
    <tr><td class="paramname">e1</td><td>first entity </td></tr>
    <tr><td class="paramname">e2</td><td>second entity </td></tr>
    <tr><td class="paramname">Q</td><td>metric</td></tr>
  </table>
  </dd>
</dl>
<p>All the angles are computed based on the Jacobian, and therefore, this function will work for curved elements as well. For anisotropic meshes the user can provide Q (he metric value of the parent) to get the angles in the metric space. Otherwise and Identity matrix must be given for Q. </p>

</div>
</div>
<a id="af7a032b8f4e5af4f9fb95280ed8ab82e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7a032b8f4e5af4f9fb95280ed8ab82e">&#9670;&nbsp;</a></span>computeLargestHeightInTet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apf::computeLargestHeightInTet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshEntity *&#160;</td>
          <td class="paramname"><em>tet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapf_1_1Matrix3x3.html">Matrix3x3</a> &amp;&#160;</td>
          <td class="paramname"><em>Q</em> = <code><a class="el" href="classapf_1_1Matrix3x3.html">Matrix3x3</a>(1.,&#160;0.,&#160;0.,&#160;0.,&#160;1.,&#160;0.,&#160;0.,&#160;0.,&#160;1.)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the largest height in a tet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>mesh </td></tr>
    <tr><td class="paramname">tet</td><td>tet </td></tr>
    <tr><td class="paramname">Q</td><td>metric (default Identity) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a248ed46bc77893a76e2ad1865d4a58c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a248ed46bc77893a76e2ad1865d4a58c8">&#9670;&nbsp;</a></span>computeLargestHeightInTri()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apf::computeLargestHeightInTri </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshEntity *&#160;</td>
          <td class="paramname"><em>tri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapf_1_1Matrix3x3.html">Matrix3x3</a> &amp;&#160;</td>
          <td class="paramname"><em>Q</em> = <code><a class="el" href="classapf_1_1Matrix3x3.html">Matrix3x3</a>(1.,&#160;0.,&#160;0.,&#160;0.,&#160;1.,&#160;0.,&#160;0.,&#160;0.,&#160;1.)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the largest height in a tri. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>mesh </td></tr>
    <tr><td class="paramname">tri</td><td>tri </td></tr>
    <tr><td class="paramname">Q</td><td>metric (default Identity) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc17aa58ccf7f217ac613b31641a8848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc17aa58ccf7f217ac613b31641a8848">&#9670;&nbsp;</a></span>computeShortestHeightInTet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apf::computeShortestHeightInTet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshEntity *&#160;</td>
          <td class="paramname"><em>tet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapf_1_1Matrix3x3.html">Matrix3x3</a> &amp;&#160;</td>
          <td class="paramname"><em>Q</em> = <code><a class="el" href="classapf_1_1Matrix3x3.html">Matrix3x3</a>(1.,&#160;0.,&#160;0.,&#160;0.,&#160;1.,&#160;0.,&#160;0.,&#160;0.,&#160;1.)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the shortest height in a tet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>mesh </td></tr>
    <tr><td class="paramname">tet</td><td>tet </td></tr>
    <tr><td class="paramname">Q</td><td>metric (default Identity) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c65bc4f2bd7ca1cd97010263bd6d01a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c65bc4f2bd7ca1cd97010263bd6d01a">&#9670;&nbsp;</a></span>computeShortestHeightInTri()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apf::computeShortestHeightInTri </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshEntity *&#160;</td>
          <td class="paramname"><em>tri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapf_1_1Matrix3x3.html">Matrix3x3</a> &amp;&#160;</td>
          <td class="paramname"><em>Q</em> = <code><a class="el" href="classapf_1_1Matrix3x3.html">Matrix3x3</a>(1.,&#160;0.,&#160;0.,&#160;0.,&#160;1.,&#160;0.,&#160;0.,&#160;0.,&#160;1.)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the shortest height in a tri. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>mesh </td></tr>
    <tr><td class="paramname">tri</td><td>tri </td></tr>
    <tr><td class="paramname">Q</td><td>metric (default Identity) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d01fdd080194c513506232443f98d74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d01fdd080194c513506232443f98d74">&#9670;&nbsp;</a></span>construct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NewElements apf::construct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh2.html">Mesh2</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const apf::Gid *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nelem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>etype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceapf.html#ad41eed81404b62d897ea31da38a53f73">GlobalToVert</a> &amp;&#160;</td>
          <td class="paramname"><em>globalToVert</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>construct a mesh from just a connectivity array </p>
<p>this function is here to interface with very simple mesh formats. Given a set of elements described only in terms of the ordered global ids of their vertices, this function builds a reasonable <a class="el" href="classapf_1_1Mesh2.html" title="Extended mesh interface for modification.">apf::Mesh2</a> structure and as a side effect returns a map from global ids to local vertices. This functions assumes a uniform cell type. Use a combination of assemble and finalise for meshes loaded with mixed cell types.</p>
<p>This is a fully scalable parallel mesh construction algorithm, no processor incurs memory or runtime costs proportional to the global mesh size.</p>
<p>Note that all vertices will have zero coordinates, so it is often good to use <a class="el" href="namespaceapf.html#a3fe3657e4785a44df6b3a822895a004a" title="Assign coordinates to the mesh.">apf::setCoords</a> after this. </p>

</div>
</div>
<a id="a6d0d84a601f50e97c8d308d7bbff107f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d0d84a601f50e97c8d308d7bbff107f">&#9670;&nbsp;</a></span>convert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::convert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">Mesh</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh2.html">Mesh2</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshEntity **&#160;</td>
          <td class="paramname"><em>nodes</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshEntity **&#160;</td>
          <td class="paramname"><em>elems</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy_data</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert one mesh data structure to another </p>
<p>this function will fill in a structure that fully implements <a class="el" href="classapf_1_1Mesh2.html" title="Extended mesh interface for modification.">apf::Mesh2</a> by using information from an implementation of <a class="el" href="classapf_1_1Mesh.html" title="Interface to a mesh part.">apf::Mesh</a>. This is a fully scalable parallel mesh conversion tool. </p>

</div>
</div>
<a id="ae79d0f88cd75286949baaa4813e7c35f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae79d0f88cd75286949baaa4813e7c35f">&#9670;&nbsp;</a></span>countElementNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int apf::countElementNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1FieldShape.html">FieldShape</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>count the number of nodes affecting an element type </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>select from <a class="el" href="classapf_1_1Mesh.html#a68729141a3c5781a24bb72ea6160b898" title="Entity topological types.">apf::Mesh::Type</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a8c7a2a41b08310447cc121097cb983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a8c7a2a41b08310447cc121097cb983">&#9670;&nbsp;</a></span>countIntPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int apf::countIntPoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceapf.html#a2432d4261391eda474007fb25c097a5c">MeshElement</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of integration points for an element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>the polynomial order of accuracy desired for the integration (not to be confused with the polynomial order of shape functions). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00ef08c6cf2af320e8346bd3abb3e2cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00ef08c6cf2af320e8346bd3abb3e2cb">&#9670;&nbsp;</a></span>countNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int apf::countNodes </td>
          <td>(</td>
          <td class="paramtype">Element *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of element nodes. </p>
<p>This is the number of nodes affecting an element, as opposed to the nodes tagged to an entity. </p>

</div>
</div>
<a id="aee6038584427e88583e5c9749ddc3384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee6038584427e88583e5c9749ddc3384">&#9670;&nbsp;</a></span>createElement() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Element* apf::createElement </td>
          <td>(</td>
          <td class="paramtype">Field *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceapf.html#a2432d4261391eda474007fb25c097a5c">MeshElement</a> *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a Field Element from a <a class="el" href="classapf_1_1Mesh.html" title="Interface to a mesh part.">Mesh</a> Element. </p>
<p>A Field Element object caches elemental data for use in evaluation, mapping, and integration. use destroyElement to free this data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The field which the Element will represent </td></tr>
    <tr><td class="paramname">e</td><td>An existing MeshElement for the desired entity </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new field Element </dd></dl>

</div>
</div>
<a id="a5dd3f44db9edac67c1976e25a6c06219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dd3f44db9edac67c1976e25a6c06219">&#9670;&nbsp;</a></span>createElement() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Element* apf::createElement </td>
          <td>(</td>
          <td class="paramtype">Field *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshEntity *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a Field Element without a parent <a class="el" href="classapf_1_1Mesh.html" title="Interface to a mesh part.">Mesh</a> Element. </p>
<p>Warning: most users should call the version which takes a MeshElement as input. Only call this function if you know the other one isn't right for you. </p>

</div>
</div>
<a id="a47f1b3e0b0e1d3a287c98b062a66b54d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47f1b3e0b0e1d3a287c98b062a66b54d">&#9670;&nbsp;</a></span>createGlobalNumbering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceapf.html#a691865cc4ddfa6781e8aba4e338617e8">GlobalNumbering</a>* apf::createGlobalNumbering </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">Mesh</a> *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1FieldShape.html">FieldShape</a> *&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>components</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create global numbering </p>
<p>see <a class="el" href="namespaceapf.html#a55068a766b0d6e1c63432c621af73bca" title="Create a Numbering of degrees of freedom of a Field.">apf::createNumbering</a>. so far global numberings have one component </p>

</div>
</div>
<a id="a88ed69b0b7d444f1e2e16609a74b5393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88ed69b0b7d444f1e2e16609a74b5393">&#9670;&nbsp;</a></span>createIPField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Field* apf::createIPField </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>valueType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an apf::Field of integration point data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the mesh over which the field is defined </td></tr>
    <tr><td class="paramname">name</td><td>a unique name for this field </td></tr>
    <tr><td class="paramname">valueType</td><td>the type of field data </td></tr>
    <tr><td class="paramname">order</td><td>polynomial order of accuracy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a400d78f4f15ca30f6777e5c7c914d21e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a400d78f4f15ca30f6777e5c7c914d21e">&#9670;&nbsp;</a></span>createLagrangeField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Field* apf::createLagrangeField </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>valueType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an apf::Field using a Lagrange distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the mesh over which the field is defined </td></tr>
    <tr><td class="paramname">name</td><td>a unique name for this field </td></tr>
    <tr><td class="paramname">valueType</td><td>the type of field data </td></tr>
    <tr><td class="paramname">order</td><td>the polynomial order of the shape functions (so far 1 or 2) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ca78ad6a2b3ef8f32c9e49638f1e38c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ca78ad6a2b3ef8f32c9e49638f1e38c">&#9670;&nbsp;</a></span>createMdsMesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapf_1_1Mesh2.html">Mesh2</a>* apf::createMdsMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgmi__model.html">gmi_model</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">Mesh</a> *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reorder</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy_data</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create an MDS mesh from an existing mesh </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the mesh to copy </td></tr>
    <tr><td class="paramname">reorder</td><td>if true reorder mesh vertices and elements (start from a vertex with minimum Y) </td></tr>
    <tr><td class="paramname">copy_data</td><td>if true (default), copy Fields/Numberings/Tags</td></tr>
  </table>
  </dd>
</dl>
<p>this function uses <a class="el" href="namespaceapf.html#a6d0d84a601f50e97c8d308d7bbff107f" title="convert one mesh data structure to another">apf::convert</a> to copy any <a class="el" href="classapf_1_1Mesh.html" title="Interface to a mesh part.">apf::Mesh</a> </p>

</div>
</div>
<a id="af0e7a0817a30581f2975260e84155951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0e7a0817a30581f2975260e84155951">&#9670;&nbsp;</a></span>createMeshElement() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceapf.html#a2432d4261391eda474007fb25c097a5c">MeshElement</a>* apf::createMeshElement </td>
          <td>(</td>
          <td class="paramtype">Field *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshEntity *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a non-standard <a class="el" href="classapf_1_1Mesh.html" title="Interface to a mesh part.">Mesh</a> Element over an entity. </p>
<p>Warning: most users should use the above function unless you know this is the right one for you. This function is useful for creating a mesh element over a coordinate field c that may be distinct from the mesh's underlying coordinate field. This may be useful for updated-Lagrangian simulations, where quantities must be computed on reference and updated configurations. </p>

</div>
</div>
<a id="ace5f1b3f0de2895610b4baab76a8d43a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace5f1b3f0de2895610b4baab76a8d43a">&#9670;&nbsp;</a></span>createMeshElement() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceapf.html#a2432d4261391eda474007fb25c097a5c">MeshElement</a>* apf::createMeshElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshEntity *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classapf_1_1Mesh.html" title="Interface to a mesh part.">Mesh</a> Element over an entity. </p>
<p>A <a class="el" href="classapf_1_1Mesh.html" title="Interface to a mesh part.">Mesh</a> Element allows queries to the coordinate field, including mapping, differential and total volume, as well as gauss integration point data. A <a class="el" href="classapf_1_1Mesh.html" title="Interface to a mesh part.">Mesh</a> Element is also required to build a Field Element. </p>

</div>
</div>
<a id="a587984a40675f8c24d83dd4462a89023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a587984a40675f8c24d83dd4462a89023">&#9670;&nbsp;</a></span>createNumbering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceapf.html#a662a796b32a9173981bfc6e1ebe60ba1">Numbering</a>* apf::createNumbering </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">Mesh</a> *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1FieldShape.html">FieldShape</a> *&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>components</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a generally-defined Numbering. </p>
<p>This numbering will be available via mesh-&gt;findNumbering, etc. The shape determines where the nodes are, and the component count determines how many integers there are per node. </p>

</div>
</div>
<a id="a4b88a075efe41bae69973e6b7ae26a01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b88a075efe41bae69973e6b7ae26a01">&#9670;&nbsp;</a></span>createPackedField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Field* apf::createPackedField </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>components</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1FieldShape.html">apf::FieldShape</a> *&#160;</td>
          <td class="paramname"><em>shape</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a field of N components without a tensor type. </p>
<p>Packed fields are used to interface with applications whose fields are not easily categorized as tensors of order 0,1,2. They contain enough information to interpolate values in an element and such, but some higher-level functionality is left out. </p>

</div>
</div>
<a id="a038c413eb37a461bd7f45a46d9c6d2cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a038c413eb37a461bd7f45a46d9c6d2cf">&#9670;&nbsp;</a></span>createStepField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Field* apf::createStepField </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>valueType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an apf::Field using a step distribution. </p>
<p>A step-wise distribution is a C-1 continuous field defined by one node at each element, with the field value being constant over the element and discontinuous at element boundaries</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the mesh over which the field is defined </td></tr>
    <tr><td class="paramname">name</td><td>a unique name for this field </td></tr>
    <tr><td class="paramname">valueType</td><td>the type of field data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa6361743deaa5515a0ad17f70a15424c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6361743deaa5515a0ad17f70a15424c">&#9670;&nbsp;</a></span>derive2DMdlFromManifold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::derive2DMdlFromManifold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh2.html">Mesh2</a> *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>isModelVert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nBEdges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)&#160;</td>
          <td class="paramname"><em>bEdges</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceapf.html#ad41eed81404b62d897ea31da38a53f73">GlobalToVert</a> &amp;&#160;</td>
          <td class="paramname"><em>globalToVert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; int, apf::MeshEntity * &gt; &amp;&#160;</td>
          <td class="paramname"><em>globalToFace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the mesh vertices that are also model vertices, and the classification on boundary mesh edges, constructs the classification on the rest of the boundary entities for a 2-D mesh. </p>
<p>Only for triangular mesh with single model region. The tags provided for edge classification are treated as reserved, and all newly generated tags are distinct regardless of dimension. It is assumed that both mesh vertices are indexed from 0 to (n_verts - 1) and mesh faces from 0 to (n_faces -1).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The mesh in consideration </td></tr>
    <tr><td class="paramname">isModelVert</td><td>Array of bools, one per mesh vertex, telling if that vertex is also a model vertex </td></tr>
    <tr><td class="paramname">nBEdges</td><td>number of boundary faces </td></tr>
    <tr><td class="paramname">bEdges</td><td>2D Array of size (nBEdges x 4). For each face, the row is [model_edge_tag, adj_face_tag, global_vtx_id_1, global_vtx_id_2] </td></tr>
    <tr><td class="paramname">globalToVert</td><td>Maps mesh vertex ID to the mesh vertex. Typically output from <a class="el" href="namespaceapf.html#a5d01fdd080194c513506232443f98d74" title="construct a mesh from just a connectivity array">apf::construct</a> </td></tr>
    <tr><td class="paramname">globalToFace</td><td>Maps mesh face ID to the mesh face </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a80f03eb0ab471313994a3cc12910e513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80f03eb0ab471313994a3cc12910e513">&#9670;&nbsp;</a></span>deriveMdlFromManifold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::deriveMdlFromManifold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh2.html">Mesh2</a> *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>isModelVert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nBFaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)&#160;</td>
          <td class="paramname"><em>bFaces</em>[5], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceapf.html#ad41eed81404b62d897ea31da38a53f73">GlobalToVert</a> &amp;&#160;</td>
          <td class="paramname"><em>globalToVert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; int, apf::MeshEntity * &gt; &amp;&#160;</td>
          <td class="paramname"><em>globalToRegion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the mesh vertices that are also model vertices, and the classification on boundary mesh faces, constructs the classification on the rest of the boundary entities. </p>
<p>Only for tetrahedral mesh with single model region. The tags provided for face classification are treated as reserved, and all newly generated tags are distinct regardless of dimension. It is assumed that the mesh was created using <a class="el" href="namespaceapf.html#a5d01fdd080194c513506232443f98d74" title="construct a mesh from just a connectivity array">apf::construct</a>, which by default assigns a tag 0 to the model region. Due to this, it is advised to provide face tags starting from 1 if uniqueness is desired. It is assumed that both mesh vertices are indexed from 0 to (n_verts - 1) and mesh regions from 0 to (n_regions -1).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The mesh in consideration </td></tr>
    <tr><td class="paramname">isModelVert</td><td>Array of bools, one per mesh vertex, telling if that vertex is also a model vertex </td></tr>
    <tr><td class="paramname">nBFaces</td><td>number of boundary faces </td></tr>
    <tr><td class="paramname">bFaces</td><td>2D Array of size (n_bfaces x 5). For each face, the row is [model_face_tag, adj_region_tag, global_vtx_id_1, global_vtx_id_2, global_vtx_id_3] </td></tr>
    <tr><td class="paramname">globalToVert</td><td>Maps mesh vertex ID to the mesh vertex. Typically output from <a class="el" href="namespaceapf.html#a5d01fdd080194c513506232443f98d74" title="construct a mesh from just a connectivity array">apf::construct</a> </td></tr>
    <tr><td class="paramname">globalToRegion</td><td>Maps mesh region ID to the mesh region </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a619beb8ada85832d9bb604a0ca7ae865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619beb8ada85832d9bb604a0ca7ae865">&#9670;&nbsp;</a></span>deriveMdsModel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::deriveMdsModel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh2.html">Mesh2</a> *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>build a null model such that <a class="el" href="namespaceapf.html#aacc951388f86b0fcce7a428905d09203" title="run consistency checks on an apf::Mesh structure">apf::verify</a> accepts the mesh. </p>
<p>given an MDS mesh that is (wrongly) classified on a null model, this algorithm will classify all interior entities onto a model region and all boundary entities onto a boundary model entity, as defined by mesh upward adjacencies. </p>

</div>
</div>
<a id="a2b79d22c97ba66e7c5b483b864dd7124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b79d22c97ba66e7c5b483b864dd7124">&#9670;&nbsp;</a></span>destroyField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::destroyField </td>
          <td>(</td>
          <td class="paramtype">Field *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy an apf::Field. </p>
<p>This function will also remove any field data that this field attached to its <a class="el" href="classapf_1_1Mesh.html" title="Interface to a mesh part.">Mesh</a> domain. </p>

</div>
</div>
<a id="a7bda3647cf835f66149ed06cb7df16e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bda3647cf835f66149ed06cb7df16e3">&#9670;&nbsp;</a></span>destroyMesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::destroyMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys an <a class="el" href="classapf_1_1Mesh.html" title="Interface to a mesh part.">apf::Mesh</a>. </p>
<p>This only destroys the <a class="el" href="classapf_1_1Mesh.html" title="Interface to a mesh part.">apf::Mesh</a> object, the underlying mesh database is unaffected. <a class="el" href="classapf_1_1Mesh.html" title="Interface to a mesh part.">Mesh</a> objects are wrappers over mesh databases, and are created by functions provided outside the APF core. </p>

</div>
</div>
<a id="aaae2bd20b6108fe74ce8ab1442883aee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaae2bd20b6108fe74ce8ab1442883aee">&#9670;&nbsp;</a></span>destroyMeshElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::destroyMeshElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceapf.html#a2432d4261391eda474007fb25c097a5c">MeshElement</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys a <a class="el" href="classapf_1_1Mesh.html" title="Interface to a mesh part.">Mesh</a> Element. </p>
<p>This only destroys the <a class="el" href="namespaceapf.html#a2432d4261391eda474007fb25c097a5c" title="Mesh Elements represent the mesh coordinate vector field.">apf::MeshElement</a> object, the underlying mesh entity and field data are unaffected. </p>

</div>
</div>
<a id="af40263f043f08164b5e83e672db2ad16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af40263f043f08164b5e83e672db2ad16">&#9670;&nbsp;</a></span>destruct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::destruct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh2.html">Mesh2</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Gid *&amp;&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>nelem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>etype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cellDim</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert an <a class="el" href="classapf_1_1Mesh2.html" title="Extended mesh interface for modification.">apf::Mesh2</a> object into a connectivity array </p>
<p>this is useful for debugging the <a class="el" href="namespaceapf.html#a6d0d84a601f50e97c8d308d7bbff107f" title="convert one mesh data structure to another">apf::convert</a> function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>the apf mesh </td></tr>
    <tr><td class="paramname">nelem</td><td>number of elements </td></tr>
    <tr><td class="paramname">etype</td><td><a class="el" href="classapf_1_1Mesh.html#a68729141a3c5781a24bb72ea6160b898" title="Entity topological types.">apf::Mesh::Type</a> </td></tr>
    <tr><td class="paramname">cellDim</td><td>dimension of elements (if embedded in a higher dimension manifold) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f5fee4fb7d38918b96a0f19645d9009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f5fee4fb7d38918b96a0f19645d9009">&#9670;&nbsp;</a></span>displaceMesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::displaceMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh2.html">Mesh2</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Field *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>factor</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>add a field (times a factor) to the mesh coordinates </p>
<p>this is useful in mechanical deformation problems to transform the mesh from reference space to deformed space. Setting the factor to -1 will undo the deformation </p>

</div>
</div>
<a id="a16d57b8d5abcb3ef2021517560105875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16d57b8d5abcb3ef2021517560105875">&#9670;&nbsp;</a></span>extractCoords()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::extractCoords </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh2.html">Mesh2</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&amp;&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>nverts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get a contiguous set of global vertex coordinates </p>
<p>this is used for debugging <a class="el" href="namespaceapf.html#a3fe3657e4785a44df6b3a822895a004a" title="Assign coordinates to the mesh.">apf::setCoords</a> </p>

</div>
</div>
<a id="a52e25204d8a3b5dfe0c240afee898c93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52e25204d8a3b5dfe0c240afee898c93">&#9670;&nbsp;</a></span>fail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::fail </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>why</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declare failure of code inside APF. </p>
<p>This function prints the string as an APF failure to stderr and then calls abort. It can be called from code that is part of the apf namespace, but not outside of that. </p>

</div>
</div>
<a id="a1c249034dbd85eaa1c944a6731815fcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c249034dbd85eaa1c944a6731815fcd">&#9670;&nbsp;</a></span>finalise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::finalise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh2.html">Mesh2</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceapf.html#ad41eed81404b62d897ea31da38a53f73">GlobalToVert</a> &amp;&#160;</td>
          <td class="paramname"><em>globalToVert</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finalise construction of a mixed-cell-type mesh from just a connectivity array </p>
<p>construct is now split into two functions, assemble and finalise. Once the mixed cell type mesh is assembled finalise should be called. Doing it this way provides non-breaking changes for current users of construct, which now just calls assemble and finalise. </p>

</div>
</div>
<a id="ab82dd4758b562097e461aaec287ce951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab82dd4758b562097e461aaec287ce951">&#9670;&nbsp;</a></span>findIn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int apf::findIn </td>
          <td>(</td>
          <td class="paramtype">MeshEntity **&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshEntity *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find pointer (e) in array (a) of length (n) </p>
<dl class="section return"><dt>Returns</dt><dd>-1 if not found, otherwise i such that a[i] = e </dd></dl>

</div>
</div>
<a id="af07afd339271516b1bb2f41e65c236ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af07afd339271516b1bb2f41e65c236ea">&#9670;&nbsp;</a></span>findTriDown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::findTriDown </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshEntity **&#160;</td>
          <td class="paramname"><em>verts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshEntity **&#160;</td>
          <td class="paramname"><em>down</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>given the vertices of a triangle, find its edges </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">down</td><td>the resulting array of edges </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9247929491b6b16ca6eb2278c2829d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9247929491b6b16ca6eb2278c2829d5">&#9670;&nbsp;</a></span>findUpward()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MeshEntity* apf::findUpward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshEntity **&#160;</td>
          <td class="paramname"><em>down</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find an entity from one-level downward adjacencies </p>
<p>this function ignores the ordering of adjacent entities </p>

</div>
</div>
<a id="a46b2bad33dc710bf0713c236478d5696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46b2bad33dc710bf0713c236478d5696">&#9670;&nbsp;</a></span>fix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::fix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceapf.html#a662a796b32a9173981bfc6e1ebe60ba1">Numbering</a> *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshEntity *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fixed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the fixed/free status of a degree of freedom,. </p>
<p>must be called prior to making any <a class="el" href="namespaceapf.html#a7701171312e7a66287b45237c1505ba0" title="Check whether a degree of freedom is fixed.">isFixed()</a> calls on the same node/component.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the numbering object </td></tr>
    <tr><td class="paramname">e</td><td>the mesh entity with which the node is associated </td></tr>
    <tr><td class="paramname">node</td><td>the node number withing the mesh entity </td></tr>
    <tr><td class="paramname">component</td><td>the component number within the nodal tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b920221a1bd88d90b9d512aef30d7ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b920221a1bd88d90b9d512aef30d7ec">&#9670;&nbsp;</a></span>freezeFields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::freezeFields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>freeze all associated fields </p>
<p>see apf::freezeField </p>

</div>
</div>
<a id="ab906004ed9cb128d518f3278aeb99768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab906004ed9cb128d518f3278aeb99768">&#9670;&nbsp;</a></span>getAlignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::getAlignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshEntity *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshEntity *&#160;</td>
          <td class="paramname"><em>boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>which</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>flip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>rotate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>boundary entity alignment to an element </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the mesh </td></tr>
    <tr><td class="paramname">elem</td><td>the element </td></tr>
    <tr><td class="paramname">boundary</td><td>an entity on the boundary of elem </td></tr>
    <tr><td class="paramname">which</td><td>index of (boundary) in getDownward((elem)...) </td></tr>
    <tr><td class="paramname">flip</td><td>true iff orientation of (boundary) is opposite canonical </td></tr>
    <tr><td class="paramname">rotate</td><td>position of canonical vertex 0 in boundary vertices, or in boundary vertices reversed if (flip)==true </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45e9d9ae4647ae4737de0b05368b7ffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45e9d9ae4647ae4737de0b05368b7ffe">&#9670;&nbsp;</a></span>getArrayData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double* apf::getArrayData </td>
          <td>(</td>
          <td class="paramtype">Field *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the contiguous array storing this field. </p>
<p>This function is only defined for fields which are using array storage, for which <a class="el" href="namespaceapf.html#aff7f9dd09ed235feecd3372b1dc0be0e" title="Returns true iff the Field uses array storage.">apf::isFrozen</a> returns true. </p>

</div>
</div>
<a id="afa0d6ff54687a13a7a3e54e9885697ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa0d6ff54687a13a7a3e54e9885697ea">&#9670;&nbsp;</a></span>getBF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::getBF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1FieldShape.html">FieldShape</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceapf.html#a2432d4261391eda474007fb25c097a5c">MeshElement</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1Vector3.html">Vector3</a> const &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NewArray&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>BF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the basis functions over a mesh element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the field shape that defines the basis functions </td></tr>
    <tr><td class="paramname">e</td><td>the mesh element over which the basis functions are defined </td></tr>
    <tr><td class="paramname">p</td><td>the local coordinates at which the basis functions are evaluated </td></tr>
    <tr><td class="paramname">BF</td><td>nodal array of basis functions evaluated at p </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c90a5e449bf1b4d8ea66f674f9fbcbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c90a5e449bf1b4d8ea66f674f9fbcbe">&#9670;&nbsp;</a></span>getCofactor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t M, std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double apf::getCofactor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Matrix.html">Matrix</a>&lt; M, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the cofactor associated with entry (i,j) of matrix A </p>
<p>this is only instantiated for square matrices up to 4 by 4 </p>

</div>
</div>
<a id="a3a28f381daa5e2b9d2509a53340cec5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a28f381daa5e2b9d2509a53340cec5d">&#9670;&nbsp;</a></span>getComponents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::getComponents </td>
          <td>(</td>
          <td class="paramtype">Field *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshEntity *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>components</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structapf_1_1Copy.html" title="a reference to an object representing the same entity">Copy</a> the nodal value into an array of component values. </p>
<p>the output array must already be allocated, <a class="el" href="namespaceapf.html#a0bce38caf1b20620595d9d064a83e2ac" title="Count the number of scalar components in the field&#39;s value type.">apf::countComponents</a> can help with this. </p>

</div>
</div>
<a id="ae247d84abe28de29cdf1b8cd16184e60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae247d84abe28de29cdf1b8cd16184e60">&#9670;&nbsp;</a></span>getConstant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapf_1_1FieldShape.html">FieldShape</a>* apf::getConstant </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimension</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Constant shape function over some dimension. </p>
<p>this pseudo-shape function places a node on every element of the given dimension. Dimensions up to 3 are available </p>

</div>
</div>
<a id="a3171054c0ff9a4e155911ec832de7bb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3171054c0ff9a4e155911ec832de7bb6">&#9670;&nbsp;</a></span>getCurl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::getCurl </td>
          <td>(</td>
          <td class="paramtype">Element *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1Vector3.html">Vector3</a> const &amp;&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1Vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>curl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the curl of a vector field at a point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>The local coordinates in the element. </td></tr>
    <tr><td class="paramname">curl</td><td>The curl vector at that point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad139a15b35e66fec23d5c110789ccb45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad139a15b35e66fec23d5c110789ccb45">&#9670;&nbsp;</a></span>getCurlShapeValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::getCurlShapeValues </td>
          <td>(</td>
          <td class="paramtype">Element *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1Vector3.html">Vector3</a> const &amp;&#160;</td>
          <td class="paramname"><em>local</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NewArray&lt; <a class="el" href="classapf_1_1Vector3.html">Vector3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the vector curl shape function values at a point. </p>
<p>used only for Nedelec shapes (Piola transformation used to map from parent to physical coordinates) </p>

</div>
</div>
<a id="a8e2654c14a6dbcfa539c1dd273f06a6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e2654c14a6dbcfa539c1dd273f06a6c">&#9670;&nbsp;</a></span>getDeterminant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t M, std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double apf::getDeterminant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Matrix.html">Matrix</a>&lt; M, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the determinant of a matrix A </p>
<p>this is only instantiated for square matrices up to 4 by 4 </p>

</div>
</div>
<a id="a10b73ca5b7cf048976a69a0178fe52d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10b73ca5b7cf048976a69a0178fe52d1">&#9670;&nbsp;</a></span>getDiv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apf::getDiv </td>
          <td>(</td>
          <td class="paramtype">Element *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1Vector3.html">Vector3</a> const &amp;&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the divergence of a vector field at a point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>The local coordinates in the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The divergence at that point. </dd></dl>

</div>
</div>
<a id="ae4287cd7f923a63c1382ad30fd0507e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4287cd7f923a63c1382ad30fd0507e4">&#9670;&nbsp;</a></span>getDV()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apf::getDV </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceapf.html#a2432d4261391eda474007fb25c097a5c">MeshElement</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1Vector3.html">Vector3</a> const &amp;&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the differential volume at a point. </p>
<p>This function is meant to provide the differential measure of an element at a point, based on the Jacobian determinant in the case of regions, and equivalent terms for lower dimensions.</p>
<dl class="section return"><dt>Returns</dt><dd>The differential volume </dd></dl>

</div>
</div>
<a id="a0670f7ef62be57864c080ace1aa780be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0670f7ef62be57864c080ace1aa780be">&#9670;&nbsp;</a></span>getElementNodeXis() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::getElementNodeXis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1FieldShape.html">FieldShape</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apf::NewArray&lt; <a class="el" href="classapf_1_1Vector3.html">apf::Vector3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>xis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets the xi coordinates for all the nodes </p>
<p>order follows canonical notation. See tables apf::Mesh::tri_edge_verts, apf::Mesh::tet_edge_verts, and apf::Mesh::tet_tri_verts </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>select from <a class="el" href="classapf_1_1Mesh.html#a68729141a3c5781a24bb72ea6160b898" title="Entity topological types.">apf::Mesh::Type</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab67fb608f9d0cd79029539c7054152cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab67fb608f9d0cd79029539c7054152cc">&#9670;&nbsp;</a></span>getElementNodeXis() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::getElementNodeXis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1FieldShape.html">FieldShape</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshEntity *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apf::NewArray&lt; <a class="el" href="classapf_1_1Vector3.html">apf::Vector3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>xis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets the xi coordinates for all the nodes </p>
<p>order follows downward adjacency and global directions for the bounding entities. xi coordinates will be with respect to the entity e </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>select from <a class="el" href="classapf_1_1Mesh.html#a68729141a3c5781a24bb72ea6160b898" title="Entity topological types.">apf::Mesh::Type</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58876c2d1a1f92d6ce3b46c4c0ba8583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58876c2d1a1f92d6ce3b46c4c0ba8583">&#9670;&nbsp;</a></span>getElementNumbers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int apf::getElementNumbers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceapf.html#a662a796b32a9173981bfc6e1ebe60ba1">Numbering</a> *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshEntity *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NewArray&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>numbers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the node numbers of an element </p>
<p>numbers are returned in the standard element node ordering for its shape functions </p><dl class="section return"><dt>Returns</dt><dd>the number of element nodes </dd></dl>

</div>
</div>
<a id="a674978bde719b096c97b16c7f0f134ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a674978bde719b096c97b16c7f0f134ba">&#9670;&nbsp;</a></span>getElementToElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* apf::getElementToElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">apf::Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an element-to-element connectivity array. </p>
<p>this function assumes the mesh has one element type. the resulting array is created with new int[nelements * nsides]. nsides is the number of faces of an element. entry [i * nsides + j] is the global id of the j'th adjacent element to local element i, which can be -1 for a geometric boundary. </p>

</div>
</div>
<a id="a7c9bbae38d369d4419755dbece22e116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c9bbae38d369d4419755dbece22e116">&#9670;&nbsp;</a></span>getFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapf_1_1Matrix3x3.html">Matrix3x3</a> apf::getFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Vector3.html">Vector3</a> const &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>derive an orthogonal frame whose x axis is the given vector </p>
<p>this is a robust algorithm for choosing an arbitrary frame that is aligned with a given vector while avoiding the numerical issues that arise when the vector is near global axes.</p>
<p>Note, however, that the resulting frame is not normalized. some uses of this function require that the x basis vector be exactly the input, so that is the default behavior. It is the user's responsibility to normalize the result if desired </p>

</div>
</div>
<a id="a3c2f5179943d09291029e91ecdbed6d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c2f5179943d09291029e91ecdbed6d5">&#9670;&nbsp;</a></span>getGaussPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::getGaussPoint </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1Vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the location of a gaussian integration point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the element type, from <a class="el" href="classapf_1_1Mesh.html#addcf9a8b1544e71eb15c6d9a695d672d" title="Get the topological type of a mesh entity.">apf::Mesh::getType</a> </td></tr>
    <tr><td class="paramname">order</td><td>the order of the integration rule </td></tr>
    <tr><td class="paramname">point</td><td>which point of the integration rule </td></tr>
    <tr><td class="paramname">param</td><td>the resulting parent element coordinates </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74d7e9574a568fa957b61cf403a53e10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74d7e9574a568fa957b61cf403a53e10">&#9670;&nbsp;</a></span>getGrad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::getGrad </td>
          <td>(</td>
          <td class="paramtype">Element *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1Vector3.html">Vector3</a> const &amp;&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1Vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>grad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the gradient of a scalar field w.r.t. global coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>The local coordinates in the element. </td></tr>
    <tr><td class="paramname">grad</td><td>The gradient vector at that point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e4edc5bad16354c92a63f8d275cc0bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e4edc5bad16354c92a63f8d275cc0bb">&#9670;&nbsp;</a></span>getGradBF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::getGradBF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1FieldShape.html">FieldShape</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceapf.html#a2432d4261391eda474007fb25c097a5c">MeshElement</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1Vector3.html">Vector3</a> const &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NewArray&lt; <a class="el" href="classapf_1_1Vector3.html">Vector3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>gradBF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get global gradients of basis functions over a mesh element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gradBF</td><td>nodal array of gradients of basis functions evaluated at p </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af62e9232d16aa3aa18e08384e3c2c4e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af62e9232d16aa3aa18e08384e3c2c4e4">&#9670;&nbsp;</a></span>getH1Shape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapf_1_1FieldShape.html">FieldShape</a>* apf::getH1Shape </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the H1 shapes of a given order. </p>
<p>These are hierarchic shapes that are compatible with MFEM's impl. </p>

</div>
</div>
<a id="a1a0aba576e8b368d1b7a20cba45f52c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a0aba576e8b368d1b7a20cba45f52c0">&#9670;&nbsp;</a></span>getHierarchic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapf_1_1FieldShape.html">FieldShape</a>* apf::getHierarchic </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the quadratic hierarchic shape function. </p>
<p>only first and second order so far </p>

</div>
</div>
<a id="a7e2f7a90a99e25e31dd5441b39f08f11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e2f7a90a99e25e31dd5441b39f08f11">&#9670;&nbsp;</a></span>getIntPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::getIntPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceapf.html#a2432d4261391eda474007fb25c097a5c">MeshElement</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1Vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an integration point in an element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>The polynomial order of accuracy. </td></tr>
    <tr><td class="paramname">point</td><td>The integration point number. </td></tr>
    <tr><td class="paramname">param</td><td>The resulting local coordinate of the integration point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f08a4de2c81f3dcff5d93fb0f33e1f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f08a4de2c81f3dcff5d93fb0f33e1f5">&#9670;&nbsp;</a></span>getIntWeight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apf::getIntWeight </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceapf.html#a2432d4261391eda474007fb25c097a5c">MeshElement</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the weight of an integration point in an element. </p>
<p>All integration point tables in APF are scaled such that the sum of the weights equals the area of of the parent element. </p>

</div>
</div>
<a id="a7b1b318dc5a6c5f6167ab4614ff138cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b1b318dc5a6c5f6167ab4614ff138cd">&#9670;&nbsp;</a></span>getIPFitShape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapf_1_1FieldShape.html">FieldShape</a>* apf::getIPFitShape </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the IP Fit shape function. </p>
<p>the IP Fit <a class="el" href="classapf_1_1FieldShape.html" title="Describes field distribution and shape functions.">FieldShape</a> is equivalent to the IPShape except that it is capable of evaluating as a shape function whose value at any point in the element is a polynomial fit to the integration point data in that element. </p>

</div>
</div>
<a id="a3bb55d5a00dbc06ae779d4b36084777c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bb55d5a00dbc06ae779d4b36084777c">&#9670;&nbsp;</a></span>getIPShape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapf_1_1FieldShape.html">FieldShape</a>* apf::getIPShape </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Integration Point distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dimension</td><td>The dimensionality of the elements </td></tr>
    <tr><td class="paramname">order</td><td>The order of accuracy, determines the integration points</td></tr>
  </table>
  </dd>
</dl>
<p>This allows users to create a field which has values at the integration points of elements. Orders 1 to 3 for dimension 2 or 3 are available </p>

</div>
</div>
<a id="a53933a5e18058aafd842e6ecb75d5759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53933a5e18058aafd842e6ecb75d5759">&#9670;&nbsp;</a></span>getJacobianDeterminant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apf::getJacobianDeterminant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Matrix3x3.html">Matrix3x3</a> const &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimension</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the Jacobian determinant or dimensional equivalent. </p>
<p>this is a special function taking into account the various formulae for differential volume, area, lenght, etc. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">J</td><td>Jacobian matrix, vector gradient of coordinate field with respect to parent element coordinates </td></tr>
    <tr><td class="paramname">dimension</td><td>spacial dimension of the entity being measured </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a038f86d6baa21578815f05d0ab592330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a038f86d6baa21578815f05d0ab592330">&#9670;&nbsp;</a></span>getJacobianInv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::getJacobianInv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceapf.html#a2432d4261391eda474007fb25c097a5c">MeshElement</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1Vector3.html">Vector3</a> const &amp;&#160;</td>
          <td class="paramname"><em>local</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1Matrix3x3.html">Matrix3x3</a> &amp;&#160;</td>
          <td class="paramname"><em>jinv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the Jacobian inverse at a local point. </p>
<p>computes the Moore-Penrose psuedo-inverse of J. This is needed to handle non-square Jacobians that arise from edges embedded in 2D or higher and faces embeded in 3D. If J is invertible, the Moore-Penrose inverse equals the inverse. </p>

</div>
</div>
<a id="a93d6933d64022aa4a3a5c0902eed5856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93d6933d64022aa4a3a5c0902eed5856">&#9670;&nbsp;</a></span>getLagrange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapf_1_1FieldShape.html">FieldShape</a>* apf::getLagrange </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Lagrangian shape function of some polynomial order. </p>
<p>we have only first and second order so far </p>

</div>
</div>
<a id="ac591ef6eec60cf7f72077aaa2a3eb99f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac591ef6eec60cf7f72077aaa2a3eb99f">&#9670;&nbsp;</a></span>getLinearCentroid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapf_1_1Vector3.html">Vector3</a> apf::getLinearCentroid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshEntity *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the average of the entity's vertex coordinates </p>
<p>this also works if given just a vertex, so its a convenient way to get the centroid of any entity </p>

</div>
</div>
<a id="aab9088db5d09e32dc5add2ae9c4f056e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab9088db5d09e32dc5add2ae9c4f056e">&#9670;&nbsp;</a></span>getMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::getMatrix </td>
          <td>(</td>
          <td class="paramtype">Element *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1Vector3.html">Vector3</a> const &amp;&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1Matrix3x3.html">Matrix3x3</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the value of a matrix field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>The local coordinates in the element. </td></tr>
    <tr><td class="paramname">value</td><td>The field value at that point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2136dffb47de654b729396362b79bda4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2136dffb47de654b729396362b79bda4">&#9670;&nbsp;</a></span>getMatrixGrad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::getMatrixGrad </td>
          <td>(</td>
          <td class="paramtype">Element *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1Vector3.html">Vector3</a> const &amp;&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1Vector.html">Vector</a>&lt; 27 &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the gradient of a matrix field </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>The local coordinate in the element. </td></tr>
    <tr><td class="paramname">value</td><td>the gradient of the field at a point. If the matrix is defined by A_{ij}, the gradient $\frac{\partial A_{ij}}{\partial X_k}=value[i*3+j+9*k]$ . </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c6382a417b2c47b4140ccda120c92fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c6382a417b2c47b4140ccda120c92fd">&#9670;&nbsp;</a></span>getMdsEntity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MeshEntity* apf::getMdsEntity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh2.html">Mesh2</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>retrieve an entity by dimension and index </p>
<p>indices follow iteration order, so this function is equivalent to iterating (index) times, but is actually much faster than that. this function only works when the arrays have no gaps, so call <a class="el" href="namespaceapf.html#a74f9b7315893d20ac27d3b32efa453c7" title="apply adjacency-based reordering">apf::reorderMdsMesh</a> after any mesh modification. </p>

</div>
</div>
<a id="afbeaf82d73a7bf53e1429add81f06bfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbeaf82d73a7bf53e1429add81f06bfe">&#9670;&nbsp;</a></span>getMdsIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int apf::getMdsIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh2.html">Mesh2</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshEntity *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the dimension-unique index for this entity </p>
<p>this function only works when the arrays have no gaps, so call <a class="el" href="namespaceapf.html#a74f9b7315893d20ac27d3b32efa453c7" title="apply adjacency-based reordering">apf::reorderMdsMesh</a> after any mesh modification. </p>

</div>
</div>
<a id="a2d835945b28d94e965f12490e578f7a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d835945b28d94e965f12490e578f7a1">&#9670;&nbsp;</a></span>getMeshElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceapf.html#a2432d4261391eda474007fb25c097a5c">MeshElement</a>* apf::getMeshElement </td>
          <td>(</td>
          <td class="paramtype">Element *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the <a class="el" href="classapf_1_1Mesh.html" title="Interface to a mesh part.">Mesh</a> Element of a Field Element. </p>
<p>Each apf::Element operates over an <a class="el" href="namespaceapf.html#a2432d4261391eda474007fb25c097a5c" title="Mesh Elements represent the mesh coordinate vector field.">apf::MeshElement</a>, which must be maintained as long as the apf::Element exists. Multiple apf::Elements may share an <a class="el" href="namespaceapf.html#a2432d4261391eda474007fb25c097a5c" title="Mesh Elements represent the mesh coordinate vector field.">apf::MeshElement</a>. </p>

</div>
</div>
<a id="aa5a6911a0f79a056f07fcc7c4208b2c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5a6911a0f79a056f07fcc7c4208b2c0">&#9670;&nbsp;</a></span>getMinor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t M, std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapf_1_1Matrix.html">Matrix</a>&lt;M-1,N-1&gt; apf::getMinor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Matrix.html">Matrix</a>&lt; M, N &gt; const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the minor matrix associated with entry (i,j) of matrix A </p>
<p>this is only instantiated for square matrices up to 4 by 4 </p>

</div>
</div>
<a id="a9c9303c704c21ebdc1eca5381941fe4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c9303c704c21ebdc1eca5381941fe4a">&#9670;&nbsp;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* apf::getName </td>
          <td>(</td>
          <td class="paramtype">Field *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of a Field. </p>
<p>Both for use convenience and for technical reasons related to tagging, each Field should have a unique name. </p>

</div>
</div>
<a id="a9467a0599c5ac57b5c0f7b8ceda3d4db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9467a0599c5ac57b5c0f7b8ceda3d4db">&#9670;&nbsp;</a></span>getNedelec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapf_1_1FieldShape.html">FieldShape</a>* apf::getNedelec </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Nedelec shape function of a given order. </p>
<p>TODO: complete later </p>

</div>
</div>
<a id="a93b7f4e66b2310574df6d62f915bbc84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93b7f4e66b2310574df6d62f915bbc84">&#9670;&nbsp;</a></span>getNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::getNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceapf.html#a662a796b32a9173981bfc6e1ebe60ba1">Numbering</a> *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicArray&lt; <a class="el" href="structapf_1_1Node.html">Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get an array of numbered nodes </p>
<p>the array is sorted by dimension first and then by mesh iterator order </p>

</div>
</div>
<a id="a18897db6d81708aa09febf8625effb40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18897db6d81708aa09febf8625effb40">&#9670;&nbsp;</a></span>getNodesOnClosure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::getNodesOnClosure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ModelEntity *&#160;</td>
          <td class="paramname"><em>me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicArray&lt; <a class="el" href="structapf_1_1Node.html">Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>on</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1FieldShape.html">FieldShape</a> *&#160;</td>
          <td class="paramname"><em>sh</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get nodes on the closure of a model entity </p>
<p>all local nodes associated with mesh entities classified on the closure of the model entity are returned. this is useful for applying boundary conditions, and correctly handles cases when a part has, for example, vertices classified on the edge of a model face, but none of the triangles classified on the model face itself. </p>

</div>
</div>
<a id="a93114a205e5418c53c8f72951d61d527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93114a205e5418c53c8f72951d61d527">&#9670;&nbsp;</a></span>getScalar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apf::getScalar </td>
          <td>(</td>
          <td class="paramtype">Element *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1Vector3.html">Vector3</a> const &amp;&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate a scalar field at a point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>The local coordinates in the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The field value at that point. </dd></dl>

</div>
</div>
<a id="a21f49dd1ad24649b6feb4ade5b97e2c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21f49dd1ad24649b6feb4ade5b97e2c6">&#9670;&nbsp;</a></span>getScalar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apf::getScalar </td>
          <td>(</td>
          <td class="paramtype">Field *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshEntity *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the node value of a scalar field. </p>
<dl class="section return"><dt>Returns</dt><dd>The field value at that node. </dd></dl>

</div>
</div>
<a id="a12329911aa8d53e5db0eb00d18c86882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12329911aa8d53e5db0eb00d18c86882">&#9670;&nbsp;</a></span>getShapeGrads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::getShapeGrads </td>
          <td>(</td>
          <td class="paramtype">Element *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1Vector3.html">Vector3</a> const &amp;&#160;</td>
          <td class="paramname"><em>local</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NewArray&lt; <a class="el" href="classapf_1_1Vector3.html">Vector3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>grads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the shape function gradients at a point. </p>
<p>these are gradients with respect to global coordinates. </p>

</div>
</div>
<a id="a4af5199eceb8f2e3e066c77d9e7392a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4af5199eceb8f2e3e066c77d9e7392a3">&#9670;&nbsp;</a></span>getSharing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapf_1_1Sharing.html">Sharing</a>* apf::getSharing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a default sharing object for this mesh </p>
<p>for normal meshes, the sharing object just describes remote copies. For matched meshes, the sharing object describes matches for matched entities and remote copies for other entities </p>

</div>
</div>
<a id="ad575d3d0b4e2c208ff9eda31b4f0b281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad575d3d0b4e2c208ff9eda31b4f0b281">&#9670;&nbsp;</a></span>getVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::getVector </td>
          <td>(</td>
          <td class="paramtype">Element *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1Vector3.html">Vector3</a> const &amp;&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1Vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate a vector field at a point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>The local coordinates in the element. </td></tr>
    <tr><td class="paramname">value</td><td>The field value at that point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c85fe4ca92302918d0820aec729a2f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c85fe4ca92302918d0820aec729a2f3">&#9670;&nbsp;</a></span>getVectorGrad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::getVectorGrad </td>
          <td>(</td>
          <td class="paramtype">Element *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1Vector3.html">Vector3</a> const &amp;&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1Matrix3x3.html">Matrix3x3</a> &amp;&#160;</td>
          <td class="paramname"><em>deriv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the gradient of a vector field w.r.t. global coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>The local coordinates in the element. </td></tr>
    <tr><td class="paramname">deriv</td><td>The gradient matrix at that point.</td></tr>
  </table>
  </dd>
</dl>
<p>Note: The return parameter component deriv[j][i] stores the value $(grad u)_{i,j} = \frac{\partial u_i} / \frac{\partial x_j}$, where $u$ is the vector field of interest, i is the vector index, and j is the derivative index. </p>

</div>
</div>
<a id="a7a0eda0e2d7d8943e38deac40e7ca168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a0eda0e2d7d8943e38deac40e7ca168">&#9670;&nbsp;</a></span>getVectorShapeValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::getVectorShapeValues </td>
          <td>(</td>
          <td class="paramtype">Element *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1Vector3.html">Vector3</a> const &amp;&#160;</td>
          <td class="paramname"><em>local</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NewArray&lt; <a class="el" href="classapf_1_1Vector3.html">Vector3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the vector shape function values at a point. </p>
<p>used only for Nedelec shapes (Piola transformation used to map from parent to physical coordinates) </p>

</div>
</div>
<a id="a0c16cb6e7b8fd7d0a3411d1a91d6f4fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c16cb6e7b8fd7d0a3411d1a91d6f4fd">&#9670;&nbsp;</a></span>getVoronoiShape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapf_1_1FieldShape.html">FieldShape</a>* apf::getVoronoiShape </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Voronoi shape function. </p>
<p>the Voronoi <a class="el" href="classapf_1_1FieldShape.html" title="Describes field distribution and shape functions.">FieldShape</a> is equivalent to the IPShape except that it is capable of evaluating as a shape function whose value at any point in the element is the value of the closest integration point in that element. </p>

</div>
</div>
<a id="ae8a792eebd35597732f4ff0b4f63dab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8a792eebd35597732f4ff0b4f63dab3">&#9670;&nbsp;</a></span>initResidence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::initResidence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh2.html">Mesh2</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set entity residence based on remote copies. </p>
<p>this function acts on all entities of one dimension </p>

</div>
</div>
<a id="a860880da18799bb81b55f5a8cd4e648f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a860880da18799bb81b55f5a8cd4e648f">&#9670;&nbsp;</a></span>loadMdsFromANSYS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapf_1_1Mesh2.html">Mesh2</a>* apf::loadMdsFromANSYS </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nodefile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>elemfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcu::PCU *&#160;</td>
          <td class="paramname"><em>PCUObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>load an MDS mesh from ANSYS .node and .elem files </p>
<p>this call takes two filenames, one for a .node and another for a .elem file.</p>
<p>the resulting MDS mesh will be constructed with a null geometric model via gmi_load(".null"), so be sure to call gmi_register_null before this function.</p>
<p>currently, ANSYS element types SOLID72 and SOLID92 are supported, which become linear and quadratic tetrahedra, respectively. </p>

</div>
</div>
<a id="acceabc812612189f46a8b76ae696e1a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acceabc812612189f46a8b76ae696e1a5">&#9670;&nbsp;</a></span>loadMdsMesh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapf_1_1Mesh2.html">Mesh2</a>* apf::loadMdsMesh </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>modelfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>meshfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcu::PCU *&#160;</td>
          <td class="paramname"><em>PCUObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>load an MDS mesh and model from file </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">modelfile</td><td>will be passed to gmi_load to get the model </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>gmi_register_mesh and gmi_register_null need to be called before this function. Also, gmi_register_sim may also be called to enable loading of GeomSim, Parasolid, and ACIS models </dd></dl>

</div>
</div>
<a id="a4a68d0848bbc927582586a38c3ebc85a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a68d0848bbc927582586a38c3ebc85a">&#9670;&nbsp;</a></span>loadMdsMesh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapf_1_1Mesh2.html">Mesh2</a>* apf::loadMdsMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgmi__model.html">gmi_model</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>meshfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcu::PCU *&#160;</td>
          <td class="paramname"><em>PCUObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>load an MDS mesh from files </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>the geometric model interface </td></tr>
    <tr><td class="paramname">meshfile</td><td>The path to an SMB format mesh. If the path is "something"".smb", then the file "somethingN.smb" will be loaded where N is the part number. If the path is "something/", then the file "something/N.smb" will be loaded. For both of these cases, if the path is prepended with "bz2:", then it will be uncompressed using PCU file IO functions. Calling <a class="el" href="classapf_1_1Mesh.html#a00056030e75df8955ab08eb055b906b4" title="write the underlying mesh into a set of files">apf::Mesh::writeNative</a> on the resulting object will do the same in reverse. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad75e869033ad646273d19238c95490ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad75e869033ad646273d19238c95490ed">&#9670;&nbsp;</a></span>makeEmptyMdsMesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapf_1_1Mesh2.html">Mesh2</a>* apf::makeEmptyMdsMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgmi__model.html">gmi_model</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isMatched</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcu::PCU *&#160;</td>
          <td class="paramname"><em>PCUObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create an empty MDS part </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>the geometric model interface </td></tr>
    <tr><td class="paramname">dim</td><td>the eventual mesh dimension. MDS needs to allocate arrays based on this before users add entities. </td></tr>
    <tr><td class="paramname">isMatched</td><td>whether or not there will be matched entities </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96f0844e05ef6ed735ebb0784c761ee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f0844e05ef6ed735ebb0784c761ee8">&#9670;&nbsp;</a></span>makeGlobal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceapf.html#a691865cc4ddfa6781e8aba4e338617e8">GlobalNumbering</a>* apf::makeGlobal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceapf.html#a662a796b32a9173981bfc6e1ebe60ba1">Numbering</a> *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>destroy</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>converts a local numbering into a global numbering. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destroy</td><td>Should the input Numbering* be destroyed?</td></tr>
  </table>
  </dd>
</dl>
<p>the original local numbering is destroyed. All local numbers are increased by an offset; the offset on part P is the sum of the numbered nodes on parts [0,P-1].</p>
<p>this is done in O(log N) time in parallel, where N is the part count.</p>
<p>this function has no intrinsic knowledge of ownership, it operates simply on nodes which have been explicitly numbered. the input to this function is usually a numbering produced by a numberOwned* function, and the result is a global numbering of all the owned nodes. subsequently calling synchronize on the global numbering completes the typical process which leaves all nodes (owned and not) with a global number attached. </p>

</div>
</div>
<a id="a06e7fc3b4f495d47ab6af0020f36ebfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06e7fc3b4f495d47ab6af0020f36ebfc">&#9670;&nbsp;</a></span>makeZoltanBalancer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapf_1_1Balancer.html">Balancer</a>* apf::makeZoltanBalancer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">Mesh</a> *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>approach</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a Zoltan <a class="el" href="classapf_1_1Balancer.html" title="Load balance over all mesh parts.">Balancer</a> object. </p>
<p>this <a class="el" href="classapf_1_1Balancer.html" title="Load balance over all mesh parts.">Balancer</a> will apply Zoltan to the global mesh to improve load balance.</p>
<p>Also note that this <a class="el" href="classapf_1_1Balancer.html" title="Load balance over all mesh parts.">Balancer</a> will create a Zoltan edge between two elements that share matched faces. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">method</td><td>select from <a class="el" href="namespaceapf.html#a43962b2ec3f0b13035fcdd6b605c0542" title="Zoltan partitioning method.">apf::ZoltanMethod</a> </td></tr>
    <tr><td class="paramname">approach</td><td>select from <a class="el" href="namespaceapf.html#a4cbe5a6d7973e9a17036406a3cead028" title="Zoltan partitioning approach.">apf::ZoltanApproach</a> </td></tr>
    <tr><td class="paramname">debug</td><td>print the full Zoltan configuration </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7948c4241abc16e6fccfef9892d61311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7948c4241abc16e6fccfef9892d61311">&#9670;&nbsp;</a></span>makeZoltanGlobalSplitter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapf_1_1Splitter.html">Splitter</a>* apf::makeZoltanGlobalSplitter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">Mesh</a> *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>approach</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a Zoltan <a class="el" href="classapf_1_1Splitter.html" title="Splits a mesh part into many.">Splitter</a> object. </p>
<p>the resulting splitter will apply Zoltan to the global mesh part to break it into several new parts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">method</td><td>select from <a class="el" href="namespaceapf.html#a43962b2ec3f0b13035fcdd6b605c0542" title="Zoltan partitioning method.">apf::ZoltanMethod</a> </td></tr>
    <tr><td class="paramname">approach</td><td>select from <a class="el" href="namespaceapf.html#a4cbe5a6d7973e9a17036406a3cead028" title="Zoltan partitioning approach.">apf::ZoltanApproach</a> </td></tr>
    <tr><td class="paramname">debug</td><td>print the full Zoltan configuration when splitting </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8074bec4c889d9ed3a76a2c178e3e9a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8074bec4c889d9ed3a76a2c178e3e9a9">&#9670;&nbsp;</a></span>makeZoltanSplitter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapf_1_1Splitter.html">Splitter</a>* apf::makeZoltanSplitter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">Mesh</a> *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>approach</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a Zoltan <a class="el" href="classapf_1_1Splitter.html" title="Splits a mesh part into many.">Splitter</a> object. </p>
<p>the resulting splitter will apply Zoltan to the local mesh part to break it into several new parts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">method</td><td>select from <a class="el" href="namespaceapf.html#a43962b2ec3f0b13035fcdd6b605c0542" title="Zoltan partitioning method.">apf::ZoltanMethod</a> </td></tr>
    <tr><td class="paramname">approach</td><td>select from <a class="el" href="namespaceapf.html#a4cbe5a6d7973e9a17036406a3cead028" title="Zoltan partitioning approach.">apf::ZoltanApproach</a> </td></tr>
    <tr><td class="paramname">debug</td><td>print the full Zoltan configuration when splitting </td></tr>
    <tr><td class="paramname">sync</td><td>all parts are splitting by the same factor, multiply the part ids in the resulting <a class="el" href="classapf_1_1Migration.html" title="Migration plan object: local elements to destinations.">apf::Migration</a> accordingly </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad11d34d97e12206457c6e1492c7771ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad11d34d97e12206457c6e1492c7771ad">&#9670;&nbsp;</a></span>measure() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apf::measure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshEntity *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measures the volume, area, or length of a <a class="el" href="classapf_1_1Mesh.html" title="Interface to a mesh part.">Mesh</a> Entity. </p>
<dl class="section return"><dt>Returns</dt><dd>The measure of the element </dd></dl>

</div>
</div>
<a id="a611fe911507d50e2bb4702522f66ab83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a611fe911507d50e2bb4702522f66ab83">&#9670;&nbsp;</a></span>measure() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double apf::measure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceapf.html#a2432d4261391eda474007fb25c097a5c">MeshElement</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measures the volume, area, or length of a <a class="el" href="classapf_1_1Mesh.html" title="Interface to a mesh part.">Mesh</a> Element. </p>
<p>By integrating the differential volume over the element, a general measure is obtained. This correctly measures curved meshes.</p>
<dl class="section return"><dt>Returns</dt><dd>The measure of the element </dd></dl>

</div>
</div>
<a id="aaa1384bcea95047a1b40c5c105a3a903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa1384bcea95047a1b40c5c105a3a903">&#9670;&nbsp;</a></span>migrate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::migrate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh2.html">Mesh2</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1Migration.html">Migration</a> *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>APF's migration function, works on <a class="el" href="classapf_1_1Mesh2.html" title="Extended mesh interface for modification.">apf::Mesh2</a>. </p>
<p>if your database implements <a class="el" href="classapf_1_1Mesh2.html" title="Extended mesh interface for modification.">apf::Mesh2</a> (and residence is separate from remote copies) then you may use this to implement most of <a class="el" href="classapf_1_1Mesh.html#ab67d6bf48b14aec7a7d85d31e061410d" title="Migrate elements.">apf::Mesh::migrate</a>. Users of APF are encouraged to call <a class="el" href="classapf_1_1Mesh.html#ab67d6bf48b14aec7a7d85d31e061410d" title="Migrate elements.">apf::Mesh::migrate</a> instead of calling this directly </p>

</div>
</div>
<a id="a731461d2b82dd5a3298466daea7378a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a731461d2b82dd5a3298466daea7378a1">&#9670;&nbsp;</a></span>numberOverlapNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceapf.html#a662a796b32a9173981bfc6e1ebe60ba1">Numbering</a>* apf::numberOverlapNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">Mesh</a> *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1FieldShape.html">FieldShape</a> *&#160;</td>
          <td class="paramname"><em>s</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>number all local nodes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>if non-zero, use nodes from this <a class="el" href="classapf_1_1FieldShape.html" title="Describes field distribution and shape functions.">FieldShape</a>, otherwise use the mesh's coordinate nodes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade73c5914c4ce70310c7a92b4f99e837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade73c5914c4ce70310c7a92b4f99e837">&#9670;&nbsp;</a></span>numberOwnedNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceapf.html#a662a796b32a9173981bfc6e1ebe60ba1">Numbering</a>* apf::numberOwnedNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">Mesh</a> *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1FieldShape.html">FieldShape</a> *&#160;</td>
          <td class="paramname"><em>s</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapf_1_1Sharing.html">Sharing</a> *&#160;</td>
          <td class="paramname"><em>shr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>number the local owned nodes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>if non-zero, use nodes from this <a class="el" href="classapf_1_1FieldShape.html" title="Describes field distribution and shape functions.">FieldShape</a>, otherwise use the mesh's coordinate nodes </td></tr>
    <tr><td class="paramname">shr</td><td>if non-zero, use this <a class="el" href="structapf_1_1Sharing.html" title="abstract description of entity copy sharing">Sharing</a> to determine ownership, otherwise call <a class="el" href="namespaceapf.html#a4af5199eceb8f2e3e066c77d9e7392a3" title="create a default sharing object for this mesh">apf::getSharing</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae44b6579152d6c9bf8cf994a1aef1fb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae44b6579152d6c9bf8cf994a1aef1fb4">&#9670;&nbsp;</a></span>recoverGradientByVolume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Field* apf::recoverGradientByVolume </td>
          <td>(</td>
          <td class="paramtype">Field *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a nodal gradient field from a nodal input field. </p>
<p>given a nodal field, compute approximate nodal gradient values by giving each node a volume-weighted average of the gradients computed at each element around it. </p>

</div>
</div>
<a id="a69273da0fbc721b7fcd7b07fe426869b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69273da0fbc721b7fcd7b07fe426869b">&#9670;&nbsp;</a></span>remapPartition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::remapPartition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh2.html">apf::Mesh2</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapf_1_1Remap.html">Remap</a> &amp;&#160;</td>
          <td class="paramname"><em>remap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>remap all part ids in the mesh structure </p>
<p>when using sub-group partitioning schemes or splitting meshes (see Parma_SplitPartition or <a class="el" href="classapf_1_1Splitter.html" title="Splits a mesh part into many.">apf::Splitter</a>), it is useful to be able to update all partition model structures in a mesh to reflect a transition from one partitioning scheme to the next.</p>
<p>this function applies the given map to all part ids in the remote copies, resident sets, and matching using the <a class="el" href="classapf_1_1Mesh2.html" title="Extended mesh interface for modification.">apf::Mesh2</a> interface </p>

</div>
</div>
<a id="a49da9cc521228907c81c74158b0eb265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49da9cc521228907c81c74158b0eb265">&#9670;&nbsp;</a></span>reorder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MeshTag* apf::reorder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">Mesh</a> *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number by adjacency graph traversal. </p>
<p>a plain single-integer tag is used to number the vertices and elements of a mesh </p>

</div>
</div>
<a id="a74f9b7315893d20ac27d3b32efa453c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74f9b7315893d20ac27d3b32efa453c7">&#9670;&nbsp;</a></span>reorderMdsMesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::reorderMdsMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh2.html">Mesh2</a> *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshTag *&#160;</td>
          <td class="paramname"><em>t</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>apply adjacency-based reordering </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Optional user-defined ordering of the vertices. Set this to NULL to use the internal ordering system. Otherwise, attach a unique integer to each vertex in the range [0, #vertices). this will indicate the order in which they appear after reordering.</td></tr>
  </table>
  </dd>
</dl>
<p>similar to the algorithm for <a class="el" href="namespaceapf.html#a49da9cc521228907c81c74158b0eb265" title="Number by adjacency graph traversal.">apf::reorder</a>, this function will traverse adjacencies to reorder each topological type. Then all MDS arrays are re-formed in this new order. An important side effect of this function is that there are no gaps in the MDS arrays after this </p>

</div>
</div>
<a id="adb4c653b78d69109f4ac0f831ca9b43e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb4c653b78d69109f4ac0f831ca9b43e">&#9670;&nbsp;</a></span>rotate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classapf_1_1Matrix3x3.html">Matrix3x3</a> apf::rotate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Vector3.html">Vector3</a> const &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the rotation matrix around an axis </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>the axis to rotate around </td></tr>
    <tr><td class="paramname">a</td><td>the amount of rotation in radians </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3fe3657e4785a44df6b3a822895a004a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fe3657e4785a44df6b3a822895a004a">&#9670;&nbsp;</a></span>setCoords()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::setCoords </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh2.html">Mesh2</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nverts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceapf.html#ad41eed81404b62d897ea31da38a53f73">GlobalToVert</a> &amp;&#160;</td>
          <td class="paramname"><em>globalToVert</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign coordinates to the mesh. </p>
<p>Each peer provides a set of the coordinates. The coords most be ordered according to the global ids of the vertices. Peer 0 provides the coords for vertices 0 to m-1, peer to for m to n-1, ... After this call, all vertices in the <a class="el" href="classapf_1_1Mesh2.html" title="Extended mesh interface for modification.">apf::Mesh2</a> object have correct coordinates assigned. </p>

</div>
</div>
<a id="a0f7441f1006483757cfc8df11ce96d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f7441f1006483757cfc8df11ce96d69">&#9670;&nbsp;</a></span>setMatches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::setMatches </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh2.html">Mesh2</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Gid *&#160;</td>
          <td class="paramname"><em>matches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nverts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceapf.html#ad41eed81404b62d897ea31da38a53f73">GlobalToVert</a> &amp;&#160;</td>
          <td class="paramname"><em>globalToVert</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign matching to the mesh. </p>
<p>Each peer provides a set of the matched entity global ids. An id set to -1 indicates that the vertex is not matched. The ids most be ordered according to the global ids of the vertices. Peer 0 provides the ids for vertices 0 to m-1, peer to for m to n-1, ... After this call, all vertices in the <a class="el" href="classapf_1_1Mesh2.html" title="Extended mesh interface for modification.">apf::Mesh2</a> object have correct coordinates assigned. </p>

</div>
</div>
<a id="a9985cf69e3345d77e51124c81851481c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9985cf69e3345d77e51124c81851481c">&#9670;&nbsp;</a></span>setMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::setMatrix </td>
          <td>(</td>
          <td class="paramtype">Field *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshEntity *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1Matrix3x3.html">Matrix3x3</a> const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the nodal value of a matrix field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The vector value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16770e4cdc54e35c06e86254e5a8355f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16770e4cdc54e35c06e86254e5a8355f">&#9670;&nbsp;</a></span>setMigrationLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::setMigrationLimit </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcu::PCU *&#160;</td>
          <td class="paramname"><em>PCUObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set the maximum elements that <a class="el" href="namespaceapf.html#aaa1384bcea95047a1b40c5c105a3a903" title="APF&#39;s migration function, works on apf::Mesh2.">apf::migrate</a> moves at once </p>
<p><a class="el" href="namespaceapf.html#aaa1384bcea95047a1b40c5c105a3a903" title="APF&#39;s migration function, works on apf::Mesh2.">apf::migrate</a> implements gradual limited migration in an effort to help applications keep memory use to a minimum. This function globally sets the limit on migration, which causes any migration requests greater than the limit to be performed as several consecutive migrations. </p>

</div>
</div>
<a id="a062b8132296bdfc66e8d77f2137fdb0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a062b8132296bdfc66e8d77f2137fdb0f">&#9670;&nbsp;</a></span>setScalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::setScalar </td>
          <td>(</td>
          <td class="paramtype">Field *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshEntity *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a nodal value of a scalar field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node number within the entity. So far, it is just 0 for vertices and for edges in 2nd order. higher order will bring more nodes per edge and onto faces and such. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab12f19c06db0f1451b1c301b2b163f58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab12f19c06db0f1451b1c301b2b163f58">&#9670;&nbsp;</a></span>setVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::setVector </td>
          <td>(</td>
          <td class="paramtype">Field *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshEntity *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1Vector3.html">Vector3</a> const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the nodal value of a vector field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The vector value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d6feacdf3007409aa31960fd2ff037f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d6feacdf3007409aa31960fd2ff037f">&#9670;&nbsp;</a></span>sharedReduction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::sharedReduction </td>
          <td>(</td>
          <td class="paramtype">Field *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapf_1_1Sharing.html">Sharing</a> *&#160;</td>
          <td class="paramname"><em>shr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>delete_shr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classapf_1_1ReductionOp.html">ReductionOp</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>sum</em> = <code>ReductionSum&lt;&#160;double&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a reudction operator along partition boundaries. </p>
<p>Using the copies described by an <a class="el" href="structapf_1_1Sharing.html" title="abstract description of entity copy sharing">apf::Sharing</a> object, applied the specified operation pairwise to the values of the field on each partition. No guarantee is made about hte order of the pairwise application </p>

</div>
</div>
<a id="a626e7a91743ee2360316fc525a460d9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a626e7a91743ee2360316fc525a460d9e">&#9670;&nbsp;</a></span>stitchMesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::stitchMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh2.html">Mesh2</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>infer all remote copies from those of vertices </p>
<p>given that the remote copies of the vertices are set up correctly, this function will synchronize the remote copies and resident part sets for all other entities correctly. </p>

</div>
</div>
<a id="a654c12ae2c4f2b04312999665d9530e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a654c12ae2c4f2b04312999665d9530e3">&#9670;&nbsp;</a></span>synchronize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::synchronize </td>
          <td>(</td>
          <td class="paramtype">Field *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapf_1_1Sharing.html">Sharing</a> *&#160;</td>
          <td class="paramname"><em>shr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronize field values along partition boundary. </p>
<p>Using the ownership and copies described by an <a class="el" href="structapf_1_1Sharing.html" title="abstract description of entity copy sharing">apf::Sharing</a> object, copy values from the owned nodes to their copies, possibly assigning them values for the first time. </p>

</div>
</div>
<a id="ac2242ed13e21887a766f0d8ccfc34571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2242ed13e21887a766f0d8ccfc34571">&#9670;&nbsp;</a></span>synchronize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::synchronize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceapf.html#a662a796b32a9173981bfc6e1ebe60ba1">Numbering</a> *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapf_1_1Sharing.html">Sharing</a> *&#160;</td>
          <td class="paramname"><em>shr</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>delete_shr</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>numbers non-owned nodes with the values from their owners </p>
<p>Works even if the non-owned nodes have no number currently assigned, after this they are all numbered </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shr</td><td>if non-zero, use this <a class="el" href="structapf_1_1Sharing.html" title="abstract description of entity copy sharing">Sharing</a> model to determine ownership and copies, otherwise call <a class="el" href="namespaceapf.html#a4af5199eceb8f2e3e066c77d9e7392a3" title="create a default sharing object for this mesh">apf::getSharing</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7eb8a13df4b1cd6f42baad3a7d335cb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eb8a13df4b1cd6f42baad3a7d335cb6">&#9670;&nbsp;</a></span>tagOpposites()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MeshTag* apf::tagOpposites </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceapf.html#a691865cc4ddfa6781e8aba4e338617e8">GlobalNumbering</a> *&#160;</td>
          <td class="paramname"><em>gn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tag global ids of opposite elements to boundary faces. </p>
<p>this function creates a LONG tag of one value and attaches to all partition boundary faces the global id of the element on the other side. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gn</td><td>global element numbering </td></tr>
    <tr><td class="paramname">name</td><td>the name of the resulting tag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58901b5327b2cced3d54bac594994ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58901b5327b2cced3d54bac594994ef3">&#9670;&nbsp;</a></span>unfreezeFields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::unfreezeFields </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>unfreeze all associated fields </p>
<p>see apf::unfreezeField </p>

</div>
</div>
<a id="ad72b0dfe3a9ddb52cd9b2a5fcec69591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad72b0dfe3a9ddb52cd9b2a5fcec69591">&#9670;&nbsp;</a></span>unite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::unite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceapf.html#a29a3b61c20263ec345eed4108116ccfb">Parts</a> &amp;&#160;</td>
          <td class="paramname"><em>into</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceapf.html#a29a3b61c20263ec345eed4108116ccfb">Parts</a> const &amp;&#160;</td>
          <td class="paramname"><em>from</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>unite two sets of unique part ids </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">into</td><td>becomes the union </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aacc951388f86b0fcce7a428905d09203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacc951388f86b0fcce7a428905d09203">&#9670;&nbsp;</a></span>verify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::verify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abort_on_error</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>run consistency checks on an <a class="el" href="classapf_1_1Mesh.html" title="Interface to a mesh part.">apf::Mesh</a> structure </p>
<p>this can be used to implement <a class="el" href="classapf_1_1Mesh.html#a581c9102d05ed9399242e77e9fa96839" title="run a set of consistency checks on the underlying data structure">apf::Mesh::verify</a>. Other implementations may define their own. </p>

</div>
</div>
<a id="a022623745e62596e3670032e550c2362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a022623745e62596e3670032e550c2362">&#9670;&nbsp;</a></span>writeASCIIVtkFiles() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::writeASCIIVtkFiles </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a set of parallel VTK Unstructured <a class="el" href="classapf_1_1Mesh.html" title="Interface to a mesh part.">Mesh</a> files from an <a class="el" href="classapf_1_1Mesh.html" title="Interface to a mesh part.">apf::Mesh</a> with ASCII encoding. </p>
<p>Nodal fields whose shape differs from the mesh shape will not be output. Fields with incomplete data will not be output. </p>

</div>
</div>
<a id="a0fed5ae41533bb1ae81c03a4422e6d54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fed5ae41533bb1ae81c03a4422e6d54">&#9670;&nbsp;</a></span>writeASCIIVtkFiles() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::writeASCIIVtkFiles </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>writeFields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a set of parallel VTK Unstructured <a class="el" href="classapf_1_1Mesh.html" title="Interface to a mesh part.">Mesh</a> files from an <a class="el" href="classapf_1_1Mesh.html" title="Interface to a mesh part.">apf::Mesh</a> with ASCII encoding. </p>
<p>Only fields whose name appears in the vector writeFields will be output. Nodal fields whose shape differs from the mesh shape will not be output. Fields with incomplete data will not be output. </p>

</div>
</div>
<a id="aad7c9deb4ebfe9510973ed3c568ac7ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad7c9deb4ebfe9510973ed3c568ac7ec">&#9670;&nbsp;</a></span>writeNedelecVtkFiles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::writeNedelecVtkFiles </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output .vtk files with ASCII encoding for this part. </p>
<p>this function is useful for debugging meshes with Nedelec fields on them. </p>

</div>
</div>
<a id="a62142dfe765839a3c5493cb1f12caf7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62142dfe765839a3c5493cb1f12caf7c">&#9670;&nbsp;</a></span>writeOneVtkFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::writeOneVtkFile </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output just the .vtu file with ASCII encoding for this part. </p>
<p>this function is useful for debugging large parallel meshes. </p>

</div>
</div>
<a id="ac224e97b2c5827c9d8b3be218466e379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac224e97b2c5827c9d8b3be218466e379">&#9670;&nbsp;</a></span>writeVtkFiles() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::writeVtkFiles </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cellDim</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a set of parallel VTK Unstructured <a class="el" href="classapf_1_1Mesh.html" title="Interface to a mesh part.">Mesh</a> files from an <a class="el" href="classapf_1_1Mesh.html" title="Interface to a mesh part.">apf::Mesh</a> with binary (base64) encoding and zlib compression (if LION_COMPRESS=ON) </p>
<p>Nodal fields whose shape differs from the mesh shape will not be output. Fields with incomplete data will not be output. </p>

</div>
</div>
<a id="aa549df4e77abc8f2900ff95cb34fe12e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa549df4e77abc8f2900ff95cb34fe12e">&#9670;&nbsp;</a></span>writeVtkFiles() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apf::writeVtkFiles </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classapf_1_1Mesh.html">Mesh</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>writeFields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cellDim</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a set of parallel VTK Unstructured <a class="el" href="classapf_1_1Mesh.html" title="Interface to a mesh part.">Mesh</a> files from an <a class="el" href="classapf_1_1Mesh.html" title="Interface to a mesh part.">apf::Mesh</a> with binary (base64) encoding and zlib compression (if LION_COMPRESS=ON) </p>
<p>Only fields whose name appears in the vector writeFields will be output. Nodal fields whose shape differs from the mesh shape will not be output. Fields with incomplete data will not be output. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a59d5b986f43beadd2e9967a366850a0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59d5b986f43beadd2e9967a366850a0a">&#9670;&nbsp;</a></span>pi</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double const apf::pi</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The mathematical constant pi. </p>
<p>although it doesn't fit perfectly in this header, there is no more appropriate place for this in APF. </p>

</div>
</div>
</div><!-- contents -->
<hr class="footer"/><address class="footer"><small>
Generated for SCOREC core by&nbsp;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.9.1</small></address>
</body>
</html>
